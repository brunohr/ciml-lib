## Bibliotecas
import copy #Para utilizar deepcopy
from random import *
import gc
import random as r
import time
import numpy as np
import os.path

#### ---- INÍCIO DA LEITURA DOS ARQUIVOS TTDF ---- ####

if os.path.isfile("tabela_verdade.ttdf") == True:
#**# ---> Parâmetros padrão (caso não esteja especificado no TTDF) ---- #**#
    nc = 100
    nr = 1
    lb = 100
    GLOBAL_SAM_MUTACOES = 1
    GLOBAL_NUM_GERACOES = 25000
    GLOBAL_NUM_AVALIACOES = 100000
    GLOBAL_QTD_TESTES = 30
#**# ------------------------------------------------------------------ #**#
    verifica_outputs = False
    tabela = open("tabela_verdade.ttdf", "r")
    INPUTS = []
    OUTPUTS = []
    for linha in tabela:
        if linha.find("nc") == True:
            linha.strip()
            nc = (linha[3:].strip())
            nc = int(nc)
            #print("Número de colunas: " + str(nc))
        if linha.find("nr") == True:
            linha.strip()
            nr = (linha[3:].strip())
            nr = int(nr)
            #print("Número de linhas: " + str(nr))              
        if linha.find("lb") == True:
            linha.strip()
            lb = (linha[3:].strip())
            lb = int(nc)
            #print("Levels-back: " + str(lb))
        if linha.find("mut") == True:
            linha.strip()
            GLOBAL_SAM_MUTACOES = (linha[4:].strip())
            GLOBAL_SAM_MUTACOES = int(GLOBAL_SAM_MUTACOES)
            #print("Quantidade de genes ativos mutados: " + str(GLOBAL_SAM_MUTACOES))
        if linha.find("numeval") == True:
            linha.strip()
            GLOBAL_NUM_AVALIACOES = (linha[8:].strip())
            GLOBAL_NUM_AVALIACOES = int(GLOBAL_NUM_AVALIACOES)
            #print("Número de grações: " + str(GLOBAL_NUM_GERACOES))
        if linha.find("testes") == True:
            linha.strip()
            GLOBAL_QTD_TESTES = (linha[7:].strip())
            GLOBAL_QTD_TESTES = int(GLOBAL_QTD_TESTES)
            #print("Quantidade de testes: " + str(GLOBAL_QTD_TESTES))         
        if linha.find("inputs") == True:
            linha.strip()
            numero_inputs = (linha[7:].strip())
            numero_inputs = int(numero_inputs)
            for i in range(numero_inputs):
                INPUTS.append([])
        if linha.find("outputs") == True:
            linha.strip()
            numero_outputs = (linha[8:].strip())
            numero_outputs = int(numero_outputs)
            for i in range(numero_outputs):
                OUTPUTS.append([])
        if verifica_outputs == True:
            if linha.find("end") == True:
                verifica_outputs = False
            else:
                saida_atual = linha.split()
                for i in range(numero_outputs):
                    OUTPUTS[i].append(int(saida_atual[0][i]))

        if linha.find("start") == True:
            verifica_outputs = True

    for i in range(numero_inputs):
        while len(INPUTS[numero_inputs - i - 1]) != pow(2,numero_inputs):
            for j in range(pow(2,i)):
                INPUTS[numero_inputs - i - 1].append(0)
            for j in range(pow(2,i)):
                INPUTS[numero_inputs - i - 1].append(1)

else:
    print("Descrição da tabela verdade não encontrada!")
    print("\nComo deseja proceder?")
    print("\n 1 - Inserir manualmente")
    print("\n 2 - Finalizar execução")
    resposta = int(input("\n"))
    if resposta == 1:
        print("INSERIR MANUALMENTE")
        INPUTS = []
        OUTPUTS = []
        numero_inputs = int(input("\n Insira o número de inputs: "))
        for i in range(numero_inputs):
            INPUTS.append([])
        for i in range(numero_inputs):
            while len(INPUTS[numero_inputs - i - 1]) != pow(2,numero_inputs):
                for j in range(pow(2,i)):
                    INPUTS[numero_inputs - i - 1].append(0)
                for j in range(pow(2,i)):
                    INPUTS[numero_inputs - i - 1].append(1)        
        numero_outputs = int(input("\n Insira o número de outputs: "))
        for i in range(numero_outputs):
            OUTPUTS.append([])
        for i in range(numero_outputs):
            k = 0
            while k < pow(2, numero_inputs):
                adicionar_valor = int(input("\n  Digite o valor do bit " + str(k) + " da saída " + str(i) + " "))
                OUTPUTS[i].append(adicionar_valor)
                k += 1
            print("\n")
        nr = int(input("\n Insira o número de linhas: "))
        nc = int(input("\n Insira o número de colunas: "))
        lb = int(input("\n Insira o valor de levels-back: "))
        GLOBAL_SAM_MUTACOES = int(input("\n Insira o número de genes ativos mutados por iteração: "))
        GLOBAL_NUM_AVALIACOES = int(input("\n Insira o número máximo de avaliações permitidas: "))
        GLOBAL_QTD_TESTES = int(input("\n Insira a quantidade de execuções independentes: "))
        
    elif resposta == 2:
        exit()


#### ---- FIM DA LEITURA DOS ARQUIVOS TTDF ---- ####
GLOBAL_MUTACAO_GAM_INPUT = [0]
GLOBAL_MUTACAO_GAM_SAIDA = [0]
GLOBAL_MUTACAO_GAM_PORTA = [0]
GLOBAL_MUTACAO_GAM_INATIVO = [0]
GLOBAL_MUTACAO_GAM_ATIVO = [0]

GLOBAL_MUTACAO_SAM_INPUT = [0]
GLOBAL_MUTACAO_SAM_SAIDA = [0]
GLOBAL_MUTACAO_SAM_PORTA = [0]
GLOBAL_MUTACAO_SAM_INATIVO = [0]
GLOBAL_MUTACAO_SAM_ATIVO = [0]


GLOBAL_QTD_CROSSOVER = [0]
GLOBAL_QTD_CROSSOVER_SAIDA = [0]


## Parâmetros Ajustáveis
#nc = 100 # Número de Colunas (definido na leitura do arquivo)
#nr = 1 # Número de Linhas (definido na leitura do arquivo)
#lb = 100 # Levels-Back (definido na leitura do arquivo)
        
ni = numero_inputs # Número de Entradas
no = numero_outputs # Número de Saídas

max_entradas = 2 # Número de máximos de conexões por porta lógica

ur = 1 # Taxa de mutação (em %)
ee_lambda = 4 #Lambda para estratégias de evolução

#GLOBAL_SAM_MUTACOES = 1 (definido na leitura do arquivo)
#GLOBAL_NUM_GERACOES = 2500 (definido na leitura do arquivo)
#GLOBAL_QTD_TESTES = 30 (definido na leitura do arquivo)


GLOBAL_SAM_MUTACOES_CROSS = 1





########### PARÂMETROS ES
ee_mu_pop = 10
ee_lambda_pop = 40

INDICE_MU_PAIS = [[]]
INDICE_LAMBDA_FILHOS = []
FITNESS_GLOBAL = []
MU_PAIS = []
LAMBDA_FILHOS = []

## Parâmetros Globais
FT = [100, 110, 800, 130, 900, 200] # Tabela de Funções #colocar 200 para MUX
#FT = [100, 110, 800, 150, 160, 130, 900, 980, 990]
Ln = nc * nr # Número máximo de Nós
ug = (int((Ln * ur) / 100)) # Transforma porcentagem em quantidade de genes e soma um (maior inteiro seguinte ao obtido)
if ((Ln * ur) % 100) != 0:
    ug = ug + 1


## Arquivos

arquivo = open('matriz_transicao.txt','w')
arquivo.close()

arquivo2 = open('semente_populacao_inicial.txt', 'w')
arquivo2.close()

## Arrays
G = [] # Array que armazena o melhor indivíduo da geração anterior
aux_AI = [] # Array auxiliar de nós ativos/inativos
GENS_EVOL = [] # Array que armazena todos os genótipos de todos os indivíduos de cada geração (Pai + ee_lambda descendentes)
OUTPUTS_CONTROLE = []

## Arrays auxiliares

fila = []
myarray = []
MEUARRAY = []
TABELA_V = [] # Array que armazena a tabela verdade dos circuitos
FITNESS_EE = [] # Array que armazena o valor das fitness dos circuitos
PORTAS_EE = [] # Array que armazena a quantidade de portas de cada circuito (acumulativo)
COMUNS_EE = []
PORTAS_CKT = [] # Array que armazena a quantidade de portas total de cada e todos circuitos
WIRES_CKT = [] # Array que aramazena a quantidade de wires total de cada e todos circuitos
MUX_CKT = []
ATIVO_MOM = [] # Array que armazena os nós ativos momentâneos
MATRIZ_REGIAO_INFACTIVEL = [[[0],[0],[0],[0],[0],[0],[0],[0],[0]],[[0],[0],[0],[0],[0],[0],[0],[0],[0]],[[0],[0],[0],[0],[0],[0],[0],[0],[0]],[[0],[0],[0],[0],[0],[0],[0],[0],[0]],[[0],[0],[0],[0],[0],[0],[0],[0],[0]],[[0],[0],[0],[0],[0],[0],[0],[0],[0]],[[0],[0],[0],[0],[0],[0],[0],[0],[0]],[[0],[0],[0],[0],[0],[0],[0],[0],[0]],[[0],[0],[0],[0],[0],[0],[0],[0],[0]]]
MATRIZ_REGIAO_FACTIVEL = [[[0],[0],[0],[0],[0],[0],[0],[0],[0]],[[0],[0],[0],[0],[0],[0],[0],[0],[0]],[[0],[0],[0],[0],[0],[0],[0],[0],[0]],[[0],[0],[0],[0],[0],[0],[0],[0],[0]],[[0],[0],[0],[0],[0],[0],[0],[0],[0]],[[0],[0],[0],[0],[0],[0],[0],[0],[0]],[[0],[0],[0],[0],[0],[0],[0],[0],[0]],[[0],[0],[0],[0],[0],[0],[0],[0],[0]],[[0],[0],[0],[0],[0],[0],[0],[0],[0]]]
GATE_INFAC = [
    [[0],[0],[0],[0],[0]],
    [[0],[0],[0],[0],[0]],
    [[0],[0],[0],[0],[0]],
    [[0],[0],[0],[0],[0]],
    [[0],[0],[0],[0],[0]]
    ]

GATE_INFAC_BEN = [
    [[0],[0],[0],[0],[0]],
    [[0],[0],[0],[0],[0]],
    [[0],[0],[0],[0],[0]],
    [[0],[0],[0],[0],[0]],
    [[0],[0],[0],[0],[0]]
    ]

IND_MUT_SAM = [
    [[0],[0]],
    [[0],[0]]
    ]

IND_MUT_GAM = [
    [[0],[0]],
    [[0],[0]]
    ]


GATE_TROCA = [
    [[0],[0],[0],[0],[0]],
    [[0],[0],[0],[0],[0]],
    [[0],[0],[0],[0],[0]],
    [[0],[0],[0],[0],[0]],
    [[0],[0],[0],[0],[0]]
    ]

GATE_TROCA_NORM = [
    [[0],[0],[0],[0],[0]],
    [[0],[0],[0],[0],[0]],
    [[0],[0],[0],[0],[0]],
    [[0],[0],[0],[0],[0]],
    [[0],[0],[0],[0],[0]]
    ]

AND = []
OR = []
XOR = []
NOT = []
XOR = []
WIRE = []


## Arrays de mutação
### ANTIGAS ###
#FACTIVEL
#MUT_XOR_5_FAC = [900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 800, 800, 800, 800, 800, 800, 800]
#MUT_OR_5_FAC = [900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 800, 800]
#MUT_AND_5_FAC = [900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 800, 800]
MUT_WIRE_5_FAC = [100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800]
MUT_AND_5_FAC = [900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 110, 130, 800, 800, 800]
MUT_OR_5_FAC = [900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 100, 100, 130, 130, 800, 800, 800]
MUT_XOR_5_FAC = [900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 100, 100, 100, 110, 110, 110, 800, 800, 800, 800, 800, 800, 800, 800, 800]
MUT_NOT_5_FAC = [900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130]


#INFACTIVEL
#MUT_NOT_5_INFAC = [100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130]
#MUT_XOR_5_INFAC = [100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800]
#MUT_OR_5_INFAC = [900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 100, 100, 100, 100, 100, 100, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 800, 800, 800, 800, 800, 800]
#MUT_AND_5_INFAC = [900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800]
#MUT_WIRE_5_INFAC = [100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130]
MUT_WIRE_5_INFAC = [100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 800, 800, 800]
MUT_AND_5_INFAC = [900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800]
MUT_OR_5_INFAC = [900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 100, 100, 100, 100, 100, 100, 100, 100, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 800, 800, 800, 800, 800, 800, 800, 800]
MUT_XOR_5_INFAC = [900, 900, 900, 900, 900, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800]
MUT_NOT_5_INFAC = [900, 900, 900, 900, 900, 900, 900, 900, 900, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130]



### PROBLEMAS TESTE MATRIZ_TRANSICAO (Biased SAM - A novel...)

#Problema 1:
#INPUTS = [[0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1],[0,0,0,0,1,1,1,1,0,0,0,0,1,1,1,1],[0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1],[0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1]]
#OUTPUTS = [[1,1,0,1,0,0,1,1,1,0,1,0,0,1,0,0]]

#Problema 2:
#INPUTS = [[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1],[0,0,0,0,1,1,1,1,0,0,0,0,1,1,1,1,0,0,0,0,1,1,1,1,0,0,0,0,1,1,1,1],[0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1],[0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1]]
#OUTPUTS = [[0,0,1,1,0,0,1,1,0,0,1,1,0,1,0,1,0,0,1,1,0,1,0,1,0,1,0,1,0,1,0,1]]

#Problema 3:
#INPUTS = [[0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1],[0,0,0,0,1,1,1,1,0,0,0,0,1,1,1,1],[0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1],[0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1]]
#OUTPUTS = [[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],[0,1,1,1,0,0,1,1,0,0,0,1,0,0,0,0],[0,0,0,0,1,0,0,0,1,1,0,0,1,1,1,0]]

#Problema 4:
#INPUTS = [[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1],[0,0,0,0,1,1,1,1,0,0,0,0,1,1,1,1,0,0,0,0,1,1,1,1,0,0,0,0,1,1,1,1],[0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1],[0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1]]
#OUTPUTS = [[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1],[1,0,1,0,1,0,1,1,1,0,1,0,1,0,1,1,1,0,1,0,1,0,1,1,1,0,1,0,1,0,1,1],[0,0,0,0,1,1,0,0,0,0,0,0,1,1,0,0,0,0,0,0,1,1,0,0,0,0,0,0,1,1,0,0]]

### EXPERIMENTOS COMPUTACIONAIS

#Problema 1: (Exemplo 2 - Evolutionary multiobjective COELLO // Tese Francisco, tabela 3 pag 100)
#INPUTS = [[0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1],[0,0,0,0,1,1,1,1,0,0,0,0,1,1,1,1],[0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1],[0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1]]
#OUTPUTS = [[1,1,0,1,0,0,1,1,1,0,1,0,0,1,0,0]]

#Problema 2: (Exemplo 4 - Evolutionary multiobjective COELLO)
#INPUTS = [[0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1],[0,0,0,0,1,1,1,1,0,0,0,0,1,1,1,1],[0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1],[0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1]]
#OUTPUTS = [[0,0,0,0,0,0,0,1,0,0,1,1,0,1,1,1],[0,0,1,1,0,1,1,0,1,1,0,0,1,0,0,1],
#[0,1,0,1,1,0,1,0,0,1,0,1,1,0,1,0]]

#Problema 3: (MULTIPLICADOR 2X2 BITS)
#INPUTS = [[0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1],[0,0,0,0,1,1,1,1,0,0,0,0,1,1,1,1],[0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1],[0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1]]
#OUTPUTS = [[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[0,0,0,0,0,0,0,0,0,0,1,1,0,0,1,0],[0,0,0,0,0,0,1,1,0,1,0,1,0,1,1,0],[0,0,0,0,0,1,0,1,0,0,0,0,0,1,0,1]]

#Problema 4: Exemplo 4 - A comparative study (case study 6) CPG-USAR
#INPUTS = [[0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1],[0,0,0,0,1,1,1,1,0,0,0,0,1,1,1,1],[0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1],[0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1]]
#OUTPUTS = [[1,1,1,0,1,1,0,0,1,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,1]]

#Problema FICTÍCIO 4X4
#INPUTS = [[0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1],[0,0,0,0,1,1,1,1,0,0,0,0,1,1,1,1],[0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1],[0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1]]
#OUTPUTS = [[0,0,0,1,0,0,0,0,1,1,0,0,0,0,0,1],[0,1,1,0,0,0,0,0,0,0,1,1,0,0,1,0],[1,0,0,0,0,0,0,1,0,1,0,1,0,1,1,0],[1,1,0,0,0,0,1,1,0,0,1,0,0,1,0,1]]


##CM85A
#INPUTS = [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],[0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1],[0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1],[0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1],[0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1]]

#OUTPUTS = [[0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0]]


## Multiplicador 3x3 bits
#INPUTS = [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1], [0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1], [0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1], [0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1]]

#OUTPUTS = [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1]]


### COMPARADOR 4-1 BIT

#INPUTS = [[0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1],
#[0,0,0,0,1,1,1,1,0,0,0,0,1,1,1,1],
#[0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1],
#[0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1]]



#OUTPUTS = [[0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0],
#[0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0],
#[1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1],
#[0,1,0,1,0,0,0,0,0,0,0,1,0,0,0,0],
#[0,0,0,0,1,0,1,0,0,0,0,0,1,0,1,0],
#[1,0,1,0,0,1,0,1,1,1,1,0,0,1,0,1],
#[0,1,0,1,0,1,0,1,0,0,0,0,0,0,0,0],
#[0,0,0,0,0,0,0,0,1,0,1,0,1,0,1,0],
#[1,0,1,0,1,0,1,0,0,1,0,1,0,1,0,1],
#[0,0,1,1,0,0,0,0,0,0,1,1,0,0,0,0],
#[0,0,0,0,1,1,0,0,0,0,0,0,1,1,0,0],
#[1,1,0,0,0,0,1,1,1,1,0,0,0,0,1,1],
#[0,0,1,1,0,0,1,1,0,0,0,0,0,0,0,0],
#[0,0,0,0,0,0,0,0,1,1,0,0,1,1,0,0],
#[1,1,0,0,1,1,0,0,0,0,1,1,0,0,1,1],
#[0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0],
#[0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0],
#[1,1,1,1,0,0,0,0,0,0,0,0,1,1,1,1]]


## Somador 3 bits
#INPUTS = [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1], [0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1], [0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1], [0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1]]

#OUTPUTS = [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1], [0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1], [0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1], [0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0]]



def limpa_array():
    GENS_EVOL.clear()
    FITNESS_EE.clear()
    COMUNS_EE.clear()
    PORTAS_EE.clear()
    MEUARRAY.clear()
    TABELA_V.clear()
    G.clear()
    PORTAS_CKT.clear()
    WIRES_CKT.clear()

def limpa_array_controle():
    OUTPUTS_CONTROLE.clear()
    
def formato_ee(): #Cria o formato da matriz GENS_EVOL
    for i in range(ee_lambda + 1):
        GENS_EVOL.append([])

def formato_ee_pop(): #Cria o formato da matriz GENS_EVOL
    for i in range(ee_lambda_pop + ee_mu_pop):
        GENS_EVOL.append([])

def formato_tabela_verdade(): #Cria o formato da matriz tabela verdade
    for i in range(Ln + ni + no):
        TABELA_V.append([])

def formato_array_fitness(): #Cria o formato da array de valores de fitness (ES1+4)
    for j in range(ee_lambda + 1):
        FITNESS_EE.append([])
        COMUNS_EE.append([])
        PORTAS_EE.append([])
        PORTAS_CKT.append([])
        WIRES_CKT.append([])
        MUX_CKT.append([])
        for k in range(no):
            FITNESS_EE[j].append([])
            COMUNS_EE[j].append([])
            PORTAS_EE[j].append([])


def formato_outputs_controle():
    for i in range(no):
        OUTPUTS_CONTROLE.append([])

def formato_array_fitness_pop(): #Cria o formato da array de valores de fitness (ES mu+lambda)
    for j in range(ee_lambda_pop + ee_mu_pop):
        FITNESS_EE.append([])
        PORTAS_EE.append([])
        PORTAS_CKT.append([])
        WIRES_CKT.append([])
        MUX_CKT.append([])
        for k in range(no):
            FITNESS_EE[j].append([])
            PORTAS_EE[j].append([])

                        
def gera_formato_nos(): #Cria o MEUARRAY (que armazena os genes ativos "X" e os inativos "-" de cada indivíduo) para ES(1+4)
    for k in range(ee_lambda + 1):
        MEUARRAY.append([])
        for j in range(no):
            MEUARRAY[k].append([])

def gera_formato_nos_pop(): #Cria o MEUARRAY (que armazena os genes ativos "X" e os inativos "-" de cada indivíduo) para ES(mu+lambda)
    for k in range(ee_lambda_pop + ee_mu_pop):
        MEUARRAY.append([])
        for j in range(no):
            MEUARRAY[k].append([])

def gera_formato_genotipo(): #Define o formato da matriz genótipos G
    for i in range(Ln + ni):
        if i <= (ni -1):
            G.append([]) #Aloca espaços para as entradas
        else:
            G.append([]) #Aloca espaços para os nós
            for k in range(3):
                G[i].append([])
    for i in range(no):
        G.append([]) #Aloca espaço para as saidas


def gera_formato_genotipo_mux(): #Define o formato da matriz genótipos G
    for i in range(Ln + ni):
        if i <= (ni -1):
            G.append([]) #Aloca espaços para as entradas
        else:
            G.append([]) #Aloca espaços para os nós
            for k in range(4):
                G[i].append([])
    for i in range(no):
        G.append([]) #Aloca espaço para as saidas        

def populacao_inicial():
    for j in range(Ln):
        i = j + ni # Pula as posições das entradas
        n_porta = r.randint(0,len(FT)-1) # Sorteia uma porta dentre as disponíveis em FT
        porta = FT[n_porta]
        G[i][max_entradas] = porta # A porta ocupa o último locus do gene
        colunaatual = int(j/nr) + 1 # Determina a coluna atual (sem contar entrada)
        if colunaatual == 1: #Neste caso as portas lógicas só recebem inputs
            for k in range(max_entradas):
                entrada = r.randint(0, (ni-1))
                G[i][k] = entrada
        if colunaatual - lb < 1 and colunaatual != 1: #Neste caso as portas lógicas recebem inputs e nós        
            valorpossivel = (nr * (colunaatual-2)) + (nr-1) + ni #Determina todos os valores de entradas possiveis
            print(valorpossivel)
            for k in range(max_entradas):
                sorteado = r.randint(0, valorpossivel)
                G[i][k] = sorteado
        if colunaatual - lb >= 1: #Neste caso as portas logicas recebem somente nós
            primeiro_elemento = nr * (colunaatual-lb-1) + ni # O fator + ni serve para deslocar os elementos para frente, contando a quantidade de inputs.
            ultimo_elemento = (nr * (colunaatual-2)) + (nr-1) + ni
            for k in range(max_entradas):
                #entrada_ou_porta = randint(0, 1) #Determina se a entrada da porta lógica atual será uma entrada do circuito ou a saída de alguma porta lógica já existente (0: entrada; 1: porta lógica)
                elementos_portas = ultimo_elemento - primeiro_elemento + 1 #Determina quantas portas possíveis existem
                qtd_elementos = elementos_portas + ni - 1 #Determina a quantidade de valores distintos que a porta pode assumir como entrada. O -1 tem como função apenas possibilitar o uso de randint(0, qtd_elementos)
                entrada_ou_porta = r.randint(0, qtd_elementos) #Dá a mesma chance para todos os possiveis inputs
                if entrada_ou_porta >= ni:
                    G[i][k] = r.randint(primeiro_elemento, ultimo_elemento)
                else:
                    G[i][k] = r.randint(0, ni-1)



def populacao_inicial_mux():
    for j in range(Ln):
        i = j + ni # Pula as posições das entradas
        n_porta = r.randint(0,len(FT)-1) # Sorteia uma porta dentre as disponíveis em FT
        porta = FT[n_porta]
        G[i][2] = porta # A porta ocupa o último locus do gene
        colunaatual = int(j/nr) + 1 # Determina a coluna atual (sem contar entrada)
        if colunaatual == 1: #Neste caso as portas lógicas só recebem inputs
            for k in range(4):
                if k != 2:
                    entrada = r.randint(0, (ni-1))
                    G[i][k] = entrada
        if colunaatual - lb < 1 and colunaatual != 1: #Neste caso as portas lógicas recebem inputs e nós        
            valorpossivel = (nr * (colunaatual-2)) + (nr-1) + ni #Determina todos os valores de entradas possiveis
            print(valorpossivel)
            for k in range(4):
                if k != 2:
                    sorteado = r.randint(0, valorpossivel)
                    G[i][k] = sorteado
        if colunaatual - lb >= 1: #Neste caso as portas logicas recebem somente nós
            primeiro_elemento = nr * (colunaatual-lb-1) + ni # O fator + ni serve para deslocar os elementos para frente, contando a quantidade de inputs.
            ultimo_elemento = (nr * (colunaatual-2)) + (nr-1) + ni
            for k in range(4):
                if k != 2:
                    #entrada_ou_porta = randint(0, 1) #Determina se a entrada da porta lógica atual será uma entrada do circuito ou a saída de alguma porta lógica já existente (0: entrada; 1: porta lógica)
                    elementos_portas = ultimo_elemento - primeiro_elemento + 1 #Determina quantas portas possíveis existem
                    qtd_elementos = elementos_portas + ni - 1 #Determina a quantidade de valores distintos que a porta pode assumir como entrada. O -1 tem como função apenas possibilitar o uso de randint(0, qtd_elementos)
                    entrada_ou_porta = r.randint(0, qtd_elementos) #Dá a mesma chance para todos os possiveis inputs
                    if entrada_ou_porta >= ni:
                        G[i][k] = r.randint(primeiro_elemento, ultimo_elemento)
                    else:
                        G[i][k] = r.randint(0, ni-1)                    



def populacao_inicial_mux2():
    for j in range(Ln):
        i = j + ni # Pula as posições das entradas
        n_porta = r.randint(0,len(FT)-1) # Sorteia uma porta dentre as disponíveis em FT
        porta = FT[n_porta]
        G[i][2] = porta # A porta ocupa o último locus do gene
        colunaatual = int(j/nr) + 1 # Determina a coluna atual (sem contar entrada)
        if colunaatual == 1: #Neste caso as portas lógicas só recebem inputs
            for k in range(4):
                if k != 2:
                    entrada = r.randint(0, (ni-1))
                    G[i][k] = entrada
        if colunaatual - lb < 1 and colunaatual != 1: #Neste caso as portas lógicas recebem inputs e nós        
            valorpossivel = (nr * (colunaatual-2)) + (nr-1) + ni #Determina todos os valores de entradas possiveis
            #print(valorpossivel)
            for k in range(4):
                if k != 2:
                    sorteado = r.randint(0, valorpossivel)
                    G[i][k] = sorteado
        if colunaatual - lb >= 1: #Neste caso as portas logicas recebem somente nós
            primeiro_elemento = nr * (colunaatual-lb-1) + ni # O fator + ni serve para deslocar os elementos para frente, contando a quantidade de inputs.
            ultimo_elemento = (nr * (colunaatual-2)) + (nr-1) + ni
            for k in range(4):
                if k != 2:
                    #entrada_ou_porta = randint(0, 1) #Determina se a entrada da porta lógica atual será uma entrada do circuito ou a saída de alguma porta lógica já existente (0: entrada; 1: porta lógica)
                    elementos_portas = ultimo_elemento - primeiro_elemento + 1 #Determina quantas portas possíveis existem
                    qtd_elementos = elementos_portas + ni - 1 #Determina a quantidade de valores distintos que a porta pode assumir como entrada. O -1 tem como função apenas possibilitar o uso de randint(0, qtd_elementos)
                    entrada_ou_porta = r.randint(0, qtd_elementos) #Dá a mesma chance para todos os possiveis inputs
                    if entrada_ou_porta >= ni:
                        G[i][k] = r.randint(primeiro_elemento, ultimo_elemento)
                    else:
                        G[i][k] = r.randint(0, ni-1)             


def define_saida():
    ultimo_elemento = ni + Ln - 1 #Último elemento possivel que a saída pode assumir
    primeiro_elemento = ultimo_elemento - (lb * nr) + 1 #Primeiro valor possivel que a saída pode assumir
    elementos_portas = ultimo_elemento - primeiro_elemento + 1 #Quantidade de valores existentes entre o primeiro e último possiveis valores
    qtd_elementos = elementos_portas + ni - 1 #Determina a quantidade de valores distintos que a porta pode assumir como entrada. O -1 tem como função apenas possibilitar o uso de randint(0, qtd_elementos)
    for i in range(no):
        entrada_ou_porta = r.randint(0, qtd_elementos) #Dá a mesma chance para todos os possiveis inputs
        if entrada_ou_porta >= ni: #G[Ln+ni+i] representa cada saida, sequencialmente
            G[Ln+ni+i] = r.randint(primeiro_elemento, ultimo_elemento)
        else:
            G[Ln+ni+i] = r.randint(0, ni-1)

def nos_ativos():
    fila = [] #Array que funcionará como uma fila
    myarray = [] #Array que armazenará os genes dos nós da fila
    vetor = []

    for k in range(Ln+ni):
        vetor.append("-")
    for w in range(ee_lambda + 1): #Percorre o pai e seus lambda filhos
        

        for i in range(no): #Realiza o procedimento para o número de saídas
            saida = int(Ln+ni+i) #Determina a saída a ser processada

            fila.append(GENS_EVOL[w][saida])
            noatual = GENS_EVOL[w][GENS_EVOL[w][saida]] #Obtém as informações do gene responsável pela saída
            if type(noatual) is not int: #len(noatual) == 3: #Analisa se a saída é o resultado de um nó ou é uma entrada do programa. (3 significa: entrada, entrada e porta)
                if (noatual[2] != 800 and noatual[2] != 900 and noatual[2] != 800 and noatual[2] != 980 and noatual[2] != 990): #Verifica se a porta logica é unária ou binária. Caso seja binária, entra no else.
                    fila.append(noatual[0]) #Adiciona primeira entrada do nó saída
                    fila.append(noatual[1]) #Adiciona segunda entrada do nó saída
                    myarray.append(GENS_EVOL[w][noatual[0]]) #Adiciona o gene responsável pela primeira entrada
                    myarray.append(GENS_EVOL[w][noatual[1]]) #Adiciona o gene responsável pela segunda entrada
                else:
                    fila.append(noatual[0])
                    myarray.append(GENS_EVOL[w][noatual[0]])
            else:
                fila.append(noatual) #Se tamanho é diferente de 3, então é uma entrada. Logo a fila recebe o valor da posição da entrada.

            while len(myarray) != 0: #Procedimento para esvaziar a fila
                noatual = myarray[0]
                if type(noatual) is int: #(len(noatual) != 3: #Considerando tamanho 3 do gene, isto é, duas entradas mais a função
                    fila.append("entrada")
                    myarray.pop(0)

                else:

                    if (noatual[2] != 800 and noatual[2] != 900 and noatual[2] != 800 and noatual[2] != 980 and noatual[2] != 990): #Verifica se a porta logica é unária ou binária. Caso seja binária, entra no else.
                        fila.append(noatual[0])

                        fila.append(noatual[1])

                        myarray.append(GENS_EVOL[w][noatual[0]])
                        myarray.append(GENS_EVOL[w][noatual[1]])

                        myarray.pop(0)

                    else:
                        fila.append(noatual[0])
                        myarray.append(GENS_EVOL[w][noatual[0]])
                        myarray.pop(0)

            for j in range(len(fila)): # Coloca X nas posições ativas do genótipo
                if type(fila[j]) is int:
                    if vetor[fila[j]] == "-":
                        vetor[fila[j]] = "X"

            MEUARRAY[w][i] = copy.deepcopy(vetor)

            vetor.clear()
            for k in range(Ln+ni):
                vetor.append("-")
                
            fila = [] #Limpa o vetor fila
            myarray = [] #Limpa o vetor myarray





def nos_ativos_mux():
    fila = [] #Array que funcionará como uma fila
    myarray = [] #Array que armazenará os genes dos nós da fila
    vetor = []

    for k in range(Ln+ni):
        vetor.append("-")
    for w in range(ee_lambda + 1): #Percorre o pai e seus lambda filhos
        

        for i in range(no): #Realiza o procedimento para o número de saídas
            saida = int(Ln+ni+i) #Determina a saída a ser processada

            fila.append(GENS_EVOL[w][saida])
            noatual = GENS_EVOL[w][GENS_EVOL[w][saida]] #Obtém as informações do gene responsável pela saída
            if type(noatual) is not int: #len(noatual) == 3: #Analisa se a saída é o resultado de um nó ou é uma entrada do programa. (3 significa: entrada, entrada e porta)
                if (noatual[2] != 800 and noatual[2] != 900 and noatual[2] != 800 and noatual[2] != 980 and noatual[2] != 990): #Verifica se a porta logica é unária ou binária. Caso seja binária, entra no else.
                    if noatual[2] == 200:
                        fila.append(noatual[0]) #Adiciona primeira entrada do nó saída
                        fila.append(noatual[1]) #Adiciona segunda entrada do nó saída
                        fila.append(noatual[3])
                        myarray.append(GENS_EVOL[w][noatual[0]]) #Adiciona o gene responsável pela primeira entrada
                        myarray.append(GENS_EVOL[w][noatual[1]]) #Adiciona o gene responsável pela segunda entrada
                        myarray.append(GENS_EVOL[w][noatual[3]])
                    else:
                        fila.append(noatual[0])
                        fila.append(noatual[1])
                        myarray.append(GENS_EVOL[w][noatual[0]])
                        myarray.append(GENS_EVOL[w][noatual[1]])
                else:
                    fila.append(noatual[0])
                    myarray.append(GENS_EVOL[w][noatual[0]])
            else:
                fila.append(noatual) #Se tamanho é diferente de 3, então é uma entrada. Logo a fila recebe o valor da posição da entrada.

            while len(myarray) != 0: #Procedimento para esvaziar a fila
                noatual = myarray[0]
                if type(noatual) is int: #(len(noatual) != 3: #Considerando tamanho 3 do gene, isto é, duas entradas mais a função
                    fila.append("entrada")
                    myarray.pop(0)

                else:

                    if (noatual[2] != 800 and noatual[2] != 900 and noatual[2] != 800 and noatual[2] != 980 and noatual[2] != 990): #Verifica se a porta logica é unária ou binária. Caso seja binária, entra no else.
                        if noatual[2] == 200:
                            fila.append(noatual[0])
                            fila.append(noatual[1])
                            fila.append(noatual[3])
                            myarray.append(GENS_EVOL[w][noatual[0]])
                            myarray.append(GENS_EVOL[w][noatual[1]])
                            myarray.append(GENS_EVOL[w][noatual[3]])
                            myarray.pop(0)
                        else:
                            fila.append(noatual[0])
                            fila.append(noatual[1])
                            myarray.append(GENS_EVOL[w][noatual[0]])
                            myarray.append(GENS_EVOL[w][noatual[1]])
                            myarray.pop(0)

                    else:
                        fila.append(noatual[0])
                        myarray.append(GENS_EVOL[w][noatual[0]])
                        myarray.pop(0)

            for j in range(len(fila)): # Coloca X nas posições ativas do genótipo
                if type(fila[j]) is int:
                    if vetor[fila[j]] == "-":
                        vetor[fila[j]] = "X"

            MEUARRAY[w][i] = copy.deepcopy(vetor)

            vetor.clear()
            for k in range(Ln+ni):
                vetor.append("-")
                
            fila = [] #Limpa o vetor fila
            myarray = [] #Limpa o vetor myarray




def nos_ativos_pop():
    fila = [] #Array que funcionará como uma fila
    myarray = [] #Array que armazenará os genes dos nós da fila
    vetor = []

    for k in range(Ln+ni):
        vetor.append("-")
    for w in range(ee_lambda_pop + ee_mu_pop): #Percorre o pai e seus lambda filhos
        

        for i in range(no): #Realiza o procedimento para o número de saídas
            saida = int(Ln+ni+i) #Determina a saída a ser processada

            fila.append(GENS_EVOL[w][saida])
            noatual = GENS_EVOL[w][GENS_EVOL[w][saida]] #Obtém as informações do gene responsável pela saída
            if type(noatual) is not int: #len(noatual) == 3: #Analisa se a saída é o resultado de um nó ou é uma entrada do programa. (3 significa: entrada, entrada e porta)
                if (noatual[2] != 800 and noatual[2] != 900 and noatual[2] != 800 and noatual[2] != 980 and noatual[2] != 990): #Verifica se a porta logica é unária ou binária. Caso seja binária, entra no else.
                    fila.append(noatual[0]) #Adiciona primeira entrada do nó saída
                    fila.append(noatual[1]) #Adiciona segunda entrada do nó saída
                    myarray.append(GENS_EVOL[w][noatual[0]]) #Adiciona o gene responsável pela primeira entrada
                    myarray.append(GENS_EVOL[w][noatual[1]]) #Adiciona o gene responsável pela segunda entrada
                else:
                    fila.append(noatual[0])
                    myarray.append(GENS_EVOL[w][noatual[0]])
            else:
                fila.append(noatual) #Se tamanho é diferente de 3, então é uma entrada. Logo a fila recebe o valor da posição da entrada.

            while len(myarray) != 0: #Procedimento para esvaziar a fila
                noatual = myarray[0]
                if type(noatual) is int: #(len(noatual) != 3: #Considerando tamanho 3 do gene, isto é, duas entradas mais a função
                    fila.append("entrada")
                    myarray.pop(0)

                else:

                    if (noatual[2] != 800 and noatual[2] != 900 and noatual[2] != 800 and noatual[2] != 980 and noatual[2] != 990): #Verifica se a porta logica é unária ou binária. Caso seja binária, entra no else.
                        fila.append(noatual[0])

                        fila.append(noatual[1])

                        myarray.append(GENS_EVOL[w][noatual[0]])
                        myarray.append(GENS_EVOL[w][noatual[1]])

                        myarray.pop(0)

                    else:
                        fila.append(noatual[0])
                        myarray.append(GENS_EVOL[w][noatual[0]])
                        myarray.pop(0)

            for j in range(len(fila)): # Coloca X nas posições ativas do genótipo
                if type(fila[j]) is int:
                    if vetor[fila[j]] == "-":
                        vetor[fila[j]] = "X"

            MEUARRAY[w][i] = copy.deepcopy(vetor)

            vetor.clear()
            for k in range(Ln+ni):
                vetor.append("-")
                
            fila = [] #Limpa o vetor fila
            myarray = [] #Limpa o vetor myarray

def preenche_matriz_portas(porta_antes, porta_depois):
    if porta_antes == 100:
        if porta_depois == 100:
            GATE_INFAC[0][0][0] += 1
        if porta_depois == 110:
            GATE_INFAC[0][1][0] += 1
        if porta_depois == 130:
            GATE_INFAC[0][2][0] += 1
        if porta_depois == 800:
            GATE_INFAC[0][3][0] += 1
        if porta_depois == 900:
            GATE_INFAC[0][4][0] += 1
            
    if porta_antes == 110:
        if porta_depois == 100:
            GATE_INFAC[1][0][0] += 1
        if porta_depois == 110:
            GATE_INFAC[1][1][0] += 1
        if porta_depois == 130:
            GATE_INFAC[1][2][0] += 1
        if porta_depois == 800:
            GATE_INFAC[1][3][0] += 1
        if porta_depois == 900:
            GATE_INFAC[1][4][0] += 1
            
    if porta_antes == 130:
        if porta_depois == 100:
            GATE_INFAC[2][0][0] += 1
        if porta_depois == 110:
            GATE_INFAC[2][1][0] += 1
        if porta_depois == 130:
            GATE_INFAC[2][2][0] += 1
        if porta_depois == 800:
            GATE_INFAC[2][3][0] += 1
        if porta_depois == 900:
            GATE_INFAC[2][4][0] += 1
            
    if porta_antes == 800:
        if porta_depois == 100:
            GATE_INFAC[3][0][0] += 1
        if porta_depois == 110:
            GATE_INFAC[3][1][0] += 1
        if porta_depois == 130:
            GATE_INFAC[3][2][0] += 1
        if porta_depois == 800:
            GATE_INFAC[3][3][0] += 1
        if porta_depois == 900:
            GATE_INFAC[3][4][0] += 1
            
    if porta_antes == 900:
        if porta_depois == 100:
            GATE_INFAC[4][0][0] += 1
        if porta_depois == 110:
            GATE_INFAC[4][1][0] += 1
        if porta_depois == 130:
            GATE_INFAC[4][2][0] += 1
        if porta_depois == 800:
            GATE_INFAC[4][3][0] += 1
        if porta_depois == 900:
            GATE_INFAC[4][4][0] += 1        


def preenche_matriz_benefico(porta_antes, porta_depois):
    if porta_antes == 100:
        if porta_depois == 100:
            GATE_INFAC_BEN[0][0][0] += 1
        if porta_depois == 110:
            GATE_INFAC_BEN[0][1][0] += 1
        if porta_depois == 130:
            GATE_INFAC_BEN[0][2][0] += 1
        if porta_depois == 800:
            GATE_INFAC_BEN[0][3][0] += 1
        if porta_depois == 900:
            GATE_INFAC_BEN[0][4][0] += 1
            
    if porta_antes == 110:
        if porta_depois == 100:
            GATE_INFAC_BEN[1][0][0] += 1
        if porta_depois == 110:
            GATE_INFAC_BEN[1][1][0] += 1
        if porta_depois == 130:
            GATE_INFAC_BEN[1][2][0] += 1
        if porta_depois == 800:
            GATE_INFAC_BEN[1][3][0] += 1
        if porta_depois == 900:
            GATE_INFAC_BEN[1][4][0] += 1
            
    if porta_antes == 130:
        if porta_depois == 100:
            GATE_INFAC_BEN[2][0][0] += 1
        if porta_depois == 110:
            GATE_INFAC_BEN[2][1][0] += 1
        if porta_depois == 130:
            GATE_INFAC_BEN[2][2][0] += 1
        if porta_depois == 800:
            GATE_INFAC_BEN[2][3][0] += 1
        if porta_depois == 900:
            GATE_INFAC_BEN[2][4][0] += 1
            
    if porta_antes == 800:
        if porta_depois == 100:
            GATE_INFAC_BEN[3][0][0] += 1
        if porta_depois == 110:
            GATE_INFAC_BEN[3][1][0] += 1
        if porta_depois == 130:
            GATE_INFAC_BEN[3][2][0] += 1
        if porta_depois == 800:
            GATE_INFAC_BEN[3][3][0] += 1
        if porta_depois == 900:
            GATE_INFAC_BEN[3][4][0] += 1
            
    if porta_antes == 900:
        if porta_depois == 100:
            GATE_INFAC_BEN[4][0][0] += 1
        if porta_depois == 110:
            GATE_INFAC_BEN[4][1][0] += 1
        if porta_depois == 130:
            GATE_INFAC_BEN[4][2][0] += 1
        if porta_depois == 800:
            GATE_INFAC_BEN[4][3][0] += 1
        if porta_depois == 900:
            GATE_INFAC_BEN[4][4][0] += 1  



def atualiza_matriz_mutacoes():
    for i in range(len(GATE_INFAC)):
        for j in range(len(GATE_INFAC[i])):
            if GATE_INFAC[i][j][0] == 0:
                GATE_TROCA[i][j][0] = copy.deepcopy(0)
            else:
                GATE_TROCA[i][j][0] = copy.deepcopy(GATE_INFAC_BEN[i][j][0] / GATE_INFAC[i][j][0])
        
    for i in range(len(GATE_TROCA)):
        variavel = 0
        for j in range(len(GATE_TROCA[i])):
            variavel += GATE_TROCA[i][j][0]
        for j in range(len(GATE_TROCA[i])):
            if variavel == 0:
                GATE_TROCA_NORM[i][j][0] = copy.deepcopy(0)
            else:
                GATE_TROCA_NORM[i][j][0] = copy.deepcopy(round(GATE_TROCA[i][j][0]/variavel,2))

                
    AND_LOCAL = []
    OR_LOCAL = []
    XOR_LOCAL = []
    NOT_LOCAL = []
    WIRE_LOCAL = []
    for i in range(len(GATE_TROCA_NORM)):
        for j in range(len(GATE_TROCA_NORM[i])):
            if i == 0:
                for k in range(int(GATE_TROCA_NORM[i][j][0] * 100)):
                    if j == 1:
                        AND_LOCAL.append(110)
                    if j == 2:
                        AND_LOCAL.append(130)
                    if j == 3:
                        AND_LOCAL.append(800)
                    if j == 4:
                        AND_LOCAL.append(900)
            if i == 1:
                for k in range(int(GATE_TROCA_NORM[i][j][0] * 100)):
                    if j == 0:
                        OR_LOCAL.append(100)
                    if j == 2:
                        OR_LOCAL.append(130)
                    if j == 3:
                        OR_LOCAL.append(800)
                    if j == 4:
                        OR_LOCAL.append(900)
            if i == 2:
                for k in range(int(GATE_TROCA_NORM[i][j][0] * 100)):
                    if j == 0:
                        XOR_LOCAL.append(100)
                    if j == 1:
                        XOR_LOCAL.append(110)
                    if j == 3:
                        XOR_LOCAL.append(800)
                    if j == 4:
                        XOR_LOCAL.append(900)
            if i == 3:
                for k in range(int(GATE_TROCA_NORM[i][j][0] * 100)):
                    if j == 0:
                        NOT_LOCAL.append(100)
                    if j == 1:
                        NOT_LOCAL.append(110)
                    if j == 2:
                        NOT_LOCAL.append(130)
                    if j == 4:
                        NOT_LOCAL.append(900)
            if i == 4:
                for k in range(int(GATE_TROCA_NORM[i][j][0] * 100)):
                    if j == 0:
                        WIRE_LOCAL.append(100)
                    if j == 1:
                        WIRE_LOCAL.append(110)
                    if j == 2:
                        WIRE_LOCAL.append(130)
                    if j == 3:
                        WIRE_LOCAL.append(800)

    AND = copy.deepcopy(AND_LOCAL)
    OR = copy.deepcopy(OR_LOCAL)
    XOR = copy.deepcopy(XOR_LOCAL)
    NOT = copy.deepcopy(NOT_LOCAL)
    WIRE = copy.deepcopy(WIRE_LOCAL)



def SAM_ativo(posicao):
    fila = [] #Array que funcionará como uma fila
    myarray = [] #Array que armazenará os genes dos nós da fila
    vetor = []
    for k in range(Ln+ni):
        vetor.append("-")

    for w in range(1): #Percorre o pai e seus lambda filhos
        for i in range(no): #Realiza o procedimento para o número de saídas
            saida = int(Ln+ni+i) #Determina a saída a ser processada
            fila.append(GENS_EVOL[posicao][saida])
            noatual = GENS_EVOL[posicao][GENS_EVOL[posicao][saida]] #Obtém as informações do gene responsável pela saída
            if type(noatual) is not int: #len(noatual) == 3: #Analisa se a saída é o resultado de um nó ou é uma entrada do programa. (3 significa: entrada, entrada e porta)
                fila.append(noatual[0]) #Adiciona primeira entrada do nó saída
                fila.append(noatual[1]) #Adiciona segunda entrada do nó saída
                myarray.append(GENS_EVOL[posicao][noatual[0]]) #Adiciona o gene responsável pela primeira entrada
                myarray.append(GENS_EVOL[posicao][noatual[1]]) #Adiciona o gene responsável pela segunda entrada
            else:
                fila.append(noatual) #Se tamanho é diferente de 3, então é uma entrada. Logo a fila recebe o valor da posição da entrada.
            while len(myarray) != 0: #Procedimento para esvaziar a fila
                noatual = myarray[0]
                if type(noatual) is int: #(len(noatual) != 3: #Considerando tamanho 3 do gene, isto é, duas entradas mais a função
                    fila.append("entrada")
                    myarray.pop(0)
                else:
                    fila.append(noatual[0])
                    fila.append(noatual[1])
                    myarray.append(GENS_EVOL[posicao][noatual[0]])
                    myarray.append(GENS_EVOL[posicao][noatual[1]])
                    myarray.pop(0)
                    
            for j in range(len(fila)): # Coloca X nas posições ativas do genótipo
                if type(fila[j]) is int:
                    if vetor[fila[j]] == "-":
                        vetor[fila[j]] = "X"

            MEUARRAY[posicao][i] = copy.deepcopy(vetor)
            vetor.clear()
            for k in range(Ln+ni):
                vetor.append("-")

            fila = [] #Limpa o vetor fila
            myarray = [] #Limpa o vetor myarray



def SAM_ativo_mux(posicao):
    fila = [] #Array que funcionará como uma fila
    myarray = [] #Array que armazenará os genes dos nós da fila
    vetor = []
    for k in range(Ln+ni):
        vetor.append("-")

    for w in range(1): #Percorre o pai e seus lambda filhos
        for i in range(no): #Realiza o procedimento para o número de saídas
            saida = int(Ln+ni+i) #Determina a saída a ser processada
            fila.append(GENS_EVOL[posicao][saida])
            noatual = GENS_EVOL[posicao][GENS_EVOL[posicao][saida]] #Obtém as informações do gene responsável pela saída
            if type(noatual) is not int: #len(noatual) == 3: #Analisa se a saída é o resultado de um nó ou é uma entrada do programa. (3 significa: entrada, entrada e porta)
                if noatual[2] == 200:
                    fila.append(noatual[0])
                    fila.append(noatual[1])
                    fila.append(noatual[3])
                    myarray.append(GENS_EVOL[posicao][noatual[0]])
                    myarray.append(GENS_EVOL[posicao][noatual[1]])
                    myarray.append(GENS_EVOL[posicao][noatual[3]])
                else:
                    fila.append(noatual[0]) #Adiciona primeira entrada do nó saída
                    fila.append(noatual[1]) #Adiciona segunda entrada do nó saída
                    myarray.append(GENS_EVOL[posicao][noatual[0]]) #Adiciona o gene responsável pela primeira entrada
                    myarray.append(GENS_EVOL[posicao][noatual[1]]) #Adiciona o gene responsável pela segunda entrada
            else:
                fila.append(noatual) #Se tamanho é diferente de 3, então é uma entrada. Logo a fila recebe o valor da posição da entrada.
            while len(myarray) != 0: #Procedimento para esvaziar a fila
                noatual = myarray[0]
                if type(noatual) is int: #(len(noatual) != 3: #Considerando tamanho 3 do gene, isto é, duas entradas mais a função
                    fila.append("entrada")
                    myarray.pop(0)
                else:
                    if noatual[2] == 200:
                        fila.append(noatual[0])
                        fila.append(noatual[1])
                        fila.append(noatual[3])
                        myarray.append(GENS_EVOL[posicao][noatual[0]])
                        myarray.append(GENS_EVOL[posicao][noatual[1]])
                        myarray.append(GENS_EVOL[posicao][noatual[3]])
                        myarray.pop(0)
                    else:
                        fila.append(noatual[0])
                        fila.append(noatual[1])
                        myarray.append(GENS_EVOL[posicao][noatual[0]])
                        myarray.append(GENS_EVOL[posicao][noatual[1]])
                        myarray.pop(0)
                    
            for j in range(len(fila)): # Coloca X nas posições ativas do genótipo
                if type(fila[j]) is int:
                    if vetor[fila[j]] == "-":
                        vetor[fila[j]] = "X"

            MEUARRAY[posicao][i] = copy.deepcopy(vetor)
            vetor.clear()
            for k in range(Ln+ni):
                vetor.append("-")

            fila = [] #Limpa o vetor fila
            myarray = [] #Limpa o vetor myarray

               
def mutacao_pontual():
    for k in range(ee_lambda): #Realiza mutações e gera "ee_lambda" variações do pai
        #print("ESTAMOS EM K IGUAL A", k)

        qtd_mutacao = r.randint(1, ug) #Determina quantos nós serão mutados, dentro do intervalo recomendado pela literatura
        for i in range(qtd_mutacao): #Realiza "qtd_mutacao" de mutações NESTE descendente
            G = copy.deepcopy(GENS_EVOL[0]) #Busca o pai original de volta (sempre alocado em GENS_EVOL[0])
            gene_mutado = r.randint(ni, (ni+no+Ln-1)) #O gene que será mutado pode receber qualquer valor maior que o último espaço ocupado pela entrada, isto é da posição ni (já que começa por 0) até a posição da última saida
            print(gene_mutado)
            if gene_mutado >= (Ln+ni): #Garante que o gene selecionado é uma saída
                ultimo_elemento = ni + Ln - 1 #Último elemento possivel que a saída pode assumir
                primeiro_elemento = ultimo_elemento - (lb * nr) + 1 #Primeiro valor possivel que a saída pode assumir
                elementos_portas = ultimo_elemento - primeiro_elemento + 1 #Quantidade de valores existentes entre o primeiro e último possiveis valores
                qtd_elementos = elementos_portas + ni - 1 #Determina a quantidade de valores distintos que a porta pode assumir como entrada. O -1 tem como função apenas possibilitar o uso de randint(0, qtd_elementos)
                entrada_ou_porta = r.randint(0, qtd_elementos) #Dá a mesma chance para todos os possiveis inputs
                if entrada_ou_porta >= ni: #G[Ln+ni+i] representa cada saida, sequencialmente
                    nova_saida = r.randint(primeiro_elemento, ultimo_elemento)
                    while G[gene_mutado] == nova_saida: #Garante que a mutação mudará o gene_mutado para um valor diferente do inicial
                        nova_saida = r.randint(primeiro_elemento, ultimo_elemento)
                    G[gene_mutado] = nova_saida
                else:
                    nova_saida = r.randint(0, ni-1)
                    while G[gene_mutado] == nova_saida: #Garante que a mutação mudará o gene_mutado para um valor diferente do inicial
                        nova_saida = r.randint(0, ni-1)
                    G[gene_mutado] = nova_saida    
            else:
                colunaatual = int((gene_mutado - ni)/nr) + 1 #Determina a coluna na qual o gene selecionado está
                alelo_mutado = r.randint(0, max_entradas) #Determina qual será o alelo a ser mutado
                #print("Mutação em nó", gene_mutado, " alelo ", alelo_mutado, " coluna ", colunaatual)
                #print("Nó correspondente: ", G[gene_mutado])
    
                if alelo_mutado == max_entradas: #Significa que a mutação ocorrerá no tipo da porta
                    porta_logica = r.randint(0, (len(FT)-1)) #Determina qual será a nova porta
                    while G[gene_mutado][alelo_mutado] == FT[porta_logica]: #Garante que a mutação mudará o gene_mutado para um valor diferente do inicial
                        porta_logica = r.randint(0, (len(FT)-1))
                    G[gene_mutado][alelo_mutado] = FT[porta_logica] #Atribui a nova porta ao gene
                else:
                    if colunaatual == 1: #Neste caso as portas lógicas só recebem inputs
                        entrada = r.randint(0, (ni-1))
                        while G[gene_mutado][alelo_mutado] == entrada:#Garante que a mutação mudará o gene_mutado para um valor diferente do inicial
                            entrada = r.randint(0, (ni-1))
                        G[gene_mutado][alelo_mutado] = entrada

                    
                    if colunaatual - lb < 1 and colunaatual != 1: #Neste caso as portas lógicas recebem inputs e nós       
                        valorpossivel = (nr * (colunaatual-2)) + (nr-1) + ni
                        sorteado = r.randint(0, valorpossivel)
                        while G[gene_mutado][alelo_mutado] == sorteado:#Garante que a mutação mudará o gene_mutado para um valor diferente do inicial
                            sorteado = r.randint(0, valorpossivel)
                        G[gene_mutado][alelo_mutado] = sorteado

            
                    if colunaatual - lb >= 1: #Neste caso as portas logicas recebem somente nós
                        primeiro_elemento = nr * (colunaatual-lb-1) + ni # O fator + ni serve para deslocar os elementos para frente, contando a quantidade de inputs.
                        ultimo_elemento = (nr * (colunaatual-2)) + (nr-1) + ni 
                        elementos_portas = ultimo_elemento - primeiro_elemento + 1 #Determina quantas portas possíveis existem
                        qtd_elementos = elementos_portas + ni - 1 #Determina a quantidade de valores distintos que a porta pode assumir como entrada. O -1 tem como função apenas possibilitar o uso de randint(0, qtd_elementos)
                        entrada_ou_porta = r.randint(0, qtd_elementos) #Dá a mesma chance para todos os possiveis inputs
                        if entrada_ou_porta >= ni:
                            novo_valor_mutacao = r.randint(primeiro_elemento, ultimo_elemento)
                            while G[gene_mutado][alelo_mutado] == novo_valor_mutacao:#Garante que a mutação mudará o gene_mutado para um valor diferente do inicial
                                novo_valor_mutacao = r.randint(primeiro_elemento, ultimo_elemento)
                            G[gene_mutado][alelo_mutado] = novo_valor_mutacao
                        else:
                            novo_valor_mutacao = r.randint(0, ni-1)
                            while G[gene_mutado][alelo_mutado] == novo_valor_mutacao:#Garante que a mutação mudará o gene_mutado para um valor diferente do inicial
                                novo_valor_mutacao = r.randint(0, ni-1)
                            G[gene_mutado][alelo_mutado] = novo_valor_mutacao
    
                #print("Nó correspondente: ", G[gene_mutado])

        GENS_EVOL[k+1] = copy.deepcopy(G) #Passa o genótipo mutado para a matriz de genótipos
        #print("EVOL K+1", GENS_EVOL[k+1])

def conta_portas(posicao):
    ATIVOS_LOCAL = []
    todos_ativos = []
    for i in range(len(MEUARRAY[posicao])):
        for j in range(len(MEUARRAY[posicao][i])):
            if MEUARRAY[posicao][i][j] == "X":
                todos_ativos.append(j)
    ATIVOS_LOCAL.clear()
    ATIVOS_LOCAL.append([])
    ATIVOS_LOCAL[0] = copy.deepcopy(MEUARRAY[posicao][0])
    for i in range(len(ATIVOS_LOCAL[0])):
        if ATIVOS_LOCAL[0][i] == "X":
            ATIVOS_LOCAL[0][i] = "X"
    for i in todos_ativos:
        ATIVOS_LOCAL[0][i] = "X"

    qtd_portas = 0
    qtd_wires = 0

    for i in range(len(ATIVOS_LOCAL[0])):
        if i >= ni and ATIVOS_LOCAL[0][i] == "X":
            if GENS_EVOL[posicao][i][2] == 900:
                qtd_wires = qtd_wires + 1
            elif GENS_EVOL[posicao][i][2] != 900 and GENS_EVOL[posicao][i][2] != 980 and GENS_EVOL[posicao][i][2] != 990:
                qtd_portas = qtd_portas + 1
    PORTAS_CKT[posicao] = copy.deepcopy(qtd_portas)
    WIRES_CKT[posicao] = copy.deepcopy(qtd_wires)


def conta_portas_mux(posicao):
    ATIVOS_LOCAL = []
    todos_ativos = []
    for i in range(len(MEUARRAY[posicao])):
        for j in range(len(MEUARRAY[posicao][i])):
            if MEUARRAY[posicao][i][j] == "X":
                todos_ativos.append(j)
    ATIVOS_LOCAL.clear()
    ATIVOS_LOCAL.append([])
    ATIVOS_LOCAL[0] = copy.deepcopy(MEUARRAY[posicao][0])
    for i in range(len(ATIVOS_LOCAL[0])):
        if ATIVOS_LOCAL[0][i] == "X":
            ATIVOS_LOCAL[0][i] = "X"
    for i in todos_ativos:
        ATIVOS_LOCAL[0][i] = "X"

    qtd_portas = 0
    qtd_wires = 0
    qtd_mux = 0

    for i in range(len(ATIVOS_LOCAL[0])):
        if i >= ni and ATIVOS_LOCAL[0][i] == "X":
            if GENS_EVOL[posicao][i][2] == 900:
                qtd_wires = qtd_wires + 1
            elif GENS_EVOL[posicao][i][2] != 900 and GENS_EVOL[posicao][i][2] != 980 and GENS_EVOL[posicao][i][2] != 990 and GENS_EVOL[posicao][i][2] != 200:
                qtd_portas = qtd_portas + 1
            elif GENS_EVOL[posicao][i][2] == 200:
                qtd_mux = qtd_mux + 1
                
    PORTAS_CKT[posicao] = copy.deepcopy(qtd_portas)
    WIRES_CKT[posicao] = copy.deepcopy(qtd_wires)
    MUX_CKT[posicao] = copy.deepcopy(qtd_mux)


def mutacao_BSAM_ADAPTATIVO(posicao):
    AND_LOCAL = []
    OR_LOCAL = []
    XOR_LOCAL = []
    NOT_LOCAL = []
    WIRE_LOCAL = []
    for i in range(len(GATE_TROCA_NORM)):
        for j in range(len(GATE_TROCA_NORM[i])):
            if i == 0:
                for k in range(int(GATE_TROCA_NORM[i][j][0] * 100)):
                    if j == 1:
                        AND_LOCAL.append(110)
                    if j == 2:
                        AND_LOCAL.append(130)
                    if j == 3:
                        AND_LOCAL.append(800)
                    if j == 4:
                        AND_LOCAL.append(900)
            if i == 1:
                for k in range(int(GATE_TROCA_NORM[i][j][0] * 100)):
                    if j == 0:
                        OR_LOCAL.append(100)
                    if j == 2:
                        OR_LOCAL.append(130)
                    if j == 3:
                        OR_LOCAL.append(800)
                    if j == 4:
                        OR_LOCAL.append(900)
            if i == 2:
                for k in range(int(GATE_TROCA_NORM[i][j][0] * 100)):
                    if j == 0:
                        XOR_LOCAL.append(100)
                    if j == 1:
                        XOR_LOCAL.append(110)
                    if j == 3:
                        XOR_LOCAL.append(800)
                    if j == 4:
                        XOR_LOCAL.append(900)
            if i == 3:
                for k in range(int(GATE_TROCA_NORM[i][j][0] * 100)):
                    if j == 0:
                        NOT_LOCAL.append(100)
                    if j == 1:
                        NOT_LOCAL.append(110)
                    if j == 2:
                        NOT_LOCAL.append(130)
                    if j == 4:
                        NOT_LOCAL.append(900)
            if i == 4:
                for k in range(int(GATE_TROCA_NORM[i][j][0] * 100)):
                    if j == 0:
                        WIRE_LOCAL.append(100)
                    if j == 1:
                        WIRE_LOCAL.append(110)
                    if j == 2:
                        WIRE_LOCAL.append(130)
                    if j == 3:
                        WIRE_LOCAL.append(800)

    AND = copy.deepcopy(AND_LOCAL)
    OR = copy.deepcopy(OR_LOCAL)
    XOR = copy.deepcopy(XOR_LOCAL)
    NOT = copy.deepcopy(NOT_LOCAL)
    WIRE = copy.deepcopy(WIRE_LOCAL)    
    #arquivo_evolucao = open("evolucao.txt", "a")
    #arquivo_evolucao.write("\n ATUALIZAÇÃO MATRIZ: ")
    #arquivo_evolucao.write("\n GATE TROCA NORM: " + str(GATE_TROCA_NORM))
    #arquivo_evolucao.write("\n AND: " + str(AND))
    #arquivo_evolucao.write("\n OR: " + str(OR))
    #arquivo_evolucao.write("\n XOR: " + str(XOR))
    #arquivo_evolucao.write("\n NOT: " + str(NOT))
    #arquivo_evolucao.write("\n WIRE: " + str(WIRE))

    
    #arquivo_evolucao.close()


    ativo = False
    arquivo_evolucao = open('evolucao.txt', 'a')
    #arquivo_evolucao.write("\n MUTAÇÃO TIPO SAM")
    todos_ativos = []
    for i in range(len(MEUARRAY[0])):
        for j in range(len(MEUARRAY[0][i])):
            if MEUARRAY[0][i][j] == "X":
                todos_ativos.append(j)
    ATIVO_MOM.clear()
    ATIVO_MOM.append([])
    ATIVO_MOM[0] = copy.deepcopy(MEUARRAY[0][0])
    for i in range(len(ATIVO_MOM[0])):
        if ATIVO_MOM[0][i] == "X":
            ATIVO_MOM[0][i] = "-"
    for i in todos_ativos:
        ATIVO_MOM[0][i] = "X"
    controle_ativo = True
    quantidade_de_mutacoes = 0
    controle_auxiliar = 0 # Esta variável serve para o index da lista ATIVO_MOM[g][gene_mutado] não ser violado
        #FICA FAZENDO MUTAÇÃO
    for g in range(1): # Se for range(no), fará mutação em ao menos UM nó ativo para CADA saida, se for range(1), mudará somente UM gene ativo de todo o genótipo 
        qtd_mutacao = r.randint(1, ug) #Determina quantos nós serão mutados, dentro do intervalo recomendado pela literatura
        while controle_ativo == True: #Realiza "qtd_mutacao" de mutações NESTE descendente
            G = copy.deepcopy(GENS_EVOL[0]) #Busca o pai original de volta (sempre alocado em GENS_EVOL[0])
            gene_mutado = r.randint(ni, (ni+no+Ln-1)) #O gene que será mutado pode receber qualquer valor maior que o último espaço ocupado pela entrada, isto é da posição ni (já que começa por 0) até a posição da última saida
            #arquivo_evolucao.write("\n Gene mutado: " + str(gene_mutado))
            if gene_mutado > ni+Ln-1:
                #arquivo_evolucao.write("\n GENE ATIVO")
                GLOBAL_MUTACAO_SAM_ATIVO[0] += 1
            else:
                if ATIVO_MOM[g][gene_mutado] != "X":
                    #arquivo_evolucao.write("\n GENE INATIVO")
                    GLOBAL_MUTACAO_SAM_INATIVO[0] += 1
                else:
                    #arquivo_evolucao.write("\n GENE ATIVO")
                    ativo = True
                    GLOBAL_MUTACAO_SAM_ATIVO[0] += 1
                    

                
            if gene_mutado > ni+Ln-1:
                quantidade_de_mutacoes += 1
                if quantidade_de_mutacoes == GLOBAL_SAM_MUTACOES:
                    controle_ativo = False
                controle_auxiliar = gene_mutado
                gene_mutado = 0

            if ATIVO_MOM[g][gene_mutado] == "X" and controle_ativo == True:

                if gene_mutado > ni+Ln-1:
                    quantidade_de_mutacoes += 1
                    if quantidade_de_mutacoes == GLOBAL_SAM_MUTACOES:
                        controle_ativo = False
                    controle_auxiliar = gene_mutado
                    gene_mutado = 0
                quantidade_de_mutacoes += 1
                if quantidade_de_mutacoes == GLOBAL_SAM_MUTACOES:
                    controle_ativo = False
                    


            if controle_auxiliar != 0:
                gene_mutado = controle_auxiliar
                controle_auxiliar = 0

            if gene_mutado >= (Ln+ni): #Garante que o gene selecionado é uma saída
                #arquivo_evolucao.write("\n MUTAÇÃO TIPO SAIDA")
                GLOBAL_MUTACAO_SAM_SAIDA[0] += 1
                ultimo_elemento = ni + Ln - 1 #Último elemento possivel que a saída pode assumir
                primeiro_elemento = ultimo_elemento - (lb * nr) + 1 #Primeiro valor possivel que a saída pode assumir
                elementos_portas = ultimo_elemento - primeiro_elemento + 1 #Quantidade de valores existentes entre o primeiro e último possiveis valores
                qtd_elementos = elementos_portas + ni - 1 #Determina a quantidade de valores distintos que a porta pode assumir como entrada. O -1 tem como função apenas possibilitar o uso de randint(0, qtd_elementos)
                entrada_ou_porta = r.randint(0, qtd_elementos) #Dá a mesma chance para todos os possiveis inputs
                if entrada_ou_porta >= ni: #G[Ln+ni+i] representa cada saida, sequencialmente
                    nova_saida = r.randint(primeiro_elemento, ultimo_elemento)
                    while G[gene_mutado] == nova_saida: #Garante que a mutação mudará o gene_mutado para um valor diferente do inicial
                        nova_saida = r.randint(primeiro_elemento, ultimo_elemento)
                    G[gene_mutado] = nova_saida
                else:
                    nova_saida = r.randint(0, ni-1)
                    while G[gene_mutado] == nova_saida: #Garante que a mutação mudará o gene_mutado para um valor diferente do inicial
                        nova_saida = r.randint(0, ni-1)
                    G[gene_mutado] = nova_saida    
            else:
                colunaatual = int((gene_mutado - ni)/nr) + 1 #Determina a coluna na qual o gene selecionado está
                alelo_mutado = r.randint(0, max_entradas) #Determina qual será o alelo a ser mutado

        
                if alelo_mutado == max_entradas: #Significa que a mutação ocorrerá no tipo da porta
                    #arquivo_evolucao.write("\n MUTAÇÃO TIPO PORTA")
                    if ativo == True:
                        porta_antes = G[gene_mutado][alelo_mutado]
                        #arquivo_evolucao.write("\n PORTA " + str(porta_antes))
                    GLOBAL_MUTACAO_SAM_PORTA[0] += 1
                    ########
                    porta_antes = G[gene_mutado][alelo_mutado]
                    if porta_antes == 100:
                        porta_logica = r.randint(0, len(AND)-1)
                    if porta_antes == 110:
                        porta_logica = r.randint(0, len(OR)-1)
                    if porta_antes == 130:
                        porta_logica = r.randint(0, len(XOR)-1)
                    if porta_antes == 800:
                        porta_logica = r.randint(0, len(NOT)-1)
                    if porta_antes == 900:
                        porta_logica = r.randint(0, len(WIRE)-1)



                    ########
                    #porta_logica = r.randint(0, (len(FT)-1)) #Determina qual será a nova porta
                    #while G[gene_mutado][alelo_mutado] == FT[porta_logica]: #Garante que a mutação mudará o gene_mutado para um valor diferente do inicial
                    #    #porta_logica = r.randint(0, (len(FT)-1))
                    #    if porta_antes == 100:
                    #        porta_logica = r.randint(0, len(AND)-1)
                    #    if porta_antes == 110:
                    #        porta_logica = r.randint(0, len(OR)-1)
                    #    if porta_antes == 130:
                    #        porta_logica = r.randint(0, len(XOR)-1)
                    #    if porta_antes == 800:
                    #        porta_logica = r.randint(0, len(NOT)-1)
                    #    if porta_antes == 900:
                    #        porta_logica = r.randint(0, len(WIRE)-1)                        
                    #G[gene_mutado][alelo_mutado] = FT[porta_logica] #Atribui a nova porta ao gene
                        
                    
                    if ativo == True:
                        #arquivo_evolucao.write("\n PORTA DEPOIS: " + str(FT[porta_logica]))
                        if porta_antes == 100:
                            porta_depois = AND[porta_logica]
                        if porta_antes == 110:
                            porta_depois = OR[porta_logica]
                        if porta_antes == 130:
                            porta_depois = XOR[porta_logica]
                        if porta_antes == 800:
                            porta_depois = NOT[porta_logica]
                        if porta_antes == 900:
                            porta_depois = WIRE[porta_logica]
                            
                        preenche_matriz_portas(porta_antes, porta_depois)
                        #arquivo_evolucao.write("\n MATRIZ: " + str(GATE_INFAC))
                        #IND_MUT_SAM[posicao-1].clear()
                        if posicao == 1 or posicao == 2:
                            IND_MUT_SAM[posicao-1][0][0] = copy.deepcopy(porta_antes)
                            IND_MUT_SAM[posicao-1][1][0] = copy.deepcopy(porta_depois)
                        else:
                            IND_MUT_GAM[posicao-3][0][0] = copy.deepcopy(porta_antes)
                            IND_MUT_GAM[posicao-3][1][0] = copy.deepcopy(porta_depois)
                        #arquivo_evolucao.write("\n IND MUT SAM " + str(IND_MUT_SAM))
                else:
                    #arquivo_evolucao.write("\n MUTAÇÃO TIPO INPUT")
                    GLOBAL_MUTACAO_SAM_INPUT[0] += 1
                    if colunaatual == 1: #Neste caso as portas lógicas só recebem inputs
                        entrada = r.randint(0, (ni-1))
                        while G[gene_mutado][alelo_mutado] == entrada:#Garante que a mutação mudará o gene_mutado para um valor diferente do inicial
                            entrada = r.randint(0, (ni-1))
                        G[gene_mutado][alelo_mutado] = entrada
    
                        
                    if colunaatual - lb < 1 and colunaatual != 1: #Neste caso as portas lógicas recebem inputs e nós       
                        valorpossivel = (nr * (colunaatual-2)) + (nr-1) + ni
                        sorteado = r.randint(0, valorpossivel)
                        while G[gene_mutado][alelo_mutado] == sorteado:#Garante que a mutação mudará o gene_mutado para um valor diferente do inicial
                            sorteado = r.randint(0, valorpossivel)
                        G[gene_mutado][alelo_mutado] = sorteado
    
                
                    if colunaatual - lb >= 1: #Neste caso as portas logicas recebem somente nós
                        primeiro_elemento = nr * (colunaatual-lb-1) + ni # O fator + ni serve para deslocar os elementos para frente, contando a quantidade de inputs.
                        ultimo_elemento = (nr * (colunaatual-2)) + (nr-1) + ni 
                        elementos_portas = ultimo_elemento - primeiro_elemento + 1 #Determina quantas portas possíveis existem
                        qtd_elementos = elementos_portas + ni - 1 #Determina a quantidade de valores distintos que a porta pode assumir como entrada. O -1 tem como função apenas possibilitar o uso de randint(0, qtd_elementos)
                        entrada_ou_porta = r.randint(0, qtd_elementos) #Dá a mesma chance para todos os possiveis inputs
                        if entrada_ou_porta >= ni:
                            novo_valor_mutacao = r.randint(primeiro_elemento, ultimo_elemento)
                            while G[gene_mutado][alelo_mutado] == novo_valor_mutacao:#Garante que a mutação mudará o gene_mutado para um valor diferente do inicial
                                novo_valor_mutacao = r.randint(primeiro_elemento, ultimo_elemento)
                            G[gene_mutado][alelo_mutado] = novo_valor_mutacao
                        else:
                            novo_valor_mutacao = r.randint(0, ni-1)
                            while G[gene_mutado][alelo_mutado] == novo_valor_mutacao:#Garante que a mutação mudará o gene_mutado para um valor diferente do inicial
                                novo_valor_mutacao = r.randint(0, ni-1)
                            G[gene_mutado][alelo_mutado] = novo_valor_mutacao

        SAM_ativo(posicao)
        GENS_EVOL[posicao] = copy.deepcopy(G) #Passa o genótipo mutado para a matriz de genótipos

        G = copy.deepcopy(GENS_EVOL[0])

        arquivo_evolucao.close()
    
def mutacao_SAM_CORRETO_CROSS(posicao):

    todos_ativos = []
    for i in range(len(MEUARRAY[0])):
        for j in range(len(MEUARRAY[0][i])):
            if MEUARRAY[0][i][j] == "X":
                todos_ativos.append(j)
    ATIVO_MOM.clear()
    ATIVO_MOM.append([])
    ATIVO_MOM[0] = copy.deepcopy(MEUARRAY[0][0])
    for i in range(len(ATIVO_MOM[0])):
        if ATIVO_MOM[0][i] == "X":
            ATIVO_MOM[0][i] = "-"
    for i in todos_ativos:
        ATIVO_MOM[0][i] = "X"
    controle_ativo = True
    quantidade_de_mutacoes = 0
    controle_auxiliar = 0 # Esta variável serve para o index da lista ATIVO_MOM[g][gene_mutado] não ser violado
        #FICA FAZENDO MUTAÇÃO
    for g in range(1): # Se for range(no), fará mutação em ao menos UM nó ativo para CADA saida, se for range(1), mudará somente UM gene ativo de todo o genótipo 
        qtd_mutacao = r.randint(1, ug) #Determina quantos nós serão mutados, dentro do intervalo recomendado pela literatura
        while controle_ativo == True: #Realiza "qtd_mutacao" de mutações NESTE descendente
            G = copy.deepcopy(GENS_EVOL[0]) #Busca o pai original de volta (sempre alocado em GENS_EVOL[0])
            gene_mutado = r.randint(ni, (ni+no+Ln-1)) #O gene que será mutado pode receber qualquer valor maior que o último espaço ocupado pela entrada, isto é da posição ni (já que começa por 0) até a posição da última saida

            if gene_mutado > ni+Ln-1:
                quantidade_de_mutacoes += 1
                if quantidade_de_mutacoes == GLOBAL_SAM_MUTACOES_CROSS:
                    controle_ativo = False
                controle_auxiliar = gene_mutado
                gene_mutado = 0
            if ATIVO_MOM[g][gene_mutado] == "X" and controle_ativo == True:
                if gene_mutado > ni+Ln-1:
                    quantidade_de_mutacoes += 1
                    if quantidade_de_mutacoes == GLOBAL_SAM_MUTACOES_CROSS:
                        controle_ativo = False
                    controle_auxiliar = gene_mutado
                    gene_mutado = 0
                quantidade_de_mutacoes += 1
                if quantidade_de_mutacoes == GLOBAL_SAM_MUTACOES_CROSS:
                    controle_ativo = False

            if controle_auxiliar != 0:
                gene_mutado = controle_auxiliar
                controle_auxiliar = 0

            if gene_mutado >= (Ln+ni): #Garante que o gene selecionado é uma saída
                #print("MUTAÇÃO TIPO SAIDA")
                ultimo_elemento = ni + Ln - 1 #Último elemento possivel que a saída pode assumir
                primeiro_elemento = ultimo_elemento - (lb * nr) + 1 #Primeiro valor possivel que a saída pode assumir
                elementos_portas = ultimo_elemento - primeiro_elemento + 1 #Quantidade de valores existentes entre o primeiro e último possiveis valores
                qtd_elementos = elementos_portas + ni - 1 #Determina a quantidade de valores distintos que a porta pode assumir como entrada. O -1 tem como função apenas possibilitar o uso de randint(0, qtd_elementos)
                entrada_ou_porta = r.randint(0, qtd_elementos) #Dá a mesma chance para todos os possiveis inputs
                if entrada_ou_porta >= ni: #G[Ln+ni+i] representa cada saida, sequencialmente
                    nova_saida = r.randint(primeiro_elemento, ultimo_elemento)
                    while G[gene_mutado] == nova_saida: #Garante que a mutação mudará o gene_mutado para um valor diferente do inicial
                        nova_saida = r.randint(primeiro_elemento, ultimo_elemento)
                    G[gene_mutado] = nova_saida
                else:
                    nova_saida = r.randint(0, ni-1)
                    while G[gene_mutado] == nova_saida: #Garante que a mutação mudará o gene_mutado para um valor diferente do inicial
                        nova_saida = r.randint(0, ni-1)
                    G[gene_mutado] = nova_saida    
            else:
                colunaatual = int((gene_mutado - ni)/nr) + 1 #Determina a coluna na qual o gene selecionado está
                alelo_mutado = r.randint(0, max_entradas) #Determina qual será o alelo a ser mutado

        
                if alelo_mutado == max_entradas: #Significa que a mutação ocorrerá no tipo da porta
                    #print("MUTAÇÃO TIPO PORTA") 
                    porta_logica = r.randint(0, (len(FT)-1)) #Determina qual será a nova porta
                    while G[gene_mutado][alelo_mutado] == FT[porta_logica]: #Garante que a mutação mudará o gene_mutado para um valor diferente do inicial
                        porta_logica = r.randint(0, (len(FT)-1))
                    G[gene_mutado][alelo_mutado] = FT[porta_logica] #Atribui a nova porta ao gene
                else:
                    #print("MUTAÇÃO TIPO INPUT")
                    if colunaatual == 1: #Neste caso as portas lógicas só recebem inputs
                        entrada = r.randint(0, (ni-1))
                        while G[gene_mutado][alelo_mutado] == entrada:#Garante que a mutação mudará o gene_mutado para um valor diferente do inicial
                            entrada = r.randint(0, (ni-1))
                        G[gene_mutado][alelo_mutado] = entrada
    
                        
                    if colunaatual - lb < 1 and colunaatual != 1: #Neste caso as portas lógicas recebem inputs e nós       
                        valorpossivel = (nr * (colunaatual-2)) + (nr-1) + ni
                        sorteado = r.randint(0, valorpossivel)
                        while G[gene_mutado][alelo_mutado] == sorteado:#Garante que a mutação mudará o gene_mutado para um valor diferente do inicial
                            sorteado = r.randint(0, valorpossivel)
                        G[gene_mutado][alelo_mutado] = sorteado
    
                
                    if colunaatual - lb >= 1: #Neste caso as portas logicas recebem somente nós
                        primeiro_elemento = nr * (colunaatual-lb-1) + ni # O fator + ni serve para deslocar os elementos para frente, contando a quantidade de inputs.
                        ultimo_elemento = (nr * (colunaatual-2)) + (nr-1) + ni 
                        elementos_portas = ultimo_elemento - primeiro_elemento + 1 #Determina quantas portas possíveis existem
                        qtd_elementos = elementos_portas + ni - 1 #Determina a quantidade de valores distintos que a porta pode assumir como entrada. O -1 tem como função apenas possibilitar o uso de randint(0, qtd_elementos)
                        entrada_ou_porta = r.randint(0, qtd_elementos) #Dá a mesma chance para todos os possiveis inputs
                        if entrada_ou_porta >= ni:
                            novo_valor_mutacao = r.randint(primeiro_elemento, ultimo_elemento)
                            while G[gene_mutado][alelo_mutado] == novo_valor_mutacao:#Garante que a mutação mudará o gene_mutado para um valor diferente do inicial
                                novo_valor_mutacao = r.randint(primeiro_elemento, ultimo_elemento)
                            G[gene_mutado][alelo_mutado] = novo_valor_mutacao
                        else:
                            novo_valor_mutacao = r.randint(0, ni-1)
                            while G[gene_mutado][alelo_mutado] == novo_valor_mutacao:#Garante que a mutação mudará o gene_mutado para um valor diferente do inicial
                                novo_valor_mutacao = r.randint(0, ni-1)
                            G[gene_mutado][alelo_mutado] = novo_valor_mutacao

        SAM_ativo(posicao)
        GENS_EVOL[posicao] = copy.deepcopy(G) #Passa o genótipo mutado para a matriz de genótipos

        G = copy.deepcopy(GENS_EVOL[0])
    
def mutacao_SAIM_CORRETO(posicao):

    todos_ativos = []
    for i in range(len(MEUARRAY[0])):
        for j in range(len(MEUARRAY[0][i])):
            if MEUARRAY[0][i][j] == "X":
                todos_ativos.append(j)
    ATIVO_MOM.clear()
    ATIVO_MOM.append([])
    ATIVO_MOM[0] = copy.deepcopy(MEUARRAY[0][0])
    for i in range(len(ATIVO_MOM[0])):
        if ATIVO_MOM[0][i] == "X":
            ATIVO_MOM[0][i] = "-"
    for i in todos_ativos:
        ATIVO_MOM[0][i] = "X"
    controle_ativo = True
    quantidade_de_mutacoes = 0
    quantidade_mutacoes_inativo = 0
    controle_auxiliar = 0 # Esta variável serve para o index da lista ATIVO_MOM[g][gene_mutado] não ser violado
        #FICA FAZENDO MUTAÇÃO
    for g in range(1): # Se for range(no), fará mutação em ao menos UM nó ativo para CADA saida, se for range(1), mudará somente UM gene ativo de todo o genótipo 
        qtd_mutacao = r.randint(1, ug) #Determina quantos nós serão mutados, dentro do intervalo recomendado pela literatura
        while controle_ativo == True: #and quantidade_mutacoes_inativo == 0: #Realiza "qtd_mutacao" de mutações NESTE descendente
            G = copy.deepcopy(GENS_EVOL[0]) #Busca o pai original de volta (sempre alocado em GENS_EVOL[0])
            gene_mutado = r.randint(ni, (ni+no+Ln-1)) #O gene que será mutado pode receber qualquer valor maior que o último espaço ocupado pela entrada, isto é da posição ni (já que começa por 0) até a posição da última saida

            if gene_mutado > ni+Ln-1:
                quantidade_de_mutacoes += 1
                if quantidade_de_mutacoes == GLOBAL_SAM_MUTACOES_CROSS:
                    controle_ativo = False
                controle_auxiliar = gene_mutado
                gene_mutado = 0
            
            if ATIVO_MOM[g][gene_mutado] == "X" and controle_ativo == True:
                if gene_mutado > ni+Ln-1:
                    quantidade_de_mutacoes += 1
                    if quantidade_de_mutacoes == GLOBAL_SAM_MUTACOES_CROSS:
                        controle_ativo = False
                    controle_auxiliar = gene_mutado
                    gene_mutado = 0
                quantidade_de_mutacoes += 1
                if quantidade_de_mutacoes == GLOBAL_SAM_MUTACOES_CROSS:
                    controle_ativo = False

            if ATIVO_MOM[g][gene_mutado] != "X":
                quantidade_mutacoes_inativo += 1

            if controle_auxiliar != 0:
                gene_mutado = controle_auxiliar
                controle_auxiliar = 0

            if gene_mutado >= (Ln+ni): #Garante que o gene selecionado é uma saída
                #print("MUTAÇÃO TIPO SAIDA")
                ultimo_elemento = ni + Ln - 1 #Último elemento possivel que a saída pode assumir
                primeiro_elemento = ultimo_elemento - (lb * nr) + 1 #Primeiro valor possivel que a saída pode assumir
                elementos_portas = ultimo_elemento - primeiro_elemento + 1 #Quantidade de valores existentes entre o primeiro e último possiveis valores
                qtd_elementos = elementos_portas + ni - 1 #Determina a quantidade de valores distintos que a porta pode assumir como entrada. O -1 tem como função apenas possibilitar o uso de randint(0, qtd_elementos)
                entrada_ou_porta = r.randint(0, qtd_elementos) #Dá a mesma chance para todos os possiveis inputs
                if entrada_ou_porta >= ni: #G[Ln+ni+i] representa cada saida, sequencialmente
                    nova_saida = r.randint(primeiro_elemento, ultimo_elemento)
                    while G[gene_mutado] == nova_saida: #Garante que a mutação mudará o gene_mutado para um valor diferente do inicial
                        nova_saida = r.randint(primeiro_elemento, ultimo_elemento)
                    G[gene_mutado] = nova_saida
                else:
                    nova_saida = r.randint(0, ni-1)
                    while G[gene_mutado] == nova_saida: #Garante que a mutação mudará o gene_mutado para um valor diferente do inicial
                        nova_saida = r.randint(0, ni-1)
                    G[gene_mutado] = nova_saida    
            else:
                colunaatual = int((gene_mutado - ni)/nr) + 1 #Determina a coluna na qual o gene selecionado está
                alelo_mutado = r.randint(0, max_entradas) #Determina qual será o alelo a ser mutado

        
                if alelo_mutado == max_entradas: #Significa que a mutação ocorrerá no tipo da porta
                    #print("MUTAÇÃO TIPO PORTA") 
                    porta_logica = r.randint(0, (len(FT)-1)) #Determina qual será a nova porta
                    while G[gene_mutado][alelo_mutado] == FT[porta_logica]: #Garante que a mutação mudará o gene_mutado para um valor diferente do inicial
                        porta_logica = r.randint(0, (len(FT)-1))
                    G[gene_mutado][alelo_mutado] = FT[porta_logica] #Atribui a nova porta ao gene
                else:
                    #print("MUTAÇÃO TIPO INPUT")
                    if colunaatual == 1: #Neste caso as portas lógicas só recebem inputs
                        entrada = r.randint(0, (ni-1))
                        while G[gene_mutado][alelo_mutado] == entrada:#Garante que a mutação mudará o gene_mutado para um valor diferente do inicial
                            entrada = r.randint(0, (ni-1))
                        G[gene_mutado][alelo_mutado] = entrada
    
                        
                    if colunaatual - lb < 1 and colunaatual != 1: #Neste caso as portas lógicas recebem inputs e nós       
                        valorpossivel = (nr * (colunaatual-2)) + (nr-1) + ni
                        sorteado = r.randint(0, valorpossivel)
                        while G[gene_mutado][alelo_mutado] == sorteado:#Garante que a mutação mudará o gene_mutado para um valor diferente do inicial
                            sorteado = r.randint(0, valorpossivel)
                        G[gene_mutado][alelo_mutado] = sorteado
    
                
                    if colunaatual - lb >= 1: #Neste caso as portas logicas recebem somente nós
                        primeiro_elemento = nr * (colunaatual-lb-1) + ni # O fator + ni serve para deslocar os elementos para frente, contando a quantidade de inputs.
                        ultimo_elemento = (nr * (colunaatual-2)) + (nr-1) + ni 
                        elementos_portas = ultimo_elemento - primeiro_elemento + 1 #Determina quantas portas possíveis existem
                        qtd_elementos = elementos_portas + ni - 1 #Determina a quantidade de valores distintos que a porta pode assumir como entrada. O -1 tem como função apenas possibilitar o uso de randint(0, qtd_elementos)
                        entrada_ou_porta = r.randint(0, qtd_elementos) #Dá a mesma chance para todos os possiveis inputs
                        if entrada_ou_porta >= ni:
                            novo_valor_mutacao = r.randint(primeiro_elemento, ultimo_elemento)
                            while G[gene_mutado][alelo_mutado] == novo_valor_mutacao:#Garante que a mutação mudará o gene_mutado para um valor diferente do inicial
                                novo_valor_mutacao = r.randint(primeiro_elemento, ultimo_elemento)
                            G[gene_mutado][alelo_mutado] = novo_valor_mutacao
                        else:
                            novo_valor_mutacao = r.randint(0, ni-1)
                            while G[gene_mutado][alelo_mutado] == novo_valor_mutacao:#Garante que a mutação mudará o gene_mutado para um valor diferente do inicial
                                novo_valor_mutacao = r.randint(0, ni-1)
                            G[gene_mutado][alelo_mutado] = novo_valor_mutacao

        SAM_ativo(posicao)
        GENS_EVOL[posicao] = copy.deepcopy(G) #Passa o genótipo mutado para a matriz de genótipos

        G = copy.deepcopy(GENS_EVOL[0])

def mutacao_GAM(posicao): ##Guided Active Mutation

    ## Determina a pior saída
    pior_saida = min(FITNESS_EE[0])
    piores_saidas = []
    for i in range(len(FITNESS_EE[0])):
        if FITNESS_EE[0][i] == pior_saida:
            piores_saidas.append(i)

    indice_saida_selecionada = r.randint(0, len(piores_saidas)-1)
    saida_selecionada = piores_saidas[indice_saida_selecionada]
    
    
    todos_ativos = []
    for i in range(len(MEUARRAY[0][saida_selecionada])):
        if MEUARRAY[0][saida_selecionada][i] == "X":
            todos_ativos.append(i)
    ATIVO_MOM.clear()
    ATIVO_MOM.append([])
    ATIVO_MOM[0] = copy.deepcopy(MEUARRAY[0][saida_selecionada])
    for i in range(len(ATIVO_MOM[0])):
        if ATIVO_MOM[0][i] == "X":
            ATIVO_MOM[0][i] = "-"
    for i in todos_ativos:
        ATIVO_MOM[0][i] = "X"
    controle_ativo = True
    quantidade_de_mutacoes = 0
    controle_auxiliar = 0 # Esta variável serve para o index da lista ATIVO_MOM[g][gene_mutado] não ser violado
        #FICA FAZENDO MUTAÇÃO
    for g in range(1): # Se for range(no), fará mutação em ao menos UM nó ativo para CADA saida, se for range(1), mudará somente UM gene ativo de todo o genótipo 
        qtd_mutacao = r.randint(1, ug) #Determina quantos nós serão mutados, dentro do intervalo recomendado pela literatura
        while controle_ativo == True: #Realiza "qtd_mutacao" de mutações NESTE descendente
            G = copy.deepcopy(GENS_EVOL[0]) #Busca o pai original de volta (sempre alocado em GENS_EVOL[0])
            gene_mutado = r.randint(ni, (ni+no+Ln-1)) #O gene que será mutado pode receber qualquer valor maior que o último espaço ocupado pela entrada, isto é da posição ni (já que começa por 0) até a posição da última saida

            if gene_mutado > ni+Ln-1:
                quantidade_de_mutacoes += 1
                if quantidade_de_mutacoes == GLOBAL_SAM_MUTACOES:
                    controle_ativo = False
                controle_auxiliar = gene_mutado
                gene_mutado = 0
            if ATIVO_MOM[g][gene_mutado] == "X" and controle_ativo == True:
                if gene_mutado > ni+Ln-1:
                    quantidade_de_mutacoes += 1
                    if quantidade_de_mutacoes == GLOBAL_SAM_MUTACOES:
                        controle_ativo = False
                    controle_auxiliar = gene_mutado
                    gene_mutado = 0
                quantidade_de_mutacoes += 1
                if quantidade_de_mutacoes == GLOBAL_SAM_MUTACOES:
                    controle_ativo = False

            if controle_auxiliar != 0:
                gene_mutado = controle_auxiliar
                controle_auxiliar = 0

            if gene_mutado >= (Ln+ni): #Garante que o gene selecionado é uma saída
                #print("MUTAÇÃO TIPO SAIDA")
                ultimo_elemento = ni + Ln - 1 #Último elemento possivel que a saída pode assumir
                primeiro_elemento = ultimo_elemento - (lb * nr) + 1 #Primeiro valor possivel que a saída pode assumir
                elementos_portas = ultimo_elemento - primeiro_elemento + 1 #Quantidade de valores existentes entre o primeiro e último possiveis valores
                qtd_elementos = elementos_portas + ni - 1 #Determina a quantidade de valores distintos que a porta pode assumir como entrada. O -1 tem como função apenas possibilitar o uso de randint(0, qtd_elementos)
                entrada_ou_porta = r.randint(0, qtd_elementos) #Dá a mesma chance para todos os possiveis inputs
                if entrada_ou_porta >= ni: #G[Ln+ni+i] representa cada saida, sequencialmente
                    nova_saida = r.randint(primeiro_elemento, ultimo_elemento)
                    while G[gene_mutado] == nova_saida: #Garante que a mutação mudará o gene_mutado para um valor diferente do inicial
                        nova_saida = r.randint(primeiro_elemento, ultimo_elemento)
                    G[gene_mutado] = nova_saida
                else:
                    nova_saida = r.randint(0, ni-1)
                    while G[gene_mutado] == nova_saida: #Garante que a mutação mudará o gene_mutado para um valor diferente do inicial
                        nova_saida = r.randint(0, ni-1)
                    G[gene_mutado] = nova_saida    
            else:
                colunaatual = int((gene_mutado - ni)/nr) + 1 #Determina a coluna na qual o gene selecionado está
                alelo_mutado = r.randint(0, max_entradas) #Determina qual será o alelo a ser mutado

        
                if alelo_mutado == max_entradas: #Significa que a mutação ocorrerá no tipo da porta
                    #print("MUTAÇÃO TIPO PORTA") 
                    porta_logica = r.randint(0, (len(FT)-1)) #Determina qual será a nova porta
                    while G[gene_mutado][alelo_mutado] == FT[porta_logica]: #Garante que a mutação mudará o gene_mutado para um valor diferente do inicial
                        porta_logica = r.randint(0, (len(FT)-1))
                    G[gene_mutado][alelo_mutado] = FT[porta_logica] #Atribui a nova porta ao gene
                else:
                    #print("MUTAÇÃO TIPO INPUT")
                    if colunaatual == 1: #Neste caso as portas lógicas só recebem inputs
                        entrada = r.randint(0, (ni-1))
                        while G[gene_mutado][alelo_mutado] == entrada:#Garante que a mutação mudará o gene_mutado para um valor diferente do inicial
                            entrada = r.randint(0, (ni-1))
                        G[gene_mutado][alelo_mutado] = entrada
    
                        
                    if colunaatual - lb < 1 and colunaatual != 1: #Neste caso as portas lógicas recebem inputs e nós       
                        valorpossivel = (nr * (colunaatual-2)) + (nr-1) + ni
                        sorteado = r.randint(0, valorpossivel)
                        while G[gene_mutado][alelo_mutado] == sorteado:#Garante que a mutação mudará o gene_mutado para um valor diferente do inicial
                            sorteado = r.randint(0, valorpossivel)
                        G[gene_mutado][alelo_mutado] = sorteado
    
                
                    if colunaatual - lb >= 1: #Neste caso as portas logicas recebem somente nós
                        primeiro_elemento = nr * (colunaatual-lb-1) + ni # O fator + ni serve para deslocar os elementos para frente, contando a quantidade de inputs.
                        ultimo_elemento = (nr * (colunaatual-2)) + (nr-1) + ni 
                        elementos_portas = ultimo_elemento - primeiro_elemento + 1 #Determina quantas portas possíveis existem
                        qtd_elementos = elementos_portas + ni - 1 #Determina a quantidade de valores distintos que a porta pode assumir como entrada. O -1 tem como função apenas possibilitar o uso de randint(0, qtd_elementos)
                        entrada_ou_porta = r.randint(0, qtd_elementos) #Dá a mesma chance para todos os possiveis inputs
                        if entrada_ou_porta >= ni:
                            novo_valor_mutacao = r.randint(primeiro_elemento, ultimo_elemento)
                            while G[gene_mutado][alelo_mutado] == novo_valor_mutacao:#Garante que a mutação mudará o gene_mutado para um valor diferente do inicial
                                novo_valor_mutacao = r.randint(primeiro_elemento, ultimo_elemento)
                            G[gene_mutado][alelo_mutado] = novo_valor_mutacao
                        else:
                            novo_valor_mutacao = r.randint(0, ni-1)
                            while G[gene_mutado][alelo_mutado] == novo_valor_mutacao:#Garante que a mutação mudará o gene_mutado para um valor diferente do inicial
                                novo_valor_mutacao = r.randint(0, ni-1)
                            G[gene_mutado][alelo_mutado] = novo_valor_mutacao

        SAM_ativo(posicao)
        GENS_EVOL[posicao] = copy.deepcopy(G) #Passa o genótipo mutado para a matriz de genótipos

        G = copy.deepcopy(GENS_EVOL[0])


def mutacao_SAM_CORRETO_analisamutacao(posicao):
    ativo = False
    arquivo_evolucao = open('evolucao.txt', 'a')
    #arquivo_evolucao.write("\n MUTAÇÃO TIPO SAM")
    todos_ativos = []
    for i in range(len(MEUARRAY[0])):
        for j in range(len(MEUARRAY[0][i])):
            if MEUARRAY[0][i][j] == "X":
                todos_ativos.append(j)
    ATIVO_MOM.clear()
    ATIVO_MOM.append([])
    ATIVO_MOM[0] = copy.deepcopy(MEUARRAY[0][0])
    for i in range(len(ATIVO_MOM[0])):
        if ATIVO_MOM[0][i] == "X":
            ATIVO_MOM[0][i] = "-"
    for i in todos_ativos:
        ATIVO_MOM[0][i] = "X"
    controle_ativo = True
    quantidade_de_mutacoes = 0
    controle_auxiliar = 0 # Esta variável serve para o index da lista ATIVO_MOM[g][gene_mutado] não ser violado
        #FICA FAZENDO MUTAÇÃO
    for g in range(1): # Se for range(no), fará mutação em ao menos UM nó ativo para CADA saida, se for range(1), mudará somente UM gene ativo de todo o genótipo 
        qtd_mutacao = r.randint(1, ug) #Determina quantos nós serão mutados, dentro do intervalo recomendado pela literatura
        while controle_ativo == True: #Realiza "qtd_mutacao" de mutações NESTE descendente
            G = copy.deepcopy(GENS_EVOL[0]) #Busca o pai original de volta (sempre alocado em GENS_EVOL[0])
            gene_mutado = r.randint(ni, (ni+no+Ln-1)) #O gene que será mutado pode receber qualquer valor maior que o último espaço ocupado pela entrada, isto é da posição ni (já que começa por 0) até a posição da última saida
            #arquivo_evolucao.write("\n Gene mutado: " + str(gene_mutado))
            if gene_mutado > ni+Ln-1:
                #arquivo_evolucao.write("\n GENE ATIVO")
                GLOBAL_MUTACAO_SAM_ATIVO[0] += 1
            else:
                if ATIVO_MOM[g][gene_mutado] != "X":
                    #arquivo_evolucao.write("\n GENE INATIVO")
                    GLOBAL_MUTACAO_SAM_INATIVO[0] += 1
                else:
                    #arquivo_evolucao.write("\n GENE ATIVO")
                    ativo = True
                    GLOBAL_MUTACAO_SAM_ATIVO[0] += 1
                    

                
            if gene_mutado > ni+Ln-1:
                quantidade_de_mutacoes += 1
                if quantidade_de_mutacoes == GLOBAL_SAM_MUTACOES:
                    controle_ativo = False
                controle_auxiliar = gene_mutado
                gene_mutado = 0

            if ATIVO_MOM[g][gene_mutado] == "X" and controle_ativo == True:

                if gene_mutado > ni+Ln-1:
                    quantidade_de_mutacoes += 1
                    if quantidade_de_mutacoes == GLOBAL_SAM_MUTACOES:
                        controle_ativo = False
                    controle_auxiliar = gene_mutado
                    gene_mutado = 0
                quantidade_de_mutacoes += 1
                if quantidade_de_mutacoes == GLOBAL_SAM_MUTACOES:
                    controle_ativo = False
                    


            if controle_auxiliar != 0:
                gene_mutado = controle_auxiliar
                controle_auxiliar = 0

            if gene_mutado >= (Ln+ni): #Garante que o gene selecionado é uma saída
                #arquivo_evolucao.write("\n MUTAÇÃO TIPO SAIDA")
                GLOBAL_MUTACAO_SAM_SAIDA[0] += 1
                ultimo_elemento = ni + Ln - 1 #Último elemento possivel que a saída pode assumir
                primeiro_elemento = ultimo_elemento - (lb * nr) + 1 #Primeiro valor possivel que a saída pode assumir
                elementos_portas = ultimo_elemento - primeiro_elemento + 1 #Quantidade de valores existentes entre o primeiro e último possiveis valores
                qtd_elementos = elementos_portas + ni - 1 #Determina a quantidade de valores distintos que a porta pode assumir como entrada. O -1 tem como função apenas possibilitar o uso de randint(0, qtd_elementos)
                entrada_ou_porta = r.randint(0, qtd_elementos) #Dá a mesma chance para todos os possiveis inputs
                if entrada_ou_porta >= ni: #G[Ln+ni+i] representa cada saida, sequencialmente
                    nova_saida = r.randint(primeiro_elemento, ultimo_elemento)
                    while G[gene_mutado] == nova_saida: #Garante que a mutação mudará o gene_mutado para um valor diferente do inicial
                        nova_saida = r.randint(primeiro_elemento, ultimo_elemento)
                    G[gene_mutado] = nova_saida
                else:
                    nova_saida = r.randint(0, ni-1)
                    while G[gene_mutado] == nova_saida: #Garante que a mutação mudará o gene_mutado para um valor diferente do inicial
                        nova_saida = r.randint(0, ni-1)
                    G[gene_mutado] = nova_saida    
            else:
                colunaatual = int((gene_mutado - ni)/nr) + 1 #Determina a coluna na qual o gene selecionado está
                alelo_mutado = r.randint(0, max_entradas) #Determina qual será o alelo a ser mutado

        
                if alelo_mutado == max_entradas: #Significa que a mutação ocorrerá no tipo da porta
                    #arquivo_evolucao.write("\n MUTAÇÃO TIPO PORTA")
                    if ativo == True:
                        porta_antes = G[gene_mutado][alelo_mutado]
                        #arquivo_evolucao.write("\n PORTA " + str(porta_antes))
                    GLOBAL_MUTACAO_SAM_PORTA[0] += 1
                    porta_logica = r.randint(0, (len(FT)-1)) #Determina qual será a nova porta
                    while G[gene_mutado][alelo_mutado] == FT[porta_logica]: #Garante que a mutação mudará o gene_mutado para um valor diferente do inicial
                        porta_logica = r.randint(0, (len(FT)-1))
                    G[gene_mutado][alelo_mutado] = FT[porta_logica] #Atribui a nova porta ao gene
                    if ativo == True:
                        #arquivo_evolucao.write("\n PORTA DEPOIS: " + str(FT[porta_logica]))
                        porta_depois = FT[porta_logica]
                        preenche_matriz_portas(porta_antes, porta_depois)
                        #arquivo_evolucao.write("\n MATRIZ: " + str(GATE_INFAC))
                        #IND_MUT_SAM[posicao-1].clear()
                        IND_MUT_SAM[posicao-1][0][0] = copy.deepcopy(porta_antes)
                        IND_MUT_SAM[posicao-1][1][0] = copy.deepcopy(porta_depois)
                        #arquivo_evolucao.write("\n IND MUT SAM " + str(IND_MUT_SAM))
                else:
                    #arquivo_evolucao.write("\n MUTAÇÃO TIPO INPUT")
                    GLOBAL_MUTACAO_SAM_INPUT[0] += 1
                    if colunaatual == 1: #Neste caso as portas lógicas só recebem inputs
                        entrada = r.randint(0, (ni-1))
                        while G[gene_mutado][alelo_mutado] == entrada:#Garante que a mutação mudará o gene_mutado para um valor diferente do inicial
                            entrada = r.randint(0, (ni-1))
                        G[gene_mutado][alelo_mutado] = entrada
    
                        
                    if colunaatual - lb < 1 and colunaatual != 1: #Neste caso as portas lógicas recebem inputs e nós       
                        valorpossivel = (nr * (colunaatual-2)) + (nr-1) + ni
                        sorteado = r.randint(0, valorpossivel)
                        while G[gene_mutado][alelo_mutado] == sorteado:#Garante que a mutação mudará o gene_mutado para um valor diferente do inicial
                            sorteado = r.randint(0, valorpossivel)
                        G[gene_mutado][alelo_mutado] = sorteado
    
                
                    if colunaatual - lb >= 1: #Neste caso as portas logicas recebem somente nós
                        primeiro_elemento = nr * (colunaatual-lb-1) + ni # O fator + ni serve para deslocar os elementos para frente, contando a quantidade de inputs.
                        ultimo_elemento = (nr * (colunaatual-2)) + (nr-1) + ni 
                        elementos_portas = ultimo_elemento - primeiro_elemento + 1 #Determina quantas portas possíveis existem
                        qtd_elementos = elementos_portas + ni - 1 #Determina a quantidade de valores distintos que a porta pode assumir como entrada. O -1 tem como função apenas possibilitar o uso de randint(0, qtd_elementos)
                        entrada_ou_porta = r.randint(0, qtd_elementos) #Dá a mesma chance para todos os possiveis inputs
                        if entrada_ou_porta >= ni:
                            novo_valor_mutacao = r.randint(primeiro_elemento, ultimo_elemento)
                            while G[gene_mutado][alelo_mutado] == novo_valor_mutacao:#Garante que a mutação mudará o gene_mutado para um valor diferente do inicial
                                novo_valor_mutacao = r.randint(primeiro_elemento, ultimo_elemento)
                            G[gene_mutado][alelo_mutado] = novo_valor_mutacao
                        else:
                            novo_valor_mutacao = r.randint(0, ni-1)
                            while G[gene_mutado][alelo_mutado] == novo_valor_mutacao:#Garante que a mutação mudará o gene_mutado para um valor diferente do inicial
                                novo_valor_mutacao = r.randint(0, ni-1)
                            G[gene_mutado][alelo_mutado] = novo_valor_mutacao

        SAM_ativo(posicao)
        GENS_EVOL[posicao] = copy.deepcopy(G) #Passa o genótipo mutado para a matriz de genótipos

        G = copy.deepcopy(GENS_EVOL[0])

        arquivo_evolucao.close()


def mutacao_SAM_CORRETO(posicao):
    ativo = False
    arquivo_evolucao = open('evolucao.txt', 'a')
    #arquivo_evolucao.write("\n MUTAÇÃO TIPO SAM")
    todos_ativos = []
    for i in range(len(MEUARRAY[0])):
        for j in range(len(MEUARRAY[0][i])):
            if MEUARRAY[0][i][j] == "X":
                todos_ativos.append(j)
    ATIVO_MOM.clear()
    ATIVO_MOM.append([])
    ATIVO_MOM[0] = copy.deepcopy(MEUARRAY[0][0])
    for i in range(len(ATIVO_MOM[0])):
        if ATIVO_MOM[0][i] == "X":
            ATIVO_MOM[0][i] = "-"
    for i in todos_ativos:
        ATIVO_MOM[0][i] = "X"
    controle_ativo = True
    quantidade_de_mutacoes = 0
    controle_auxiliar = 0 # Esta variável serve para o index da lista ATIVO_MOM[g][gene_mutado] não ser violado
        #FICA FAZENDO MUTAÇÃO
    for g in range(1): # Se for range(no), fará mutação em ao menos UM nó ativo para CADA saida, se for range(1), mudará somente UM gene ativo de todo o genótipo 
        qtd_mutacao = r.randint(1, ug) #Determina quantos nós serão mutados, dentro do intervalo recomendado pela literatura
        while controle_ativo == True: #Realiza "qtd_mutacao" de mutações NESTE descendente
            G = copy.deepcopy(GENS_EVOL[0]) #Busca o pai original de volta (sempre alocado em GENS_EVOL[0])
            gene_mutado = r.randint(ni, (ni+no+Ln-1)) #O gene que será mutado pode receber qualquer valor maior que o último espaço ocupado pela entrada, isto é da posição ni (já que começa por 0) até a posição da última saida
            #arquivo_evolucao.write("\n Gene mutado: " + str(gene_mutado))
            if gene_mutado > ni+Ln-1:
                #arquivo_evolucao.write("\n GENE ATIVO")
                GLOBAL_MUTACAO_SAM_ATIVO[0] += 1
            else:
                if ATIVO_MOM[g][gene_mutado] != "X":
                    #arquivo_evolucao.write("\n GENE INATIVO")
                    GLOBAL_MUTACAO_SAM_INATIVO[0] += 1
                else:
                    #arquivo_evolucao.write("\n GENE ATIVO")
                    ativo = True
                    GLOBAL_MUTACAO_SAM_ATIVO[0] += 1
                    

                
            if gene_mutado > ni+Ln-1:
                quantidade_de_mutacoes += 1
                if quantidade_de_mutacoes == GLOBAL_SAM_MUTACOES:
                    controle_ativo = False
                controle_auxiliar = gene_mutado
                gene_mutado = 0

            if ATIVO_MOM[g][gene_mutado] == "X" and controle_ativo == True:

                if gene_mutado > ni+Ln-1:
                    quantidade_de_mutacoes += 1
                    if quantidade_de_mutacoes == GLOBAL_SAM_MUTACOES:
                        controle_ativo = False
                    controle_auxiliar = gene_mutado
                    gene_mutado = 0
                quantidade_de_mutacoes += 1
                if quantidade_de_mutacoes == GLOBAL_SAM_MUTACOES:
                    controle_ativo = False
                    


            if controle_auxiliar != 0:
                gene_mutado = controle_auxiliar
                controle_auxiliar = 0

            if gene_mutado >= (Ln+ni): #Garante que o gene selecionado é uma saída
                #arquivo_evolucao.write("\n MUTAÇÃO TIPO SAIDA")
                GLOBAL_MUTACAO_SAM_SAIDA[0] += 1
                ultimo_elemento = ni + Ln - 1 #Último elemento possivel que a saída pode assumir
                primeiro_elemento = ultimo_elemento - (lb * nr) + 1 #Primeiro valor possivel que a saída pode assumir
                elementos_portas = ultimo_elemento - primeiro_elemento + 1 #Quantidade de valores existentes entre o primeiro e último possiveis valores
                qtd_elementos = elementos_portas + ni - 1 #Determina a quantidade de valores distintos que a porta pode assumir como entrada. O -1 tem como função apenas possibilitar o uso de randint(0, qtd_elementos)
                entrada_ou_porta = r.randint(0, qtd_elementos) #Dá a mesma chance para todos os possiveis inputs
                if entrada_ou_porta >= ni: #G[Ln+ni+i] representa cada saida, sequencialmente
                    nova_saida = r.randint(primeiro_elemento, ultimo_elemento)
                    while G[gene_mutado] == nova_saida: #Garante que a mutação mudará o gene_mutado para um valor diferente do inicial
                        nova_saida = r.randint(primeiro_elemento, ultimo_elemento)
                    G[gene_mutado] = nova_saida
                else:
                    nova_saida = r.randint(0, ni-1)
                    while G[gene_mutado] == nova_saida: #Garante que a mutação mudará o gene_mutado para um valor diferente do inicial
                        nova_saida = r.randint(0, ni-1)
                    G[gene_mutado] = nova_saida    
            else:
                colunaatual = int((gene_mutado - ni)/nr) + 1 #Determina a coluna na qual o gene selecionado está
                alelo_mutado = r.randint(0, max_entradas) #Determina qual será o alelo a ser mutado

        
                if alelo_mutado == max_entradas: #Significa que a mutação ocorrerá no tipo da porta
                    #arquivo_evolucao.write("\n MUTAÇÃO TIPO PORTA")
                    if ativo == True:
                        porta_antes = G[gene_mutado][alelo_mutado]
                        #arquivo_evolucao.write("\n PORTA " + str(porta_antes))
                    GLOBAL_MUTACAO_SAM_PORTA[0] += 1
                    porta_logica = r.randint(0, (len(FT)-1)) #Determina qual será a nova porta
                    while G[gene_mutado][alelo_mutado] == FT[porta_logica]: #Garante que a mutação mudará o gene_mutado para um valor diferente do inicial
                        porta_logica = r.randint(0, (len(FT)-1))
                    G[gene_mutado][alelo_mutado] = FT[porta_logica] #Atribui a nova porta ao gene
                    if ativo == True:
                        #arquivo_evolucao.write("\n PORTA DEPOIS: " + str(FT[porta_logica]))
                        porta_depois = FT[porta_logica]
                        preenche_matriz_portas(porta_antes, porta_depois)
                        #arquivo_evolucao.write("\n MATRIZ: " + str(GATE_INFAC))
                        #IND_MUT_SAM[posicao-1].clear()
                        #IND_MUT_SAM[posicao-1][0][0] = copy.deepcopy(porta_antes)
                        #IND_MUT_SAM[posicao-1][1][0] = copy.deepcopy(porta_depois)
                        #arquivo_evolucao.write("\n IND MUT SAM " + str(IND_MUT_SAM))
                else:
                    #arquivo_evolucao.write("\n MUTAÇÃO TIPO INPUT")
                    GLOBAL_MUTACAO_SAM_INPUT[0] += 1
                    if colunaatual == 1: #Neste caso as portas lógicas só recebem inputs
                        entrada = r.randint(0, (ni-1))
                        while G[gene_mutado][alelo_mutado] == entrada:#Garante que a mutação mudará o gene_mutado para um valor diferente do inicial
                            entrada = r.randint(0, (ni-1))
                        G[gene_mutado][alelo_mutado] = entrada
    
                        
                    if colunaatual - lb < 1 and colunaatual != 1: #Neste caso as portas lógicas recebem inputs e nós       
                        valorpossivel = (nr * (colunaatual-2)) + (nr-1) + ni
                        sorteado = r.randint(0, valorpossivel)
                        while G[gene_mutado][alelo_mutado] == sorteado:#Garante que a mutação mudará o gene_mutado para um valor diferente do inicial
                            sorteado = r.randint(0, valorpossivel)
                        G[gene_mutado][alelo_mutado] = sorteado
    
                
                    if colunaatual - lb >= 1: #Neste caso as portas logicas recebem somente nós
                        primeiro_elemento = nr * (colunaatual-lb-1) + ni # O fator + ni serve para deslocar os elementos para frente, contando a quantidade de inputs.
                        ultimo_elemento = (nr * (colunaatual-2)) + (nr-1) + ni 
                        elementos_portas = ultimo_elemento - primeiro_elemento + 1 #Determina quantas portas possíveis existem
                        qtd_elementos = elementos_portas + ni - 1 #Determina a quantidade de valores distintos que a porta pode assumir como entrada. O -1 tem como função apenas possibilitar o uso de randint(0, qtd_elementos)
                        entrada_ou_porta = r.randint(0, qtd_elementos) #Dá a mesma chance para todos os possiveis inputs
                        if entrada_ou_porta >= ni:
                            novo_valor_mutacao = r.randint(primeiro_elemento, ultimo_elemento)
                            while G[gene_mutado][alelo_mutado] == novo_valor_mutacao:#Garante que a mutação mudará o gene_mutado para um valor diferente do inicial
                                novo_valor_mutacao = r.randint(primeiro_elemento, ultimo_elemento)
                            G[gene_mutado][alelo_mutado] = novo_valor_mutacao
                        else:
                            novo_valor_mutacao = r.randint(0, ni-1)
                            while G[gene_mutado][alelo_mutado] == novo_valor_mutacao:#Garante que a mutação mudará o gene_mutado para um valor diferente do inicial
                                novo_valor_mutacao = r.randint(0, ni-1)
                            G[gene_mutado][alelo_mutado] = novo_valor_mutacao

        SAM_ativo(posicao)
        GENS_EVOL[posicao] = copy.deepcopy(G) #Passa o genótipo mutado para a matriz de genótipos

        G = copy.deepcopy(GENS_EVOL[0])

        arquivo_evolucao.close()







def mutacao_SAM_CORRETO_mux(posicao):
    ativo = False
    arquivo_evolucao = open('evolucao.txt', 'a')
    #arquivo_evolucao.write("\n MUTAÇÃO TIPO SAM")
    todos_ativos = []
    for i in range(len(MEUARRAY[0])):
        for j in range(len(MEUARRAY[0][i])):
            if MEUARRAY[0][i][j] == "X":
                todos_ativos.append(j)
    ATIVO_MOM.clear()
    ATIVO_MOM.append([])
    ATIVO_MOM[0] = copy.deepcopy(MEUARRAY[0][0])
    for i in range(len(ATIVO_MOM[0])):
        if ATIVO_MOM[0][i] == "X":
            ATIVO_MOM[0][i] = "-"
    for i in todos_ativos:
        ATIVO_MOM[0][i] = "X"
    controle_ativo = True
    quantidade_de_mutacoes = 0
    controle_auxiliar = 0 # Esta variável serve para o index da lista ATIVO_MOM[g][gene_mutado] não ser violado
        #FICA FAZENDO MUTAÇÃO
    for g in range(1): # Se for range(no), fará mutação em ao menos UM nó ativo para CADA saida, se for range(1), mudará somente UM gene ativo de todo o genótipo 
        qtd_mutacao = r.randint(1, ug) #Determina quantos nós serão mutados, dentro do intervalo recomendado pela literatura
        while controle_ativo == True: #Realiza "qtd_mutacao" de mutações NESTE descendente
            G = copy.deepcopy(GENS_EVOL[0]) #Busca o pai original de volta (sempre alocado em GENS_EVOL[0])
            gene_mutado = r.randint(ni, (ni+no+Ln-1)) #O gene que será mutado pode receber qualquer valor maior que o último espaço ocupado pela entrada, isto é da posição ni (já que começa por 0) até a posição da última saida
            #arquivo_evolucao.write("\n Gene mutado: " + str(gene_mutado))
            if gene_mutado > ni+Ln-1:
                #arquivo_evolucao.write("\n GENE ATIVO")
                GLOBAL_MUTACAO_SAM_ATIVO[0] += 1
            else:
                if ATIVO_MOM[g][gene_mutado] != "X":
                    #arquivo_evolucao.write("\n GENE INATIVO")
                    GLOBAL_MUTACAO_SAM_INATIVO[0] += 1
                else:
                    #arquivo_evolucao.write("\n GENE ATIVO")
                    ativo = True
                    GLOBAL_MUTACAO_SAM_ATIVO[0] += 1
                    

                
            if gene_mutado > ni+Ln-1:
                quantidade_de_mutacoes += 1
                if quantidade_de_mutacoes == GLOBAL_SAM_MUTACOES:
                    controle_ativo = False
                controle_auxiliar = gene_mutado
                gene_mutado = 0

            if ATIVO_MOM[g][gene_mutado] == "X" and controle_ativo == True:

                if gene_mutado > ni+Ln-1:
                    quantidade_de_mutacoes += 1
                    if quantidade_de_mutacoes == GLOBAL_SAM_MUTACOES:
                        controle_ativo = False
                    controle_auxiliar = gene_mutado
                    gene_mutado = 0
                quantidade_de_mutacoes += 1
                if quantidade_de_mutacoes == GLOBAL_SAM_MUTACOES:
                    controle_ativo = False
                    


            if controle_auxiliar != 0:
                gene_mutado = controle_auxiliar
                controle_auxiliar = 0

            if gene_mutado >= (Ln+ni): #Garante que o gene selecionado é uma saída
                #arquivo_evolucao.write("\n MUTAÇÃO TIPO SAIDA")
                GLOBAL_MUTACAO_SAM_SAIDA[0] += 1
                ultimo_elemento = ni + Ln - 1 #Último elemento possivel que a saída pode assumir
                primeiro_elemento = ultimo_elemento - (lb * nr) + 1 #Primeiro valor possivel que a saída pode assumir
                elementos_portas = ultimo_elemento - primeiro_elemento + 1 #Quantidade de valores existentes entre o primeiro e último possiveis valores
                qtd_elementos = elementos_portas + ni - 1 #Determina a quantidade de valores distintos que a porta pode assumir como entrada. O -1 tem como função apenas possibilitar o uso de randint(0, qtd_elementos)
                entrada_ou_porta = r.randint(0, qtd_elementos) #Dá a mesma chance para todos os possiveis inputs
                if entrada_ou_porta >= ni: #G[Ln+ni+i] representa cada saida, sequencialmente
                    nova_saida = r.randint(primeiro_elemento, ultimo_elemento)
                    while G[gene_mutado] == nova_saida: #Garante que a mutação mudará o gene_mutado para um valor diferente do inicial
                        nova_saida = r.randint(primeiro_elemento, ultimo_elemento)
                    G[gene_mutado] = nova_saida
                else:
                    nova_saida = r.randint(0, ni-1)
                    while G[gene_mutado] == nova_saida: #Garante que a mutação mudará o gene_mutado para um valor diferente do inicial
                        nova_saida = r.randint(0, ni-1)
                    G[gene_mutado] = nova_saida    
            else:
                colunaatual = int((gene_mutado - ni)/nr) + 1 #Determina a coluna na qual o gene selecionado está
                alelo_mutado = r.randint(0, 3) #Determina qual será o alelo a ser mutado
                if alelo_mutado == 3 and G[gene_mutado][2] != 200:
                    if quantidade_de_mutacoes != 0:
                        quantidade_de_mutacoes = quantidade_de_mutacoes - 1

        
                if alelo_mutado == max_entradas: #Significa que a mutação ocorrerá no tipo da porta
                    #arquivo_evolucao.write("\n MUTAÇÃO TIPO PORTA")
                    if ativo == True:
                        porta_antes = G[gene_mutado][alelo_mutado]
                        #arquivo_evolucao.write("\n PORTA " + str(porta_antes))
                    GLOBAL_MUTACAO_SAM_PORTA[0] += 1
                    porta_logica = r.randint(0, (len(FT)-1)) #Determina qual será a nova porta
                    while G[gene_mutado][alelo_mutado] == FT[porta_logica]: #Garante que a mutação mudará o gene_mutado para um valor diferente do inicial
                        porta_logica = r.randint(0, (len(FT)-1))
                    G[gene_mutado][alelo_mutado] = FT[porta_logica] #Atribui a nova porta ao gene
                    if ativo == True:
                        #arquivo_evolucao.write("\n PORTA DEPOIS: " + str(FT[porta_logica]))
                        porta_depois = FT[porta_logica]
                        preenche_matriz_portas(porta_antes, porta_depois)
                        #arquivo_evolucao.write("\n MATRIZ: " + str(GATE_INFAC))
                        #IND_MUT_SAM[posicao-1].clear()
                        #IND_MUT_SAM[posicao-1][0][0] = copy.deepcopy(porta_antes)
                        #IND_MUT_SAM[posicao-1][1][0] = copy.deepcopy(porta_depois)
                        #arquivo_evolucao.write("\n IND MUT SAM " + str(IND_MUT_SAM))
                else:
                    #arquivo_evolucao.write("\n MUTAÇÃO TIPO INPUT")
                    GLOBAL_MUTACAO_SAM_INPUT[0] += 1
                    if colunaatual == 1: #Neste caso as portas lógicas só recebem inputs
                        entrada = r.randint(0, (ni-1))
                        while G[gene_mutado][alelo_mutado] == entrada:#Garante que a mutação mudará o gene_mutado para um valor diferente do inicial
                            entrada = r.randint(0, (ni-1))
                        G[gene_mutado][alelo_mutado] = entrada
    
                        
                    if colunaatual - lb < 1 and colunaatual != 1: #Neste caso as portas lógicas recebem inputs e nós       
                        valorpossivel = (nr * (colunaatual-2)) + (nr-1) + ni
                        sorteado = r.randint(0, valorpossivel)
                        while G[gene_mutado][alelo_mutado] == sorteado:#Garante que a mutação mudará o gene_mutado para um valor diferente do inicial
                            sorteado = r.randint(0, valorpossivel)
                        G[gene_mutado][alelo_mutado] = sorteado
    
                
                    if colunaatual - lb >= 1: #Neste caso as portas logicas recebem somente nós
                        primeiro_elemento = nr * (colunaatual-lb-1) + ni # O fator + ni serve para deslocar os elementos para frente, contando a quantidade de inputs.
                        ultimo_elemento = (nr * (colunaatual-2)) + (nr-1) + ni 
                        elementos_portas = ultimo_elemento - primeiro_elemento + 1 #Determina quantas portas possíveis existem
                        qtd_elementos = elementos_portas + ni - 1 #Determina a quantidade de valores distintos que a porta pode assumir como entrada. O -1 tem como função apenas possibilitar o uso de randint(0, qtd_elementos)
                        entrada_ou_porta = r.randint(0, qtd_elementos) #Dá a mesma chance para todos os possiveis inputs
                        if entrada_ou_porta >= ni:
                            novo_valor_mutacao = r.randint(primeiro_elemento, ultimo_elemento)
                            while G[gene_mutado][alelo_mutado] == novo_valor_mutacao:#Garante que a mutação mudará o gene_mutado para um valor diferente do inicial
                                novo_valor_mutacao = r.randint(primeiro_elemento, ultimo_elemento)
                            G[gene_mutado][alelo_mutado] = novo_valor_mutacao
                        else:
                            novo_valor_mutacao = r.randint(0, ni-1)
                            while G[gene_mutado][alelo_mutado] == novo_valor_mutacao:#Garante que a mutação mudará o gene_mutado para um valor diferente do inicial
                                novo_valor_mutacao = r.randint(0, ni-1)
                            G[gene_mutado][alelo_mutado] = novo_valor_mutacao

        SAM_ativo_mux(posicao)
        GENS_EVOL[posicao] = copy.deepcopy(G) #Passa o genótipo mutado para a matriz de genótipos

        G = copy.deepcopy(GENS_EVOL[0])

        arquivo_evolucao.close()



def mutacao_GAM_CORRETO(posicao):
    ativo = False
    arquivo_evolucao = open('evolucao.txt', 'a')
    #arquivo_evolucao.write("\n MUTAÇÃO TIPO GAM")
    valor_pior_saida = min(FITNESS_EE[0])
    for i in range(len(FITNESS_EE[0])):
        if FITNESS_EE[0][i] == valor_pior_saida:
            pior_saida = i
    
    
    todos_ativos = []
    for i in range(len(MEUARRAY[0][pior_saida])):
        if MEUARRAY[0][pior_saida][i] == "X":
            todos_ativos.append(i)
            
    ATIVO_MOM.clear()
    ATIVO_MOM.append([])
    ATIVO_MOM[0] = copy.deepcopy(MEUARRAY[0][0])
    for i in range(len(ATIVO_MOM[0])):
        if ATIVO_MOM[0][i] == "X":
            ATIVO_MOM[0][i] = "-"
    for i in todos_ativos:
        ATIVO_MOM[0][i] = "X"
        
    controle_ativo = True
    quantidade_de_mutacoes = 0
    controle_auxiliar = 0 # Esta variável serve para o index da lista ATIVO_MOM[g][gene_mutado] não ser violado
        #FICA FAZENDO MUTAÇÃO
    for g in range(1): # Se for range(no), fará mutação em ao menos UM nó ativo para CADA saida, se for range(1), mudará somente UM gene ativo de todo o genótipo 
        qtd_mutacao = r.randint(1, ug) #Determina quantos nós serão mutados, dentro do intervalo recomendado pela literatura
        while controle_ativo == True: #Realiza "qtd_mutacao" de mutações NESTE descendente
            G = copy.deepcopy(GENS_EVOL[0]) #Busca o pai original de volta (sempre alocado em GENS_EVOL[0])
            gene_mutado = r.randint(ni, (ni+no+Ln-1)) #O gene que será mutado pode receber qualquer valor maior que o último espaço ocupado pela entrada, isto é da posição ni (já que começa por 0) até a posição da última saida

            #arquivo_evolucao.write("\n Gene mutado: " + str(gene_mutado))
            if gene_mutado > ni+Ln-1:
                #arquivo_evolucao.write("\n GENE ATIVO")
                GLOBAL_MUTACAO_GAM_ATIVO[0] += 1
            else:
                if ATIVO_MOM[g][gene_mutado] != "X":
                    #arquivo_evolucao.write("\n GENE INATIVO")
                    GLOBAL_MUTACAO_GAM_INATIVO[0] += 1
                else:
                    #arquivo_evolucao.write("\n GENE ATIVO")
                    ativo = True
                    GLOBAL_MUTACAO_GAM_ATIVO[0] += 1

            if gene_mutado > ni+Ln-1:
                quantidade_de_mutacoes += 1
                if quantidade_de_mutacoes == GLOBAL_SAM_MUTACOES:
                    controle_ativo = False
                controle_auxiliar = gene_mutado
                gene_mutado = 0
            if ATIVO_MOM[g][gene_mutado] == "X" and controle_ativo == True:
                if gene_mutado > ni+Ln-1:
                    quantidade_de_mutacoes += 1
                    if quantidade_de_mutacoes == GLOBAL_SAM_MUTACOES:
                        controle_ativo = False
                    controle_auxiliar = gene_mutado
                    gene_mutado = 0
                quantidade_de_mutacoes += 1
                if quantidade_de_mutacoes == GLOBAL_SAM_MUTACOES:
                    controle_ativo = False

            if controle_auxiliar != 0:
                gene_mutado = controle_auxiliar
                controle_auxiliar = 0

            if gene_mutado >= (Ln+ni): #Garante que o gene selecionado é uma saída
                #arquivo_evolucao.write("\n MUTAÇÃO TIPO SAIDA")
                GLOBAL_MUTACAO_GAM_SAIDA[0] += 1
                ultimo_elemento = ni + Ln - 1 #Último elemento possivel que a saída pode assumir
                primeiro_elemento = ultimo_elemento - (lb * nr) + 1 #Primeiro valor possivel que a saída pode assumir
                elementos_portas = ultimo_elemento - primeiro_elemento + 1 #Quantidade de valores existentes entre o primeiro e último possiveis valores
                qtd_elementos = elementos_portas + ni - 1 #Determina a quantidade de valores distintos que a porta pode assumir como entrada. O -1 tem como função apenas possibilitar o uso de randint(0, qtd_elementos)
                entrada_ou_porta = r.randint(0, qtd_elementos) #Dá a mesma chance para todos os possiveis inputs
                if entrada_ou_porta >= ni: #G[Ln+ni+i] representa cada saida, sequencialmente
                    nova_saida = r.randint(primeiro_elemento, ultimo_elemento)
                    while G[gene_mutado] == nova_saida: #Garante que a mutação mudará o gene_mutado para um valor diferente do inicial
                        nova_saida = r.randint(primeiro_elemento, ultimo_elemento)
                    G[gene_mutado] = nova_saida
                else:
                    nova_saida = r.randint(0, ni-1)
                    while G[gene_mutado] == nova_saida: #Garante que a mutação mudará o gene_mutado para um valor diferente do inicial
                        nova_saida = r.randint(0, ni-1)
                    G[gene_mutado] = nova_saida    
            else:
                colunaatual = int((gene_mutado - ni)/nr) + 1 #Determina a coluna na qual o gene selecionado está
                alelo_mutado = r.randint(0, max_entradas) #Determina qual será o alelo a ser mutado

        
                if alelo_mutado == max_entradas: #Significa que a mutação ocorrerá no tipo da porta
                    #arquivo_evolucao.write("\n MUTAÇÃO TIPO PORTA")
                    if ativo == True:
                        porta_antes = G[gene_mutado][alelo_mutado]
                        #arquivo_evolucao.write("\n PORTA " + str(porta_antes))
                    GLOBAL_MUTACAO_GAM_PORTA[0] += 1
                    porta_logica = r.randint(0, (len(FT)-1)) #Determina qual será a nova porta
                    while G[gene_mutado][alelo_mutado] == FT[porta_logica]: #Garante que a mutação mudará o gene_mutado para um valor diferente do inicial
                        porta_logica = r.randint(0, (len(FT)-1))
                    G[gene_mutado][alelo_mutado] = FT[porta_logica] #Atribui a nova porta ao gene
                    if ativo == True:
                        #arquivo_evolucao.write("\n PORTA DEPOIS: " + str(FT[porta_logica]))
                        porta_depois = FT[porta_logica]
                        preenche_matriz_portas(porta_antes, porta_depois)
                        #arquivo_evolucao.write("\n MATRIZ: " + str(GATE_INFAC))
                        IND_MUT_GAM[posicao-3][0][0] = copy.deepcopy(porta_antes)
                        IND_MUT_GAM[posicao-3][1][0] = copy.deepcopy(porta_depois)
                        #arquivo_evolucao.write("\n IND MUT GAM " + str(IND_MUT_GAM))
                else:
                    #arquivo_evolucao.write("\n MUTAÇÃO TIPO INPUT")
                    GLOBAL_MUTACAO_GAM_INPUT[0] += 1
                    if colunaatual == 1: #Neste caso as portas lógicas só recebem inputs
                        entrada = r.randint(0, (ni-1))
                        while G[gene_mutado][alelo_mutado] == entrada:#Garante que a mutação mudará o gene_mutado para um valor diferente do inicial
                            entrada = r.randint(0, (ni-1))
                        G[gene_mutado][alelo_mutado] = entrada
    
                        
                    if colunaatual - lb < 1 and colunaatual != 1: #Neste caso as portas lógicas recebem inputs e nós       
                        valorpossivel = (nr * (colunaatual-2)) + (nr-1) + ni
                        sorteado = r.randint(0, valorpossivel)
                        while G[gene_mutado][alelo_mutado] == sorteado:#Garante que a mutação mudará o gene_mutado para um valor diferente do inicial
                            sorteado = r.randint(0, valorpossivel)
                        G[gene_mutado][alelo_mutado] = sorteado
    
                
                    if colunaatual - lb >= 1: #Neste caso as portas logicas recebem somente nós
                        primeiro_elemento = nr * (colunaatual-lb-1) + ni # O fator + ni serve para deslocar os elementos para frente, contando a quantidade de inputs.
                        ultimo_elemento = (nr * (colunaatual-2)) + (nr-1) + ni 
                        elementos_portas = ultimo_elemento - primeiro_elemento + 1 #Determina quantas portas possíveis existem
                        qtd_elementos = elementos_portas + ni - 1 #Determina a quantidade de valores distintos que a porta pode assumir como entrada. O -1 tem como função apenas possibilitar o uso de randint(0, qtd_elementos)
                        entrada_ou_porta = r.randint(0, qtd_elementos) #Dá a mesma chance para todos os possiveis inputs
                        if entrada_ou_porta >= ni:
                            novo_valor_mutacao = r.randint(primeiro_elemento, ultimo_elemento)
                            while G[gene_mutado][alelo_mutado] == novo_valor_mutacao:#Garante que a mutação mudará o gene_mutado para um valor diferente do inicial
                                novo_valor_mutacao = r.randint(primeiro_elemento, ultimo_elemento)
                            G[gene_mutado][alelo_mutado] = novo_valor_mutacao
                        else:
                            novo_valor_mutacao = r.randint(0, ni-1)
                            while G[gene_mutado][alelo_mutado] == novo_valor_mutacao:#Garante que a mutação mudará o gene_mutado para um valor diferente do inicial
                                novo_valor_mutacao = r.randint(0, ni-1)
                            G[gene_mutado][alelo_mutado] = novo_valor_mutacao

        SAM_ativo(posicao)
        GENS_EVOL[posicao] = copy.deepcopy(G) #Passa o genótipo mutado para a matriz de genótipos

        G = copy.deepcopy(GENS_EVOL[0])

        arquivo_evolucao.close()



def mutacao_GAM_CORRETO_mux(posicao):
    ativo = False
    arquivo_evolucao = open('evolucao.txt', 'a')
    #arquivo_evolucao.write("\n MUTAÇÃO TIPO GAM")
    valor_pior_saida = min(FITNESS_EE[0])
    for i in range(len(FITNESS_EE[0])):
        if FITNESS_EE[0][i] == valor_pior_saida:
            pior_saida = i
    
    
    todos_ativos = []
    for i in range(len(MEUARRAY[0][pior_saida])):
        if MEUARRAY[0][pior_saida][i] == "X":
            todos_ativos.append(i)
            
    ATIVO_MOM.clear()
    ATIVO_MOM.append([])
    ATIVO_MOM[0] = copy.deepcopy(MEUARRAY[0][0])
    for i in range(len(ATIVO_MOM[0])):
        if ATIVO_MOM[0][i] == "X":
            ATIVO_MOM[0][i] = "-"
    for i in todos_ativos:
        ATIVO_MOM[0][i] = "X"
        
    controle_ativo = True
    quantidade_de_mutacoes = 0
    controle_auxiliar = 0 # Esta variável serve para o index da lista ATIVO_MOM[g][gene_mutado] não ser violado
        #FICA FAZENDO MUTAÇÃO
    for g in range(1): # Se for range(no), fará mutação em ao menos UM nó ativo para CADA saida, se for range(1), mudará somente UM gene ativo de todo o genótipo 
        qtd_mutacao = r.randint(1, ug) #Determina quantos nós serão mutados, dentro do intervalo recomendado pela literatura
        while controle_ativo == True: #Realiza "qtd_mutacao" de mutações NESTE descendente
            G = copy.deepcopy(GENS_EVOL[0]) #Busca o pai original de volta (sempre alocado em GENS_EVOL[0])
            gene_mutado = r.randint(ni, (ni+no+Ln-1)) #O gene que será mutado pode receber qualquer valor maior que o último espaço ocupado pela entrada, isto é da posição ni (já que começa por 0) até a posição da última saida

            #arquivo_evolucao.write("\n Gene mutado: " + str(gene_mutado))
            if gene_mutado > ni+Ln-1:
                #arquivo_evolucao.write("\n GENE ATIVO")
                GLOBAL_MUTACAO_GAM_ATIVO[0] += 1
            else:
                if ATIVO_MOM[g][gene_mutado] != "X":
                    #arquivo_evolucao.write("\n GENE INATIVO")
                    GLOBAL_MUTACAO_GAM_INATIVO[0] += 1
                else:
                    #arquivo_evolucao.write("\n GENE ATIVO")
                    ativo = True
                    GLOBAL_MUTACAO_GAM_ATIVO[0] += 1

            if gene_mutado > ni+Ln-1:
                quantidade_de_mutacoes += 1
                if quantidade_de_mutacoes == GLOBAL_SAM_MUTACOES:
                    controle_ativo = False
                controle_auxiliar = gene_mutado
                gene_mutado = 0
            if ATIVO_MOM[g][gene_mutado] == "X" and controle_ativo == True:
                if gene_mutado > ni+Ln-1:
                    quantidade_de_mutacoes += 1
                    if quantidade_de_mutacoes == GLOBAL_SAM_MUTACOES:
                        controle_ativo = False
                    controle_auxiliar = gene_mutado
                    gene_mutado = 0
                quantidade_de_mutacoes += 1
                if quantidade_de_mutacoes == GLOBAL_SAM_MUTACOES:
                    controle_ativo = False

            if controle_auxiliar != 0:
                gene_mutado = controle_auxiliar
                controle_auxiliar = 0

            if gene_mutado >= (Ln+ni): #Garante que o gene selecionado é uma saída
                #arquivo_evolucao.write("\n MUTAÇÃO TIPO SAIDA")
                GLOBAL_MUTACAO_GAM_SAIDA[0] += 1
                ultimo_elemento = ni + Ln - 1 #Último elemento possivel que a saída pode assumir
                primeiro_elemento = ultimo_elemento - (lb * nr) + 1 #Primeiro valor possivel que a saída pode assumir
                elementos_portas = ultimo_elemento - primeiro_elemento + 1 #Quantidade de valores existentes entre o primeiro e último possiveis valores
                qtd_elementos = elementos_portas + ni - 1 #Determina a quantidade de valores distintos que a porta pode assumir como entrada. O -1 tem como função apenas possibilitar o uso de randint(0, qtd_elementos)
                entrada_ou_porta = r.randint(0, qtd_elementos) #Dá a mesma chance para todos os possiveis inputs
                if entrada_ou_porta >= ni: #G[Ln+ni+i] representa cada saida, sequencialmente
                    nova_saida = r.randint(primeiro_elemento, ultimo_elemento)
                    while G[gene_mutado] == nova_saida: #Garante que a mutação mudará o gene_mutado para um valor diferente do inicial
                        nova_saida = r.randint(primeiro_elemento, ultimo_elemento)
                    G[gene_mutado] = nova_saida
                else:
                    nova_saida = r.randint(0, ni-1)
                    while G[gene_mutado] == nova_saida: #Garante que a mutação mudará o gene_mutado para um valor diferente do inicial
                        nova_saida = r.randint(0, ni-1)
                    G[gene_mutado] = nova_saida    
            else:
                colunaatual = int((gene_mutado - ni)/nr) + 1 #Determina a coluna na qual o gene selecionado está
                alelo_mutado = r.randint(0, 3) #Determina qual será o alelo a ser mutado
                if alelo_mutado == 3 and G[gene_mutado][2] != 200:
                    if quantidade_de_mutacoes != 0:
                        quantidade_de_mutacoes = quantidade_de_mutacoes - 1                

        
                if alelo_mutado == max_entradas: #Significa que a mutação ocorrerá no tipo da porta
                    #arquivo_evolucao.write("\n MUTAÇÃO TIPO PORTA")
                    if ativo == True:
                        porta_antes = G[gene_mutado][alelo_mutado]
                        #arquivo_evolucao.write("\n PORTA " + str(porta_antes))
                    GLOBAL_MUTACAO_GAM_PORTA[0] += 1
                    porta_logica = r.randint(0, (len(FT)-1)) #Determina qual será a nova porta
                    while G[gene_mutado][alelo_mutado] == FT[porta_logica]: #Garante que a mutação mudará o gene_mutado para um valor diferente do inicial
                        porta_logica = r.randint(0, (len(FT)-1))
                    G[gene_mutado][alelo_mutado] = FT[porta_logica] #Atribui a nova porta ao gene
                    if ativo == True:
                        #arquivo_evolucao.write("\n PORTA DEPOIS: " + str(FT[porta_logica]))
                        porta_depois = FT[porta_logica]
                        preenche_matriz_portas(porta_antes, porta_depois)
                        #arquivo_evolucao.write("\n MATRIZ: " + str(GATE_INFAC))
                        IND_MUT_GAM[posicao-3][0][0] = copy.deepcopy(porta_antes)
                        IND_MUT_GAM[posicao-3][1][0] = copy.deepcopy(porta_depois)
                        #arquivo_evolucao.write("\n IND MUT GAM " + str(IND_MUT_GAM))
                else:
                    #arquivo_evolucao.write("\n MUTAÇÃO TIPO INPUT")
                    GLOBAL_MUTACAO_GAM_INPUT[0] += 1
                    if colunaatual == 1: #Neste caso as portas lógicas só recebem inputs
                        entrada = r.randint(0, (ni-1))
                        while G[gene_mutado][alelo_mutado] == entrada:#Garante que a mutação mudará o gene_mutado para um valor diferente do inicial
                            entrada = r.randint(0, (ni-1))
                        G[gene_mutado][alelo_mutado] = entrada
    
                        
                    if colunaatual - lb < 1 and colunaatual != 1: #Neste caso as portas lógicas recebem inputs e nós       
                        valorpossivel = (nr * (colunaatual-2)) + (nr-1) + ni
                        sorteado = r.randint(0, valorpossivel)
                        while G[gene_mutado][alelo_mutado] == sorteado:#Garante que a mutação mudará o gene_mutado para um valor diferente do inicial
                            sorteado = r.randint(0, valorpossivel)
                        G[gene_mutado][alelo_mutado] = sorteado
    
                
                    if colunaatual - lb >= 1: #Neste caso as portas logicas recebem somente nós
                        primeiro_elemento = nr * (colunaatual-lb-1) + ni # O fator + ni serve para deslocar os elementos para frente, contando a quantidade de inputs.
                        ultimo_elemento = (nr * (colunaatual-2)) + (nr-1) + ni 
                        elementos_portas = ultimo_elemento - primeiro_elemento + 1 #Determina quantas portas possíveis existem
                        qtd_elementos = elementos_portas + ni - 1 #Determina a quantidade de valores distintos que a porta pode assumir como entrada. O -1 tem como função apenas possibilitar o uso de randint(0, qtd_elementos)
                        entrada_ou_porta = r.randint(0, qtd_elementos) #Dá a mesma chance para todos os possiveis inputs
                        if entrada_ou_porta >= ni:
                            novo_valor_mutacao = r.randint(primeiro_elemento, ultimo_elemento)
                            while G[gene_mutado][alelo_mutado] == novo_valor_mutacao:#Garante que a mutação mudará o gene_mutado para um valor diferente do inicial
                                novo_valor_mutacao = r.randint(primeiro_elemento, ultimo_elemento)
                            G[gene_mutado][alelo_mutado] = novo_valor_mutacao
                        else:
                            novo_valor_mutacao = r.randint(0, ni-1)
                            while G[gene_mutado][alelo_mutado] == novo_valor_mutacao:#Garante que a mutação mudará o gene_mutado para um valor diferente do inicial
                                novo_valor_mutacao = r.randint(0, ni-1)
                            G[gene_mutado][alelo_mutado] = novo_valor_mutacao

        SAM_ativo_mux(posicao)
        GENS_EVOL[posicao] = copy.deepcopy(G) #Passa o genótipo mutado para a matriz de genótipos

        G = copy.deepcopy(GENS_EVOL[0])

        arquivo_evolucao.close()



def monta_tabela(posicao): #Monta a tabela verdade e quantifica a fitness do individuo
    auxiliar = []
    qtd_portas = 0
    for i in range(no):
        for j in range(len(MEUARRAY[posicao][i])):
            if MEUARRAY[posicao][i][j] == "X":

                if j < ni:
                    #print("É UMA ENTRADA")
                    TABELA_V[j] = copy.deepcopy(INPUTS[j])
                else:
                    #print("NÃO É UMA ENTRADA")
                    entradaA = GENS_EVOL[posicao][j][0]
                    entradaB = GENS_EVOL[posicao][j][1]
                    funcao = GENS_EVOL[posicao][j][2]
                    if funcao == 100:
                        for w in range(len(TABELA_V[entradaA])):
                            auxiliar.append((TABELA_V[entradaA][w]) and (TABELA_V[entradaB][w]))
                        TABELA_V[j] = copy.deepcopy(auxiliar)
                        auxiliar = []
                        qtd_portas = qtd_portas + 1
                    if funcao == 110:
                        for w in range(len(TABELA_V[entradaA])):
                            auxiliar.append((TABELA_V[entradaA][w]) or (TABELA_V[entradaB][w]))
                        TABELA_V[j] = copy.deepcopy(auxiliar)
                        auxiliar = []
                        qtd_portas = qtd_portas + 1
                    if funcao == 130:
                        for w in range(len(TABELA_V[entradaA])):
                            auxiliar.append((((not(TABELA_V[entradaA][w])) and (TABELA_V[entradaB][w])) or ((not(TABELA_V[entradaB][w])) and (TABELA_V[entradaA][w]))))
                        TABELA_V[j] = copy.deepcopy(auxiliar)
                        auxiliar = []
                        qtd_portas = qtd_portas + 1
                    if funcao == 150:
                        for w in range(len(TABELA_V[entradaA])):
                            auxiliar.append(not((TABELA_V[entradaA][w]) and (TABELA_V[entradaB][w])))
                        TABELA_V[j] = copy.deepcopy(auxiliar)
                        auxiliar = []
                        qtd_portas = qtd_portas + 1
                    if funcao == 160:
                        for w in range(len(TABELA_V[entradaA])):
                            auxiliar.append(not((TABELA_V[entradaA][w]) or (TABELA_V[entradaB][w])))
                        TABELA_V[j] = copy.deepcopy(auxiliar)
                        auxiliar = []
                        qtd_portas = qtd_portas + 1
                    if funcao == 800:
                        for w in range(len(TABELA_V[entradaA])):
                            auxiliar.append(not(TABELA_V[entradaA][w]))
                        TABELA_V[j] = copy.deepcopy(auxiliar)
                        auxiliar = []
                        qtd_portas = qtd_portas + 1
                    if funcao == 900:
                        for w in range(len(TABELA_V[entradaA])):
                            auxiliar.append(TABELA_V[entradaA][w])
                        TABELA_V[j] = copy.deepcopy(auxiliar)
                        auxiliar = []
                    if funcao == 980:
                        for w in range(len(TABELA_V[entradaA])):
                            auxiliar.append(0)
                        TABELA_V[j] = copy.deepcopy(auxiliar)
                        auxiliar = []
                    if funcao == 990:
                        for w in range(len(TABELA_V[entradaA])):
                            auxiliar.append(1)
                        TABELA_V[j] = copy.deepcopy(auxiliar)
                        auxiliar = []
                    

        saida_ckt = GENS_EVOL[posicao][Ln+ni+i] #Determina a saida atual do circuito, que está sendo processada
        tabela_saida = TABELA_V[saida_ckt]
        if len(TABELA_V[saida_ckt]) == 0:
            print("TABELA VAZIA")
        fitness_atual = 0
                                
        for s in range(len(OUTPUTS[i])):
            if OUTPUTS[i][s] == TABELA_V[saida_ckt][s]:
                #print("OUTPUT IGUAL")
                fitness_atual = fitness_atual + 1

        FITNESS_EE[posicao][i] = copy.deepcopy(fitness_atual)
        PORTAS_EE[posicao][i] = copy.deepcopy(qtd_portas)
        
        if fitness_atual == 15:
            for s in range(len(OUTPUTS[i])):
                if OUTPUTS[i][s] == TABELA_V[saida_ckt][s]:
                    variavel_tg = 0
                else:
                    arquivo_evolucao = open("evolucao.txt", "a")
                    arquivo_evolucao.write("\n Bit errado: " + str(s) + " cujo valor deveria ser: " + str(OUTPUTS[i][s]))
                    arquivo_evolucao.close()
                
        TABELA_V.clear()
        formato_tabela_verdade()


def cria_TABELA_CONTROLE(posicao):
    auxiliar = []
    qtd_portas = 0
    for i in range(no):
        for j in range(len(MEUARRAY[posicao][i])):
            if MEUARRAY[posicao][i][j] == "X":

                if j < ni:
                    #print("É UMA ENTRADA")
                    TABELA_V[j] = copy.deepcopy(INPUTS[j])
                else:
                    #print("NÃO É UMA ENTRADA")
                    entradaA = GENS_EVOL[posicao][j][0]
                    entradaB = GENS_EVOL[posicao][j][1]
                    funcao = GENS_EVOL[posicao][j][2]
                    controle = GENS_EVOL[posicao][j][3]



                    if funcao == 200:
                        for w in range(len(TABELA_V[entradaA])):
                            if TABELA_V[controle][w] == 0:
                                auxiliar.append(TABELA_V[entradaA][w])
                            else:
                                auxiliar.append(TABELA_V[entradaB][w])
                        TABELA_V[j] = copy.deepcopy(auxiliar)
                        auxiliar = []
                        
                    if funcao == 100:
                        for w in range(len(TABELA_V[entradaA])):
                            auxiliar.append((TABELA_V[entradaA][w]) and (TABELA_V[entradaB][w]))
                        TABELA_V[j] = copy.deepcopy(auxiliar)
                        auxiliar = []
                        qtd_portas = qtd_portas + 1
                    if funcao == 110:
                        for w in range(len(TABELA_V[entradaA])):
                            auxiliar.append((TABELA_V[entradaA][w]) or (TABELA_V[entradaB][w]))
                        TABELA_V[j] = copy.deepcopy(auxiliar)
                        auxiliar = []
                        qtd_portas = qtd_portas + 1
                    if funcao == 130:
                        for w in range(len(TABELA_V[entradaA])):
                            auxiliar.append((((not(TABELA_V[entradaA][w])) and (TABELA_V[entradaB][w])) or ((not(TABELA_V[entradaB][w])) and (TABELA_V[entradaA][w]))))
                        TABELA_V[j] = copy.deepcopy(auxiliar)
                        auxiliar = []
                        qtd_portas = qtd_portas + 1
                    if funcao == 150:
                        for w in range(len(TABELA_V[entradaA])):
                            auxiliar.append(not((TABELA_V[entradaA][w]) and (TABELA_V[entradaB][w])))
                        TABELA_V[j] = copy.deepcopy(auxiliar)
                        auxiliar = []
                        qtd_portas = qtd_portas + 1
                    if funcao == 160:
                        for w in range(len(TABELA_V[entradaA])):
                            auxiliar.append(not((TABELA_V[entradaA][w]) or (TABELA_V[entradaB][w])))
                        TABELA_V[j] = copy.deepcopy(auxiliar)
                        auxiliar = []
                        qtd_portas = qtd_portas + 1
                    if funcao == 800:
                        for w in range(len(TABELA_V[entradaA])):
                            auxiliar.append(not(TABELA_V[entradaA][w]))
                        TABELA_V[j] = copy.deepcopy(auxiliar)
                        auxiliar = []
                        qtd_portas = qtd_portas + 1
                    if funcao == 900:
                        for w in range(len(TABELA_V[entradaA])):
                            auxiliar.append(TABELA_V[entradaA][w])
                        TABELA_V[j] = copy.deepcopy(auxiliar)
                        auxiliar = []
                    if funcao == 980:
                        for w in range(len(TABELA_V[entradaA])):
                            auxiliar.append(0)
                        TABELA_V[j] = copy.deepcopy(auxiliar)
                        auxiliar = []
                    if funcao == 990:
                        for w in range(len(TABELA_V[entradaA])):
                            auxiliar.append(1)
                        TABELA_V[j] = copy.deepcopy(auxiliar)
                        auxiliar = []
                    

        saida_ckt = GENS_EVOL[posicao][Ln+ni+i] #Determina a saida atual do circuito, que está sendo processada
        tabela_saida = TABELA_V[saida_ckt]
        if len(TABELA_V[saida_ckt]) == 0:
            print("TABELA VAZIA")
        fitness_atual = 0
        qtd_comuns = 0

        if type(GENS_EVOL[posicao][saida_ckt]) != int:
            porta_usada = GENS_EVOL[posicao][saida_ckt][2]
            if porta_usada == 800 or porta_usada == 900 or porta_usada == 200:
                sub_circuito1 = GENS_EVOL[posicao][saida_ckt][0]
                sub_circuito2 = GENS_EVOL[posicao][saida_ckt][0]
            else:
                sub_circuito1 = GENS_EVOL[posicao][saida_ckt][0]
                sub_circuito2 = GENS_EVOL[posicao][saida_ckt][1]
        else:
            sub_circuito1 = GENS_EVOL[posicao][saida_ckt]
            sub_circuito2 = GENS_EVOL[posicao][saida_ckt]

        for s in range(len(OUTPUTS[i])):
            if OUTPUTS[i][s] == TABELA_V[sub_circuito1][s] or OUTPUTS[i][s] == TABELA_V[sub_circuito2][s]:
                fitness_atual = fitness_atual + 1
        for s in range(len(TABELA_V[sub_circuito1])):
            if TABELA_V[sub_circuito1][s] == TABELA_V[sub_circuito2][s]:
                qtd_comuns = qtd_comuns + 1
        tabela_controle = []
        for s in range(len(OUTPUTS[i])):
            if OUTPUTS[i][s] == TABELA_V[sub_circuito1][s] and OUTPUTS[i][s] == TABELA_V[sub_circuito2][s]:
                tabela_controle.append(9)
            elif OUTPUTS[i][s] == TABELA_V[sub_circuito1][s]:
                tabela_controle.append(0)
            elif OUTPUTS[i][s] == TABELA_V[sub_circuito2][s]:
                tabela_controle.append(1)
                
        OUTPUTS_CONTROLE[i] = copy.deepcopy(tabela_controle)
                
        
        
        #for s in range(len(OUTPUTS[i])):
        #    if OUTPUTS[i][s] == TABELA_V[saida_ckt][s]:
        #        #print("OUTPUT IGUAL")
        #        fitness_atual = fitness_atual + 1

        FITNESS_EE[posicao][i] = copy.deepcopy(fitness_atual)
        PORTAS_EE[posicao][i] = copy.deepcopy(qtd_portas)
        COMUNS_EE[posicao][i] = copy.deepcopy(qtd_comuns)
        
        if fitness_atual == 15:
            for s in range(len(OUTPUTS[i])):
                if OUTPUTS[i][s] == TABELA_V[saida_ckt][s]:
                    variavel_tg = 0
                else:
                    arquivo_evolucao = open("evolucao.txt", "a")
                    arquivo_evolucao.write("\n Bit errado: " + str(s) + " cujo valor deveria ser: " + str(OUTPUTS[i][s]))
                    arquivo_evolucao.close()
                
        TABELA_V.clear()
        formato_tabela_verdade()
    



def monta_tabela_mux_porta(posicao): #Monta a tabela verdade e quantifica a fitness do individuo
    auxiliar = []
    qtd_portas = 0
    for i in range(no):
        for j in range(len(MEUARRAY[posicao][i])):
            if MEUARRAY[posicao][i][j] == "X":

                if j < ni:
                    #print("É UMA ENTRADA")
                    TABELA_V[j] = copy.deepcopy(INPUTS[j])
                else:
                    #print("NÃO É UMA ENTRADA")
                    entradaA = GENS_EVOL[posicao][j][0]
                    entradaB = GENS_EVOL[posicao][j][1]
                    funcao = GENS_EVOL[posicao][j][2]
                    controle = GENS_EVOL[posicao][j][3]



                    if funcao == 200:
                        for w in range(len(TABELA_V[entradaA])):
                            if TABELA_V[controle][w] == 0:
                                auxiliar.append(TABELA_V[entradaA][w])
                            else:
                                auxiliar.append(TABELA_V[entradaB][w])
                        TABELA_V[j] = copy.deepcopy(auxiliar)
                        auxiliar = []
                        
                    if funcao == 100:
                        for w in range(len(TABELA_V[entradaA])):
                            auxiliar.append((TABELA_V[entradaA][w]) and (TABELA_V[entradaB][w]))
                        TABELA_V[j] = copy.deepcopy(auxiliar)
                        auxiliar = []
                        qtd_portas = qtd_portas + 1
                    if funcao == 110:
                        for w in range(len(TABELA_V[entradaA])):
                            auxiliar.append((TABELA_V[entradaA][w]) or (TABELA_V[entradaB][w]))
                        TABELA_V[j] = copy.deepcopy(auxiliar)
                        auxiliar = []
                        qtd_portas = qtd_portas + 1
                    if funcao == 130:
                        for w in range(len(TABELA_V[entradaA])):
                            auxiliar.append((((not(TABELA_V[entradaA][w])) and (TABELA_V[entradaB][w])) or ((not(TABELA_V[entradaB][w])) and (TABELA_V[entradaA][w]))))
                        TABELA_V[j] = copy.deepcopy(auxiliar)
                        auxiliar = []
                        qtd_portas = qtd_portas + 1
                    if funcao == 150:
                        for w in range(len(TABELA_V[entradaA])):
                            auxiliar.append(not((TABELA_V[entradaA][w]) and (TABELA_V[entradaB][w])))
                        TABELA_V[j] = copy.deepcopy(auxiliar)
                        auxiliar = []
                        qtd_portas = qtd_portas + 1
                    if funcao == 160:
                        for w in range(len(TABELA_V[entradaA])):
                            auxiliar.append(not((TABELA_V[entradaA][w]) or (TABELA_V[entradaB][w])))
                        TABELA_V[j] = copy.deepcopy(auxiliar)
                        auxiliar = []
                        qtd_portas = qtd_portas + 1
                    if funcao == 800:
                        for w in range(len(TABELA_V[entradaA])):
                            auxiliar.append(not(TABELA_V[entradaA][w]))
                        TABELA_V[j] = copy.deepcopy(auxiliar)
                        auxiliar = []
                        qtd_portas = qtd_portas + 1
                    if funcao == 900:
                        for w in range(len(TABELA_V[entradaA])):
                            auxiliar.append(TABELA_V[entradaA][w])
                        TABELA_V[j] = copy.deepcopy(auxiliar)
                        auxiliar = []
                    if funcao == 980:
                        for w in range(len(TABELA_V[entradaA])):
                            auxiliar.append(0)
                        TABELA_V[j] = copy.deepcopy(auxiliar)
                        auxiliar = []
                    if funcao == 990:
                        for w in range(len(TABELA_V[entradaA])):
                            auxiliar.append(1)
                        TABELA_V[j] = copy.deepcopy(auxiliar)
                        auxiliar = []
                    

        saida_ckt = GENS_EVOL[posicao][Ln+ni+i] #Determina a saida atual do circuito, que está sendo processada
        tabela_saida = TABELA_V[saida_ckt]
        if len(TABELA_V[saida_ckt]) == 0:
            print("TABELA VAZIA")
        fitness_atual = 0
                                
        for s in range(len(OUTPUTS[i])):
            if OUTPUTS[i][s] == TABELA_V[saida_ckt][s]:
                #print("OUTPUT IGUAL")
                fitness_atual = fitness_atual + 1

        FITNESS_EE[posicao][i] = copy.deepcopy(fitness_atual)
        PORTAS_EE[posicao][i] = copy.deepcopy(qtd_portas)
        
        if fitness_atual == 15:
            for s in range(len(OUTPUTS[i])):
                if OUTPUTS[i][s] == TABELA_V[saida_ckt][s]:
                    variavel_tg = 0
                else:
                    arquivo_evolucao = open("evolucao.txt", "a")
                    arquivo_evolucao.write("\n Bit errado: " + str(s) + " cujo valor deveria ser: " + str(OUTPUTS[i][s]))
                    arquivo_evolucao.close()
                
        TABELA_V.clear()
        formato_tabela_verdade()


    
def monta_tabela_mux(posicao): #Monta a tabela verdade e quantifica a fitness do individuo
    auxiliar = []
    qtd_portas = 0
    for i in range(no):
        for j in range(len(MEUARRAY[posicao][i])):
            if MEUARRAY[posicao][i][j] == "X":

                if j < ni:
                    #print("É UMA ENTRADA")
                    TABELA_V[j] = copy.deepcopy(INPUTS[j])
                else:
                    #print("NÃO É UMA ENTRADA")
                    entradaA = GENS_EVOL[posicao][j][0]
                    entradaB = GENS_EVOL[posicao][j][1]
                    funcao = GENS_EVOL[posicao][j][2]
                    controle = GENS_EVOL[posicao][j][3]



                    if funcao == 200:
                        for w in range(len(TABELA_V[entradaA])):
                            if TABELA_V[controle][w] == 0:
                                auxiliar.append(TABELA_V[entradaA][w])
                            else:
                                auxiliar.append(TABELA_V[entradaB][w])
                        TABELA_V[j] = copy.deepcopy(auxiliar)
                        auxiliar = []
                        
                    if funcao == 100:
                        for w in range(len(TABELA_V[entradaA])):
                            auxiliar.append((TABELA_V[entradaA][w]) and (TABELA_V[entradaB][w]))
                        TABELA_V[j] = copy.deepcopy(auxiliar)
                        auxiliar = []
                        qtd_portas = qtd_portas + 1
                    if funcao == 110:
                        for w in range(len(TABELA_V[entradaA])):
                            auxiliar.append((TABELA_V[entradaA][w]) or (TABELA_V[entradaB][w]))
                        TABELA_V[j] = copy.deepcopy(auxiliar)
                        auxiliar = []
                        qtd_portas = qtd_portas + 1
                    if funcao == 130:
                        for w in range(len(TABELA_V[entradaA])):
                            auxiliar.append((((not(TABELA_V[entradaA][w])) and (TABELA_V[entradaB][w])) or ((not(TABELA_V[entradaB][w])) and (TABELA_V[entradaA][w]))))
                        TABELA_V[j] = copy.deepcopy(auxiliar)
                        auxiliar = []
                        qtd_portas = qtd_portas + 1
                    if funcao == 150:
                        for w in range(len(TABELA_V[entradaA])):
                            auxiliar.append(not((TABELA_V[entradaA][w]) and (TABELA_V[entradaB][w])))
                        TABELA_V[j] = copy.deepcopy(auxiliar)
                        auxiliar = []
                        qtd_portas = qtd_portas + 1
                    if funcao == 160:
                        for w in range(len(TABELA_V[entradaA])):
                            auxiliar.append(not((TABELA_V[entradaA][w]) or (TABELA_V[entradaB][w])))
                        TABELA_V[j] = copy.deepcopy(auxiliar)
                        auxiliar = []
                        qtd_portas = qtd_portas + 1
                    if funcao == 800:
                        for w in range(len(TABELA_V[entradaA])):
                            auxiliar.append(not(TABELA_V[entradaA][w]))
                        TABELA_V[j] = copy.deepcopy(auxiliar)
                        auxiliar = []
                        qtd_portas = qtd_portas + 1
                    if funcao == 900:
                        for w in range(len(TABELA_V[entradaA])):
                            auxiliar.append(TABELA_V[entradaA][w])
                        TABELA_V[j] = copy.deepcopy(auxiliar)
                        auxiliar = []
                    if funcao == 980:
                        for w in range(len(TABELA_V[entradaA])):
                            auxiliar.append(0)
                        TABELA_V[j] = copy.deepcopy(auxiliar)
                        auxiliar = []
                    if funcao == 990:
                        for w in range(len(TABELA_V[entradaA])):
                            auxiliar.append(1)
                        TABELA_V[j] = copy.deepcopy(auxiliar)
                        auxiliar = []
                    

        saida_ckt = GENS_EVOL[posicao][Ln+ni+i] #Determina a saida atual do circuito, que está sendo processada
        tabela_saida = TABELA_V[saida_ckt]
        if len(TABELA_V[saida_ckt]) == 0:
            print("TABELA VAZIA")
        fitness_atual = 0
        qtd_comuns = 0

        if type(GENS_EVOL[posicao][saida_ckt]) != int:
            porta_usada = GENS_EVOL[posicao][saida_ckt][2]
            if porta_usada == 800 or porta_usada == 900 or porta_usada == 200:
                sub_circuito1 = GENS_EVOL[posicao][saida_ckt][0]
                sub_circuito2 = GENS_EVOL[posicao][saida_ckt][0]
            else:
                sub_circuito1 = GENS_EVOL[posicao][saida_ckt][0]
                sub_circuito2 = GENS_EVOL[posicao][saida_ckt][1]
        else:
            sub_circuito1 = GENS_EVOL[posicao][saida_ckt]
            sub_circuito2 = GENS_EVOL[posicao][saida_ckt]

        for s in range(len(OUTPUTS[i])):
            if OUTPUTS[i][s] == TABELA_V[sub_circuito1][s] or OUTPUTS[i][s] == TABELA_V[sub_circuito2][s]:
                fitness_atual = fitness_atual + 1
        for s in range(len(TABELA_V[sub_circuito1])):
            if TABELA_V[sub_circuito1][s] == TABELA_V[sub_circuito2][s]:
                qtd_comuns = qtd_comuns + 1
            #if TABELA_V[sub_circuito2][s] == OUTPUTS[i][s]:
            #    qtd_comuns = qtd_comuns + 1
            #else:
            #    if TABELA_V[sub_circuito1][s] == 0:
            #        qtd_comuns = qtd_comuns - 1
            #    if TABELA_V[sub_circuito2][s] == 0:
            #        qtd_comuns = qtd_comuns - 1
                
        #for s in range(len(OUTPUTS[i])):
        #    if OUTPUTS[i][s] == TABELA_V[saida_ckt][s]:
        #        #print("OUTPUT IGUAL")
        #        fitness_atual = fitness_atual + 1

        FITNESS_EE[posicao][i] = copy.deepcopy(fitness_atual)
        PORTAS_EE[posicao][i] = copy.deepcopy(qtd_portas)
        COMUNS_EE[posicao][i] = copy.deepcopy(qtd_comuns)
        
        if fitness_atual == 15:
            for s in range(len(OUTPUTS[i])):
                if OUTPUTS[i][s] == TABELA_V[saida_ckt][s]:
                    variavel_tg = 0
                else:
                    arquivo_evolucao = open("evolucao.txt", "a")
                    arquivo_evolucao.write("\n Bit errado: " + str(s) + " cujo valor deveria ser: " + str(OUTPUTS[i][s]))
                    arquivo_evolucao.close()
                
        TABELA_V.clear()
        formato_tabela_verdade()





def monta_tabela_mux2(posicao): #Monta a tabela verdade e quantifica a fitness do individuo
    auxiliar = []
    qtd_portas = 0
    for i in range(no):
        for j in range(len(MEUARRAY[posicao][i])):
            if MEUARRAY[posicao][i][j] == "X":

                if j < ni:
                    #print("É UMA ENTRADA")
                    TABELA_V[j] = copy.deepcopy(INPUTS[j])
                else:
                    #print("NÃO É UMA ENTRADA")
                    entradaA = GENS_EVOL[posicao][j][0]
                    entradaB = GENS_EVOL[posicao][j][1]
                    funcao = GENS_EVOL[posicao][j][2]
                    controle = GENS_EVOL[posicao][j][3]



                    if funcao == 200:
                        for w in range(len(TABELA_V[entradaA])):
                            if TABELA_V[controle][w] == 0:
                                auxiliar.append(TABELA_V[entradaA][w])
                            else:
                                auxiliar.append(TABELA_V[entradaB][w])
                        TABELA_V[j] = copy.deepcopy(auxiliar)
                        auxiliar = []
                        
                    if funcao == 100:
                        for w in range(len(TABELA_V[entradaA])):
                            auxiliar.append((TABELA_V[entradaA][w]) and (TABELA_V[entradaB][w]))
                        TABELA_V[j] = copy.deepcopy(auxiliar)
                        auxiliar = []
                        qtd_portas = qtd_portas + 1
                    if funcao == 110:
                        for w in range(len(TABELA_V[entradaA])):
                            auxiliar.append((TABELA_V[entradaA][w]) or (TABELA_V[entradaB][w]))
                        TABELA_V[j] = copy.deepcopy(auxiliar)
                        auxiliar = []
                        qtd_portas = qtd_portas + 1
                    if funcao == 130:
                        for w in range(len(TABELA_V[entradaA])):
                            auxiliar.append((((not(TABELA_V[entradaA][w])) and (TABELA_V[entradaB][w])) or ((not(TABELA_V[entradaB][w])) and (TABELA_V[entradaA][w]))))
                        TABELA_V[j] = copy.deepcopy(auxiliar)
                        auxiliar = []
                        qtd_portas = qtd_portas + 1
                    if funcao == 150:
                        for w in range(len(TABELA_V[entradaA])):
                            auxiliar.append(not((TABELA_V[entradaA][w]) and (TABELA_V[entradaB][w])))
                        TABELA_V[j] = copy.deepcopy(auxiliar)
                        auxiliar = []
                        qtd_portas = qtd_portas + 1
                    if funcao == 160:
                        for w in range(len(TABELA_V[entradaA])):
                            auxiliar.append(not((TABELA_V[entradaA][w]) or (TABELA_V[entradaB][w])))
                        TABELA_V[j] = copy.deepcopy(auxiliar)
                        auxiliar = []
                        qtd_portas = qtd_portas + 1
                    if funcao == 800:
                        for w in range(len(TABELA_V[entradaA])):
                            auxiliar.append(not(TABELA_V[entradaA][w]))
                        TABELA_V[j] = copy.deepcopy(auxiliar)
                        auxiliar = []
                        qtd_portas = qtd_portas + 1
                    if funcao == 900:
                        for w in range(len(TABELA_V[entradaA])):
                            auxiliar.append(TABELA_V[entradaA][w])
                        TABELA_V[j] = copy.deepcopy(auxiliar)
                        auxiliar = []
                    if funcao == 980:
                        for w in range(len(TABELA_V[entradaA])):
                            auxiliar.append(0)
                        TABELA_V[j] = copy.deepcopy(auxiliar)
                        auxiliar = []
                    if funcao == 990:
                        for w in range(len(TABELA_V[entradaA])):
                            auxiliar.append(1)
                        TABELA_V[j] = copy.deepcopy(auxiliar)
                        auxiliar = []
                    

        saida_ckt = GENS_EVOL[posicao][Ln+ni+i] #Determina a saida atual do circuito, que está sendo processada
        tabela_saida = TABELA_V[saida_ckt]
        if len(TABELA_V[saida_ckt]) == 0:
            print("TABELA VAZIA")
        fitness_atual = 0


        for s in range(len(OUTPUTS_CONTROLE[i])):
            if OUTPUTS_CONTROLE[i][s] == 9:
                fitness_atual = fitness_atual + 1
            elif OUTPUTS_CONTROLE[i][s] == TABELA_V[saida_ckt][s]:
                fitness_atual += 1


        FITNESS_EE[posicao][i] = copy.deepcopy(fitness_atual)
        PORTAS_EE[posicao][i] = copy.deepcopy(qtd_portas)

        
        if fitness_atual == 15:
            for s in range(len(OUTPUTS[i])):
                if OUTPUTS[i][s] == TABELA_V[saida_ckt][s]:
                    variavel_tg = 0
                else:
                    arquivo_evolucao = open("evolucao.txt", "a")
                    arquivo_evolucao.write("\n Bit errado: " + str(s) + " cujo valor deveria ser: " + str(OUTPUTS[i][s]))
                    arquivo_evolucao.close()
                
        TABELA_V.clear()
        formato_tabela_verdade()


def monta_tabela_MUX(posicao): #Monta a tabela verdade e quantifica a fitness do individuo
    auxiliar = []
    qtd_portas = 0
    for i in range(no):
        for j in range(len(MEUARRAY[posicao][i])):
            if MEUARRAY[posicao][i][j] == "X":

                if j < ni:
                    #print("É UMA ENTRADA")
                    TABELA_V[j] = copy.deepcopy(INPUTS[j])
                else:
                    #print("NÃO É UMA ENTRADA")
                    entradaA = GENS_EVOL[posicao][j][0]
                    entradaB = GENS_EVOL[posicao][j][1]
                    funcao = GENS_EVOL[posicao][j][2]
                    if funcao == 100:
                        for w in range(len(TABELA_V[entradaA])):
                            auxiliar.append((TABELA_V[entradaA][w]) and (TABELA_V[entradaB][w]))
                        TABELA_V[j] = copy.deepcopy(auxiliar)
                        auxiliar = []
                        qtd_portas = qtd_portas + 1
                    if funcao == 110:
                        for w in range(len(TABELA_V[entradaA])):
                            auxiliar.append((TABELA_V[entradaA][w]) or (TABELA_V[entradaB][w]))
                        TABELA_V[j] = copy.deepcopy(auxiliar)
                        auxiliar = []
                        qtd_portas = qtd_portas + 1
                    if funcao == 130:
                        for w in range(len(TABELA_V[entradaA])):
                            auxiliar.append((((not(TABELA_V[entradaA][w])) and (TABELA_V[entradaB][w])) or ((not(TABELA_V[entradaB][w])) and (TABELA_V[entradaA][w]))))
                        TABELA_V[j] = copy.deepcopy(auxiliar)
                        auxiliar = []
                        qtd_portas = qtd_portas + 1
                    if funcao == 150:
                        for w in range(len(TABELA_V[entradaA])):
                            auxiliar.append(not((TABELA_V[entradaA][w]) and (TABELA_V[entradaB][w])))
                        TABELA_V[j] = copy.deepcopy(auxiliar)
                        auxiliar = []
                        qtd_portas = qtd_portas + 1
                    if funcao == 160:
                        for w in range(len(TABELA_V[entradaA])):
                            auxiliar.append(not((TABELA_V[entradaA][w]) or (TABELA_V[entradaB][w])))
                        TABELA_V[j] = copy.deepcopy(auxiliar)
                        auxiliar = []
                        qtd_portas = qtd_portas + 1
                    if funcao == 800:
                        for w in range(len(TABELA_V[entradaA])):
                            auxiliar.append(not(TABELA_V[entradaA][w]))
                        TABELA_V[j] = copy.deepcopy(auxiliar)
                        auxiliar = []
                        qtd_portas = qtd_portas + 1
                    if funcao == 900:
                        for w in range(len(TABELA_V[entradaA])):
                            auxiliar.append(TABELA_V[entradaA][w])
                        TABELA_V[j] = copy.deepcopy(auxiliar)
                        auxiliar = []
                    if funcao == 980:
                        for w in range(len(TABELA_V[entradaA])):
                            auxiliar.append(0)
                        TABELA_V[j] = copy.deepcopy(auxiliar)
                        auxiliar = []
                    if funcao == 990:
                        for w in range(len(TABELA_V[entradaA])):
                            auxiliar.append(1)
                        TABELA_V[j] = copy.deepcopy(auxiliar)
                        auxiliar = []
                    

        saida_ckt = GENS_EVOL[posicao][Ln+ni+i] #Determina a saida atual do circuito, que está sendo processada
        tabela_saida = TABELA_V[saida_ckt]
        if len(TABELA_V[saida_ckt]) == 0:
            print("TABELA VAZIA")
        fitness_atual = 0
        if type(GENS_EVOL[posicao][saida_ckt]) == int:
            sub_circuito1 = GENS_EVOL[posicao][saida_ckt]
            sub_circuito2 = GENS_EVOL[posicao][saida_ckt]
        else:
            if GENS_EVOL[posicao][saida_ckt][2] == 800 or GENS_EVOL[posicao][saida_ckt][2] == 900:
                sub_circuito1 = GENS_EVOL[posicao][saida_ckt][0]
                sub_circuito2 = GENS_EVOL[posicao][saida_ckt][0]
            else:
                sub_circuito1 = GENS_EVOL[posicao][saida_ckt][0]
                sub_circuito2 = GENS_EVOL[posicao][saida_ckt][1]

        TABELA1 = copy.deepcopy(TABELA_V[sub_circuito1])
        TABELA2 = copy.deepcopy(TABELA_V[sub_circuito2])
        #print("1", TABELA1)
        #print("2", TABELA2)
        TABELA_FINAL = []
        for bit in range(len(INPUTS[2])): ## 0(A), 1(B), 2(C), 3(D)
            if INPUTS[2][bit] == 0:
                TABELA_FINAL.append(TABELA_V[sub_circuito1][bit])
            else:
                TABELA_FINAL.append(TABELA_V[sub_circuito2][bit])
                                
        for s in range(len(OUTPUTS[i])):
            if OUTPUTS[i][s] == TABELA_FINAL[s]:#TABELA_V[saida_ckt][s]:
                #print("OUTPUT IGUAL")
                fitness_atual = fitness_atual + 1

        FITNESS_EE[posicao][i] = copy.deepcopy(fitness_atual)
        PORTAS_EE[posicao][i] = copy.deepcopy(qtd_portas)
        
        if fitness_atual == 15:
            for s in range(len(OUTPUTS[i])):
                if OUTPUTS[i][s] == TABELA_V[saida_ckt][s]:
                    variavel_tg = 0
                else:
                    arquivo_evolucao = open("evolucao.txt", "a")
                    arquivo_evolucao.write("\n Bit errado: " + str(s) + " cujo valor deveria ser: " + str(OUTPUTS[i][s]))
                    arquivo_evolucao.close()
                
        TABELA_V.clear()
        formato_tabela_verdade()

def monta_tabela_wires(posicao): #Monta a tabela verdade e quantifica a fitness do individuo
    auxiliar = []
    qtd_portas = 0
    for i in range(no):
        for j in range(len(MEUARRAY[posicao][i])):
            if MEUARRAY[posicao][i][j] == "X":
                if j < ni:
                    #print("É UMA ENTRADA")
                    TABELA_V[j] = copy.deepcopy(INPUTS[j])
                else:
                    #print("NÃO É UMA ENTRADA")
                    entradaA = GENS_EVOL[posicao][j][0]
                    entradaB = GENS_EVOL[posicao][j][1]
                    funcao = GENS_EVOL[posicao][j][2]
                    if funcao == 100:
                        for w in range(len(TABELA_V[entradaA])):
                            auxiliar.append((TABELA_V[entradaA][w]) and (TABELA_V[entradaB][w]))
                        TABELA_V[j] = copy.deepcopy(auxiliar)
                        auxiliar = []
                        qtd_portas = qtd_portas + 1
                    if funcao == 110:
                        for w in range(len(TABELA_V[entradaA])):
                            auxiliar.append((TABELA_V[entradaA][w]) or (TABELA_V[entradaB][w]))
                        TABELA_V[j] = copy.deepcopy(auxiliar)
                        auxiliar = []
                        qtd_portas = qtd_portas + 1
                    if funcao == 130:
                        for w in range(len(TABELA_V[entradaA])):
                            auxiliar.append((((not(TABELA_V[entradaA][w])) and (TABELA_V[entradaB][w])) or ((not(TABELA_V[entradaB][w])) and (TABELA_V[entradaA][w]))))
                        TABELA_V[j] = copy.deepcopy(auxiliar)
                        auxiliar = []
                        qtd_portas = qtd_portas + 1
                    if funcao == 150:
                        for w in range(len(TABELA_V[entradaA])):
                            auxiliar.append(not((TABELA_V[entradaA][w]) and (TABELA_V[entradaB][w])))
                        TABELA_V[j] = copy.deepcopy(auxiliar)
                        auxiliar = []
                        qtd_portas = qtd_portas + 1
                    if funcao == 160:
                        for w in range(len(TABELA_V[entradaA])):
                            auxiliar.append(not((TABELA_V[entradaA][w]) or (TABELA_V[entradaB][w])))
                        TABELA_V[j] = copy.deepcopy(auxiliar)
                        auxiliar = []
                        qtd_portas = qtd_portas + 1
                    if funcao == 800:
                        for w in range(len(TABELA_V[entradaA])):
                            auxiliar.append(not(TABELA_V[entradaA][w]))
                        TABELA_V[j] = copy.deepcopy(auxiliar)
                        auxiliar = []
                        qtd_portas = qtd_portas + 1
                    if funcao == 900:
                        for w in range(len(TABELA_V[entradaA])):
                            auxiliar.append(TABELA_V[entradaA][w])
                        TABELA_V[j] = copy.deepcopy(auxiliar)
                        auxiliar = []
                    if funcao == 980:
                        for w in range(len(TABELA_V[entradaA])):
                            auxiliar.append(0)
                        TABELA_V[j] = copy.deepcopy(auxiliar)
                        auxiliar = []
                    if funcao == 990:
                        for w in range(len(TABELA_V[entradaA])):
                            auxiliar.append(1)
                        TABELA_V[j] = copy.deepcopy(auxiliar)
                        auxiliar = []
                    

        saida_ckt = GENS_EVOL[posicao][Ln+ni+i] #Determina a saida atual do circuito, que está sendo processada
        tabela_saida = TABELA_V[saida_ckt]
        if len(TABELA_V[saida_ckt]) == 0:
            print("TABELA VAZIA")
        fitness_atual = 0
        for s in range(len(OUTPUTS[i])):
            if OUTPUTS[i][s] == TABELA_V[saida_ckt][s]:
                #print("OUTPUT IGUAL")
                fitness_atual = fitness_atual + 1

        if fitness_atual == (no * len(OUTPUTS[0])):
            nos_ativos_agora = []
            nos_ativos_agora.clear()
            for p in range(len(MEUARRAY[posicao])):
                for q in range(len(MEUARRAY[posicao][p])):
                    if MEUARRAY[posicao][p][q] == "X":
                        nos_ativos_agora.append(q)
            nova_lista = []
            nova_lista.clear()
            nova_lista = sorted(set(nos_ativos_agora))

            nos_ativos_saida = []
            nos_ativos_saida.clear()
            for p in range(len(nova_lista)):
                if nova_lista[p] >= ni:
                    nos_ativos_saida.append(nova_lista[p])
            wires = 0
            for p in range(len(nos_ativos_saida)):
                if GENS_EVOL[posicao][nos_ativos_saida[p]][2] == 900:
                    wires = wires + 1
            fitness_atual = fitness_atual + wires
                                
        
        FITNESS_EE[posicao][i] = copy.deepcopy(fitness_atual)
        PORTAS_EE[posicao][i] = copy.deepcopy(qtd_portas)
        TABELA_V.clear()
        formato_tabela_verdade()


def seleciona_mu_pais():
    MU_PAIS.clear()
    INDICE_MU_PAIS.clear()
    individuos_selecionados = []
    indices = np.argsort(FITNESS_GLOBAL)[::-1]
    for i in range(ee_mu_pop):
        individuos_selecionados.append(indices[i])
        INDICE_MU_PAIS.append(indices[i])
        MU_PAIS.append(GENS_EVOL[indices[i]])



def atualiza_pai_SOCONTROLE_MUX(): 
    soma = 0
    fitness_soma = [] # Array que armazena a soma de todas as saídas de cada circuito
    aux = []
    for k in range(ee_lambda + 1):
        fitness_soma.append([])
    for i in range(len(FITNESS_EE)):
        for j in range(len(FITNESS_EE[i])):
            soma = soma + FITNESS_EE[i][j]
        fitness_soma[i] = copy.deepcopy(soma)
        soma = 0
    for s in range(len(fitness_soma)):
        if fitness_soma[s] == max(fitness_soma):
            aux.append(s)
    sorteia = r.randint(0, len(aux)-1)
    GENS_EVOL[0] = copy.deepcopy(GENS_EVOL[aux[sorteia]])
    FITNESS_EE[0] = copy.deepcopy(FITNESS_EE[aux[sorteia]])


    
def atualiza_pai_CGP_PADRAO(): #Analisa somente a fitness dos individuos. Em caso de empate, sorteia um.
    soma = 0
    fitness_soma = [] # Array que armazena a soma de todas as saídas de cada circuito
    aux = []
    for k in range(ee_lambda + 1):
        fitness_soma.append([])
    for i in range(len(FITNESS_EE)):
        for j in range(len(FITNESS_EE[i])):
            soma = soma + FITNESS_EE[i][j]
        fitness_soma[i] = copy.deepcopy(soma)
        soma = 0
    for s in range(len(fitness_soma)):
        if fitness_soma[s] == max(fitness_soma):
            aux.append(s)
    sorteia = r.randint(0, len(aux)-1)


    portas = 0
    portas_soma = []
    aux_portas = []
    for k in range(ee_lambda + 1):
        portas_soma.append([])
    for i in range(len(PORTAS_EE)):
        for j in range(len(PORTAS_EE[i])):
            portas = portas = PORTAS_EE[i][j]
        portas_soma[i] = copy.deepcopy(portas)
        portas = 0
    for s in range(len(portas_soma)):
        if portas_soma[s] == max(portas_soma):
            aux_portas.append(s)
    sorteia_porta = r.randint(0, len(aux_portas)-1)

    if fitness_soma[aux[sorteia]] < (no * len(OUTPUTS[0])):
        caso = 1
    else:
        caso = 2
### MATRIZ REGIÃO INFACTÍVEL
    if fitness_soma[0] < fitness_soma[aux[sorteia]] and fitness_soma[aux[sorteia]] < (no * len(OUTPUTS[0])):
        caso = 1
        for i in range(len(GENS_EVOL[0])):
            if GENS_EVOL[0][i] != GENS_EVOL[aux[sorteia]][i]:
                if i >= ni and i < ni+Ln:
                    if GENS_EVOL[0][i][2] != GENS_EVOL[aux[sorteia]][i][2]:
                        if GENS_EVOL[0][i][2] == 900:
                            if GENS_EVOL[aux[sorteia]][i][2] == 100:
                                MATRIZ_REGIAO_INFACTIVEL[0][1][0] = MATRIZ_REGIAO_INFACTIVEL[0][1][0] + 1
                            if GENS_EVOL[aux[sorteia]][i][2] == 110:
                                MATRIZ_REGIAO_INFACTIVEL[0][2][0] = MATRIZ_REGIAO_INFACTIVEL[0][2][0] + 1
                            if GENS_EVOL[aux[sorteia]][i][2] == 130:
                                MATRIZ_REGIAO_INFACTIVEL[0][3][0] = MATRIZ_REGIAO_INFACTIVEL[0][3][0] + 1
                            if GENS_EVOL[aux[sorteia]][i][2] == 800:
                                MATRIZ_REGIAO_INFACTIVEL[0][4][0] = MATRIZ_REGIAO_INFACTIVEL[0][4][0] + 1
                        if GENS_EVOL[0][i][2] == 100:
                            if GENS_EVOL[aux[sorteia]][i][2] == 900:
                                MATRIZ_REGIAO_INFACTIVEL[1][0][0] = MATRIZ_REGIAO_INFACTIVEL[1][0][0] + 1
                            if GENS_EVOL[aux[sorteia]][i][2] == 110:
                                MATRIZ_REGIAO_INFACTIVEL[1][2][0] = MATRIZ_REGIAO_INFACTIVEL[1][2][0] + 1
                            if GENS_EVOL[aux[sorteia]][i][2] == 130:
                                MATRIZ_REGIAO_INFACTIVEL[1][3][0] = MATRIZ_REGIAO_INFACTIVEL[1][3][0] + 1
                            if GENS_EVOL[aux[sorteia]][i][2] == 800:
                                MATRIZ_REGIAO_INFACTIVEL[1][4][0] = MATRIZ_REGIAO_INFACTIVEL[1][4][0] + 1
                        if GENS_EVOL[0][i][2] == 110:
                            if GENS_EVOL[aux[sorteia]][i][2] == 900:
                                MATRIZ_REGIAO_INFACTIVEL[2][0][0] = MATRIZ_REGIAO_INFACTIVEL[2][0][0] + 1
                            if GENS_EVOL[aux[sorteia]][i][2] == 100:
                                MATRIZ_REGIAO_INFACTIVEL[2][1][0] = MATRIZ_REGIAO_INFACTIVEL[2][1][0] + 1
                            if GENS_EVOL[aux[sorteia]][i][2] == 130:
                                MATRIZ_REGIAO_INFACTIVEL[2][3][0] = MATRIZ_REGIAO_INFACTIVEL[2][3][0] + 1
                            if GENS_EVOL[aux[sorteia]][i][2] == 800:
                                MATRIZ_REGIAO_INFACTIVEL[2][4][0] = MATRIZ_REGIAO_INFACTIVEL[2][4][0] + 1
                        if GENS_EVOL[0][i][2] == 130:
                            if GENS_EVOL[aux[sorteia]][i][2] == 900:
                                MATRIZ_REGIAO_INFACTIVEL[3][0][0] = MATRIZ_REGIAO_INFACTIVEL[3][0][0] + 1
                            if GENS_EVOL[aux[sorteia]][i][2] == 100:
                                MATRIZ_REGIAO_INFACTIVEL[3][1][0] = MATRIZ_REGIAO_INFACTIVEL[3][1][0] + 1
                            if GENS_EVOL[aux[sorteia]][i][2] == 110:
                                MATRIZ_REGIAO_INFACTIVEL[3][2][0] = MATRIZ_REGIAO_INFACTIVEL[3][2][0] + 1
                            if GENS_EVOL[aux[sorteia]][i][2] == 800:
                                MATRIZ_REGIAO_INFACTIVEL[3][4][0] = MATRIZ_REGIAO_INFACTIVEL[3][4][0] + 1
                        if GENS_EVOL[0][i][2] == 800:
                            if GENS_EVOL[aux[sorteia]][i][2] == 900:
                                MATRIZ_REGIAO_INFACTIVEL[4][0][0] = MATRIZ_REGIAO_INFACTIVEL[4][0][0] + 1
                            if GENS_EVOL[aux[sorteia]][i][2] == 100:
                                MATRIZ_REGIAO_INFACTIVEL[4][1][0] = MATRIZ_REGIAO_INFACTIVEL[4][1][0] + 1
                            if GENS_EVOL[aux[sorteia]][i][2] == 110:
                                MATRIZ_REGIAO_INFACTIVEL[4][2][0] = MATRIZ_REGIAO_INFACTIVEL[4][2][0] + 1
                            if GENS_EVOL[aux[sorteia]][i][2] == 130:
                                MATRIZ_REGIAO_INFACTIVEL[4][3][0] = MATRIZ_REGIAO_INFACTIVEL[4][3][0] + 1    

### MATRIZ REGIÃO FACTÍVEL
                               
    if portas_soma[0] > portas_soma[aux_portas[sorteia_porta]] and fitness_soma[aux[sorteia_porta]] >= (no * len(OUTPUTS[0])):
        print("ENTROU NA REGIÃO FACTÍVEL")
        caso = 2
        for i in range(len(GENS_EVOL[0])):
            if GENS_EVOL[0][i] != GENS_EVOL[aux[sorteia_porta]][i]:
                if i >= ni and i < ni+Ln:
                    if GENS_EVOL[0][i][2] != GENS_EVOL[aux[sorteia_porta]][i][2]:
                        if GENS_EVOL[0][i][2] == 900:
                            if GENS_EVOL[aux[sorteia_porta]][i][2] == 100:
                                MATRIZ_REGIAO_FACTIVEL[0][1][0] = MATRIZ_REGIAO_FACTIVEL[0][1][0] + 1
                            if GENS_EVOL[aux[sorteia_porta]][i][2] == 110:
                                MATRIZ_REGIAO_FACTIVEL[0][2][0] = MATRIZ_REGIAO_FACTIVEL[0][2][0] + 1
                            if GENS_EVOL[aux[sorteia_porta]][i][2] == 130:
                                MATRIZ_REGIAO_FACTIVEL[0][3][0] = MATRIZ_REGIAO_FACTIVEL[0][3][0] + 1
                            if GENS_EVOL[aux[sorteia_porta]][i][2] == 800:
                                MATRIZ_REGIAO_FACTIVEL[0][4][0] = MATRIZ_REGIAO_FACTIVEL[0][4][0] + 1
                        if GENS_EVOL[0][i][2] == 100:
                            if GENS_EVOL[aux[sorteia_porta]][i][2] == 900:
                                MATRIZ_REGIAO_FACTIVEL[1][0][0] = MATRIZ_REGIAO_FACTIVEL[1][0][0] + 1
                            if GENS_EVOL[aux[sorteia_porta]][i][2] == 110:
                                MATRIZ_REGIAO_FACTIVEL[1][2][0] = MATRIZ_REGIAO_FACTIVEL[1][2][0] + 1
                            if GENS_EVOL[aux[sorteia_porta]][i][2] == 130:
                                MATRIZ_REGIAO_FACTIVEL[1][3][0] = MATRIZ_REGIAO_FACTIVEL[1][3][0] + 1
                            if GENS_EVOL[aux[sorteia_porta]][i][2] == 800:
                                MATRIZ_REGIAO_FACTIVEL[1][4][0] = MATRIZ_REGIAO_FACTIVEL[1][4][0] + 1
                        if GENS_EVOL[0][i][2] == 110:
                            if GENS_EVOL[aux[sorteia_porta]][i][2] == 900:
                                MATRIZ_REGIAO_FACTIVEL[2][0][0] = MATRIZ_REGIAO_FACTIVEL[2][0][0] + 1
                            if GENS_EVOL[aux[sorteia_porta]][i][2] == 100:
                                MATRIZ_REGIAO_FACTIVEL[2][1][0] = MATRIZ_REGIAO_FACTIVEL[2][1][0] + 1
                            if GENS_EVOL[aux[sorteia_porta]][i][2] == 130:
                                MATRIZ_REGIAO_FACTIVEL[2][3][0] = MATRIZ_REGIAO_FACTIVEL[2][3][0] + 1
                            if GENS_EVOL[aux[sorteia_porta]][i][2] == 800:
                                MATRIZ_REGIAO_FACTIVEL[2][4][0] = MATRIZ_REGIAO_FACTIVEL[2][4][0] + 1
                        if GENS_EVOL[0][i][2] == 130:
                            if GENS_EVOL[aux[sorteia_porta]][i][2] == 900:
                                MATRIZ_REGIAO_FACTIVEL[3][0][0] = MATRIZ_REGIAO_FACTIVEL[3][0][0] + 1
                            if GENS_EVOL[aux[sorteia_porta]][i][2] == 100:
                                MATRIZ_REGIAO_FACTIVEL[3][1][0] = MATRIZ_REGIAO_FACTIVEL[3][1][0] + 1
                            if GENS_EVOL[aux[sorteia_porta]][i][2] == 110:
                                MATRIZ_REGIAO_FACTIVEL[3][2][0] = MATRIZ_REGIAO_FACTIVEL[3][2][0] + 1
                            if GENS_EVOL[aux[sorteia_porta]][i][2] == 800:
                                MATRIZ_REGIAO_FACTIVEL[3][4][0] = MATRIZ_REGIAO_FACTIVEL[3][4][0] + 1
                        if GENS_EVOL[0][i][2] == 800:
                            if GENS_EVOL[aux[sorteia_porta]][i][2] == 900:
                                MATRIZ_REGIAO_FACTIVEL[4][0][0] = MATRIZ_REGIAO_FACTIVEL[4][0][0] + 1
                            if GENS_EVOL[aux[sorteia_porta]][i][2] == 100:
                                MATRIZ_REGIAO_FACTIVEL[4][1][0] = MATRIZ_REGIAO_FACTIVEL[4][1][0] + 1
                            if GENS_EVOL[aux[sorteia_porta]][i][2] == 110:
                                MATRIZ_REGIAO_FACTIVEL[4][2][0] = MATRIZ_REGIAO_FACTIVEL[4][2][0] + 1
                            if GENS_EVOL[aux[sorteia_porta]][i][2] == 130:
                                MATRIZ_REGIAO_FACTIVEL[4][3][0] = MATRIZ_REGIAO_FACTIVEL[4][3][0] + 1    

    if caso == 1:
        GENS_EVOL[0] = copy.deepcopy(GENS_EVOL[aux[sorteia]])
    elif caso == 2:
        GENS_EVOL[0] = copy.deepcopy(GENS_EVOL[aux[sorteia_porta]])


def atualiza_pai_PORTAS(): #Quantifica a quantidade de acertos da tabela verdade e a quantidade de portas (sugestão do Heder), ao longo de todo o processo
    soma = 0
    fitness_soma = [] # Array que armazena a soma de todas as saídas de cada circuito
    aux = []
    for k in range(ee_lambda + 1):
        fitness_soma.append([])
    for i in range(len(FITNESS_EE)):
        for j in range(len(FITNESS_EE[i])):
            soma = soma + FITNESS_EE[i][j]
        fitness_soma[i] = copy.deepcopy(soma)
        soma = 0
    maior_fitness = max(fitness_soma)

    indice_maior_fitness = [] #Array que armazena os índices dos genótipos com a maior fitness existente
    iguais = [] #Array que armazena o número de portas correspondente a cada um dos genótipos com maior fitness existente
    iguais_qtd_portas = [] #Array que armazena os índices dos genótipos cujas fitness são iguais e a quantidade de portas também, caso a quantidade de portas seja a menor existente
    for i in range(len(fitness_soma)):
        if fitness_soma[i] == maior_fitness:
            indice_maior_fitness.append(i)

    for i in range(len(indice_maior_fitness)):
        iguais.append(PORTAS_EE[indice_maior_fitness[i]][no-1])
    menor_porta = min(iguais)

    for i in range(len(PORTAS_EE)):
        
        if PORTAS_EE[i][no-1] == menor_porta and fitness_soma[i] == maior_fitness:
            iguais_qtd_portas.append(i)
    
    if len(iguais_qtd_portas) > 1:
        pai = r.randint(0, len(iguais_qtd_portas)-1)
        pai = iguais_qtd_portas[pai]

    else:
        pai = iguais_qtd_portas[0]
        


    indice_maior_fitness.clear()
    iguais.clear()
    iguais_qtd_portas.clear()


    GENS_EVOL[0] = copy.deepcopy(GENS_EVOL[pai]) #Atualiza novo pai



def atualiza_pai_PORTAS_FACTIVEL(): #Quando o circuito atende a tabela verdade, conta-se o número de portas
    soma = 0
    fitness_soma = [] # Array que armazena a soma de todas as saídas de cada circuito
    aux = []
    factivel = False 
    for k in range(ee_lambda + 1):
        fitness_soma.append([])
    for i in range(len(FITNESS_EE)):
        for j in range(len(FITNESS_EE[i])):
            soma = soma + FITNESS_EE[i][j]
        fitness_soma[i] = copy.deepcopy(soma)
        soma = 0

    for i in range(len(fitness_soma)):
        if fitness_soma[i] == (no * len(OUTPUTS[0])):
            factivel = True
    
     

    if factivel == False:
        for s in range(len(fitness_soma)):
            if fitness_soma[s] == max(fitness_soma):
                aux.append(s)
        sorteia = r.randint(0, len(aux)-1)

        if fitness_soma[0] < fitness_soma[aux[sorteia]]:
            for i in range(len(GENS_EVOL[0])):
                if GENS_EVOL[0][i] != GENS_EVOL[aux[sorteia]][i]:

                    if i >= ni and i < ni+Ln:
                        if GENS_EVOL[0][i][2] != GENS_EVOL[aux[sorteia]][i][2]:
                            if GENS_EVOL[0][i][2] == 900:
                                if GENS_EVOL[aux[sorteia]][i][2] == 100:
                                    MATRIZ_REGIAO_INFACTIVEL[0][1][0] = MATRIZ_REGIAO_INFACTIVEL[0][1][0] + 1
                                if GENS_EVOL[aux[sorteia]][i][2] == 110:
                                    MATRIZ_REGIAO_INFACTIVEL[0][2][0] = MATRIZ_REGIAO_INFACTIVEL[0][2][0] + 1
                                if GENS_EVOL[aux[sorteia]][i][2] == 130:
                                    MATRIZ_REGIAO_INFACTIVEL[0][3][0] = MATRIZ_REGIAO_INFACTIVEL[0][3][0] + 1
                                if GENS_EVOL[aux[sorteia]][i][2] == 800:
                                    MATRIZ_REGIAO_INFACTIVEL[0][4][0] = MATRIZ_REGIAO_INFACTIVEL[0][4][0] + 1
                                if GENS_EVOL[aux[sorteia]][i][2] == 150:
                                    MATRIZ_REGIAO_INFACTIVEL[0][5][0] = MATRIZ_REGIAO_INFACTIVEL[0][5][0] + 1
                                if GENS_EVOL[aux[sorteia]][i][2] == 160:
                                    MATRIZ_REGIAO_INFACTIVEL[0][6][0] = MATRIZ_REGIAO_INFACTIVEL[0][6][0] + 1
                                if GENS_EVOL[aux[sorteia]][i][2] == 980:
                                    MATRIZ_REGIAO_INFACTIVEL[0][7][0] = MATRIZ_REGIAO_INFACTIVEL[0][7][0] + 1
                                if GENS_EVOL[aux[sorteia]][i][2] == 990:
                                    MATRIZ_REGIAO_INFACTIVEL[0][8][0] = MATRIZ_REGIAO_INFACTIVEL[0][8][0] + 1
                                                            
                                                                    
                            if GENS_EVOL[0][i][2] == 100:
                                if GENS_EVOL[aux[sorteia]][i][2] == 900:
                                    MATRIZ_REGIAO_INFACTIVEL[1][0][0] = MATRIZ_REGIAO_INFACTIVEL[1][0][0] + 1
                                if GENS_EVOL[aux[sorteia]][i][2] == 110:
                                    MATRIZ_REGIAO_INFACTIVEL[1][2][0] = MATRIZ_REGIAO_INFACTIVEL[1][2][0] + 1
                                if GENS_EVOL[aux[sorteia]][i][2] == 130:
                                    MATRIZ_REGIAO_INFACTIVEL[1][3][0] = MATRIZ_REGIAO_INFACTIVEL[1][3][0] + 1
                                if GENS_EVOL[aux[sorteia]][i][2] == 800:
                                    MATRIZ_REGIAO_INFACTIVEL[1][4][0] = MATRIZ_REGIAO_INFACTIVEL[1][4][0] + 1
                                if GENS_EVOL[aux[sorteia]][i][2] == 150:
                                    MATRIZ_REGIAO_INFACTIVEL[1][5][0] = MATRIZ_REGIAO_INFACTIVEL[1][5][0] + 1
                                if GENS_EVOL[aux[sorteia]][i][2] == 160:
                                    MATRIZ_REGIAO_INFACTIVEL[1][6][0] = MATRIZ_REGIAO_INFACTIVEL[1][6][0] + 1
                                if GENS_EVOL[aux[sorteia]][i][2] == 980:
                                    MATRIZ_REGIAO_INFACTIVEL[1][7][0] = MATRIZ_REGIAO_INFACTIVEL[1][7][0] + 1
                                if GENS_EVOL[aux[sorteia]][i][2] == 990:
                                    MATRIZ_REGIAO_INFACTIVEL[1][8][0] = MATRIZ_REGIAO_INFACTIVEL[1][8][0] + 1                            
                            if GENS_EVOL[0][i][2] == 110:
                                if GENS_EVOL[aux[sorteia]][i][2] == 900:
                                    MATRIZ_REGIAO_INFACTIVEL[2][0][0] = MATRIZ_REGIAO_INFACTIVEL[2][0][0] + 1
                                if GENS_EVOL[aux[sorteia]][i][2] == 100:
                                    MATRIZ_REGIAO_INFACTIVEL[2][1][0] = MATRIZ_REGIAO_INFACTIVEL[2][1][0] + 1
                                if GENS_EVOL[aux[sorteia]][i][2] == 130:
                                    MATRIZ_REGIAO_INFACTIVEL[2][3][0] = MATRIZ_REGIAO_INFACTIVEL[2][3][0] + 1
                                if GENS_EVOL[aux[sorteia]][i][2] == 800:
                                    MATRIZ_REGIAO_INFACTIVEL[2][4][0] = MATRIZ_REGIAO_INFACTIVEL[2][4][0] + 1
                                if GENS_EVOL[aux[sorteia]][i][2] == 150:
                                    MATRIZ_REGIAO_INFACTIVEL[2][5][0] = MATRIZ_REGIAO_INFACTIVEL[2][5][0] + 1
                                if GENS_EVOL[aux[sorteia]][i][2] == 160:
                                    MATRIZ_REGIAO_INFACTIVEL[2][6][0] = MATRIZ_REGIAO_INFACTIVEL[2][6][0] + 1
                                if GENS_EVOL[aux[sorteia]][i][2] == 980:
                                    MATRIZ_REGIAO_INFACTIVEL[2][7][0] = MATRIZ_REGIAO_INFACTIVEL[2][7][0] + 1
                                if GENS_EVOL[aux[sorteia]][i][2] == 990:
                                    MATRIZ_REGIAO_INFACTIVEL[2][8][0] = MATRIZ_REGIAO_INFACTIVEL[2][8][0] + 1                                    
                            if GENS_EVOL[0][i][2] == 130:
                                if GENS_EVOL[aux[sorteia]][i][2] == 900:
                                    MATRIZ_REGIAO_INFACTIVEL[3][0][0] = MATRIZ_REGIAO_INFACTIVEL[3][0][0] + 1
                                if GENS_EVOL[aux[sorteia]][i][2] == 100:
                                    MATRIZ_REGIAO_INFACTIVEL[3][1][0] = MATRIZ_REGIAO_INFACTIVEL[3][1][0] + 1
                                if GENS_EVOL[aux[sorteia]][i][2] == 110:
                                    MATRIZ_REGIAO_INFACTIVEL[3][2][0] = MATRIZ_REGIAO_INFACTIVEL[3][2][0] + 1
                                if GENS_EVOL[aux[sorteia]][i][2] == 800:
                                    MATRIZ_REGIAO_INFACTIVEL[3][4][0] = MATRIZ_REGIAO_INFACTIVEL[3][4][0] + 1
                                if GENS_EVOL[aux[sorteia]][i][2] == 150:
                                    MATRIZ_REGIAO_INFACTIVEL[3][5][0] = MATRIZ_REGIAO_INFACTIVEL[3][5][0] + 1
                                if GENS_EVOL[aux[sorteia]][i][2] == 160:
                                    MATRIZ_REGIAO_INFACTIVEL[3][6][0] = MATRIZ_REGIAO_INFACTIVEL[3][6][0] + 1
                                if GENS_EVOL[aux[sorteia]][i][2] == 980:
                                    MATRIZ_REGIAO_INFACTIVEL[3][7][0] = MATRIZ_REGIAO_INFACTIVEL[3][7][0] + 1
                                if GENS_EVOL[aux[sorteia]][i][2] == 990:
                                    MATRIZ_REGIAO_INFACTIVEL[3][8][0] = MATRIZ_REGIAO_INFACTIVEL[3][8][0] + 1                                    
                            if GENS_EVOL[0][i][2] == 800:
                                if GENS_EVOL[aux[sorteia]][i][2] == 900:
                                    MATRIZ_REGIAO_INFACTIVEL[4][0][0] = MATRIZ_REGIAO_INFACTIVEL[4][0][0] + 1
                                if GENS_EVOL[aux[sorteia]][i][2] == 100:
                                    MATRIZ_REGIAO_INFACTIVEL[4][1][0] = MATRIZ_REGIAO_INFACTIVEL[4][1][0] + 1
                                if GENS_EVOL[aux[sorteia]][i][2] == 110:
                                    MATRIZ_REGIAO_INFACTIVEL[4][2][0] = MATRIZ_REGIAO_INFACTIVEL[4][2][0] + 1
                                if GENS_EVOL[aux[sorteia]][i][2] == 130:
                                    MATRIZ_REGIAO_INFACTIVEL[4][3][0] = MATRIZ_REGIAO_INFACTIVEL[4][3][0] + 1
                                if GENS_EVOL[aux[sorteia]][i][2] == 150:
                                    MATRIZ_REGIAO_INFACTIVEL[4][5][0] = MATRIZ_REGIAO_INFACTIVEL[4][5][0] + 1
                                if GENS_EVOL[aux[sorteia]][i][2] == 160:
                                    MATRIZ_REGIAO_INFACTIVEL[4][6][0] = MATRIZ_REGIAO_INFACTIVEL[4][6][0] + 1
                                if GENS_EVOL[aux[sorteia]][i][2] == 980:
                                    MATRIZ_REGIAO_INFACTIVEL[4][7][0] = MATRIZ_REGIAO_INFACTIVEL[4][7][0] + 1
                                if GENS_EVOL[aux[sorteia]][i][2] == 990:
                                    MATRIZ_REGIAO_INFACTIVEL[4][8][0] = MATRIZ_REGIAO_INFACTIVEL[4][8][0] + 1

                            if GENS_EVOL[0][i][2] == 150:
                                if GENS_EVOL[aux[sorteia]][i][2] == 900:
                                    MATRIZ_REGIAO_INFACTIVEL[5][0][0] = MATRIZ_REGIAO_INFACTIVEL[5][0][0] + 1
                                if GENS_EVOL[aux[sorteia]][i][2] == 100:
                                    MATRIZ_REGIAO_INFACTIVEL[5][1][0] = MATRIZ_REGIAO_INFACTIVEL[5][1][0] + 1
                                if GENS_EVOL[aux[sorteia]][i][2] == 110:
                                    MATRIZ_REGIAO_INFACTIVEL[5][2][0] = MATRIZ_REGIAO_INFACTIVEL[5][2][0] + 1
                                if GENS_EVOL[aux[sorteia]][i][2] == 130:
                                    MATRIZ_REGIAO_INFACTIVEL[5][3][0] = MATRIZ_REGIAO_INFACTIVEL[5][3][0] + 1
                                if GENS_EVOL[aux[sorteia]][i][2] == 800:
                                    MATRIZ_REGIAO_INFACTIVEL[5][4][0] = MATRIZ_REGIAO_INFACTIVEL[5][4][0] + 1
                                if GENS_EVOL[aux[sorteia]][i][2] == 160:
                                    MATRIZ_REGIAO_INFACTIVEL[5][6][0] = MATRIZ_REGIAO_INFACTIVEL[5][6][0] + 1
                                if GENS_EVOL[aux[sorteia]][i][2] == 980:
                                    MATRIZ_REGIAO_INFACTIVEL[5][7][0] = MATRIZ_REGIAO_INFACTIVEL[5][7][0] + 1
                                if GENS_EVOL[aux[sorteia]][i][2] == 990:
                                    MATRIZ_REGIAO_INFACTIVEL[5][8][0] = MATRIZ_REGIAO_INFACTIVEL[5][8][0] + 1                             
                            if GENS_EVOL[0][i][2] == 160:
                                if GENS_EVOL[aux[sorteia]][i][2] == 900:
                                    MATRIZ_REGIAO_INFACTIVEL[6][0][0] = MATRIZ_REGIAO_INFACTIVEL[6][0][0] + 1
                                if GENS_EVOL[aux[sorteia]][i][2] == 100:
                                    MATRIZ_REGIAO_INFACTIVEL[6][1][0] = MATRIZ_REGIAO_INFACTIVEL[6][1][0] + 1
                                if GENS_EVOL[aux[sorteia]][i][2] == 110:
                                    MATRIZ_REGIAO_INFACTIVEL[6][2][0] = MATRIZ_REGIAO_INFACTIVEL[6][2][0] + 1
                                if GENS_EVOL[aux[sorteia]][i][2] == 130:
                                    MATRIZ_REGIAO_INFACTIVEL[6][3][0] = MATRIZ_REGIAO_INFACTIVEL[6][3][0] + 1
                                if GENS_EVOL[aux[sorteia]][i][2] == 800:
                                    MATRIZ_REGIAO_INFACTIVEL[6][4][0] = MATRIZ_REGIAO_INFACTIVEL[6][4][0] + 1
                                if GENS_EVOL[aux[sorteia]][i][2] == 150:
                                    MATRIZ_REGIAO_INFACTIVEL[6][5][0] = MATRIZ_REGIAO_INFACTIVEL[6][5][0] + 1
                                if GENS_EVOL[aux[sorteia]][i][2] == 980:
                                    MATRIZ_REGIAO_INFACTIVEL[6][7][0] = MATRIZ_REGIAO_INFACTIVEL[6][7][0] + 1
                                if GENS_EVOL[aux[sorteia]][i][2] == 990:
                                    MATRIZ_REGIAO_INFACTIVEL[6][8][0] = MATRIZ_REGIAO_INFACTIVEL[6][8][0] + 1
                            if GENS_EVOL[0][i][2] == 980:
                                if GENS_EVOL[aux[sorteia]][i][2] == 900:
                                    MATRIZ_REGIAO_INFACTIVEL[7][0][0] = MATRIZ_REGIAO_INFACTIVEL[7][0][0] + 1
                                if GENS_EVOL[aux[sorteia]][i][2] == 100:
                                    MATRIZ_REGIAO_INFACTIVEL[7][1][0] = MATRIZ_REGIAO_INFACTIVEL[7][1][0] + 1
                                if GENS_EVOL[aux[sorteia]][i][2] == 110:
                                    MATRIZ_REGIAO_INFACTIVEL[7][2][0] = MATRIZ_REGIAO_INFACTIVEL[7][2][0] + 1
                                if GENS_EVOL[aux[sorteia]][i][2] == 130:
                                    MATRIZ_REGIAO_INFACTIVEL[7][3][0] = MATRIZ_REGIAO_INFACTIVEL[7][3][0] + 1
                                if GENS_EVOL[aux[sorteia]][i][2] == 800:
                                    MATRIZ_REGIAO_INFACTIVEL[7][4][0] = MATRIZ_REGIAO_INFACTIVEL[7][4][0] + 1
                                if GENS_EVOL[aux[sorteia]][i][2] == 150:
                                    MATRIZ_REGIAO_INFACTIVEL[7][5][0] = MATRIZ_REGIAO_INFACTIVEL[7][5][0] + 1
                                if GENS_EVOL[aux[sorteia]][i][2] == 160:
                                    MATRIZ_REGIAO_INFACTIVEL[7][6][0] = MATRIZ_REGIAO_INFACTIVEL[7][6][0] + 1
                                if GENS_EVOL[aux[sorteia]][i][2] == 990:
                                    MATRIZ_REGIAO_INFACTIVEL[7][8][0] = MATRIZ_REGIAO_INFACTIVEL[7][8][0] + 1
                            if GENS_EVOL[0][i][2] == 990:
                                if GENS_EVOL[aux[sorteia]][i][2] == 900:
                                    MATRIZ_REGIAO_INFACTIVEL[8][0][0] = MATRIZ_REGIAO_INFACTIVEL[8][0][0] + 1
                                if GENS_EVOL[aux[sorteia]][i][2] == 100:
                                    MATRIZ_REGIAO_INFACTIVEL[8][1][0] = MATRIZ_REGIAO_INFACTIVEL[8][1][0] + 1
                                if GENS_EVOL[aux[sorteia]][i][2] == 110:
                                    MATRIZ_REGIAO_INFACTIVEL[8][2][0] = MATRIZ_REGIAO_INFACTIVEL[8][2][0] + 1
                                if GENS_EVOL[aux[sorteia]][i][2] == 130:
                                    MATRIZ_REGIAO_INFACTIVEL[8][3][0] = MATRIZ_REGIAO_INFACTIVEL[8][3][0] + 1
                                if GENS_EVOL[aux[sorteia]][i][2] == 800:
                                    MATRIZ_REGIAO_INFACTIVEL[8][4][0] = MATRIZ_REGIAO_INFACTIVEL[8][4][0] + 1
                                if GENS_EVOL[aux[sorteia]][i][2] == 150:
                                    MATRIZ_REGIAO_INFACTIVEL[8][5][0] = MATRIZ_REGIAO_INFACTIVEL[8][5][0] + 1
                                if GENS_EVOL[aux[sorteia]][i][2] == 160:
                                    MATRIZ_REGIAO_INFACTIVEL[8][6][0] = MATRIZ_REGIAO_INFACTIVEL[8][6][0] + 1
                                if GENS_EVOL[aux[sorteia]][i][2] == 980:
                                    MATRIZ_REGIAO_INFACTIVEL[8][7][0] = MATRIZ_REGIAO_INFACTIVEL[8][7][0] + 1

        GENS_EVOL[0] = copy.deepcopy(GENS_EVOL[aux[sorteia]])            

    if factivel == True:
        for i in range(ee_lambda + 1):
            PORTAS_EE[i][no-1] = copy.deepcopy(PORTAS_CKT[i])
        maior_fitness = max(fitness_soma)

        indice_maior_fitness = []
        iguais = []
        iguais_qtd_portas = []
        for i in range(len(fitness_soma)):
            if fitness_soma[i] == maior_fitness:
                indice_maior_fitness.append(i)

        for i in range(len(indice_maior_fitness)):
            iguais.append(PORTAS_EE[indice_maior_fitness[i]][no-1])
        menor_porta = min(iguais)

        for i in range(len(PORTAS_EE)):

            if PORTAS_EE[i][no-1] == menor_porta and fitness_soma[i] == maior_fitness:
                iguais_qtd_portas.append(i)

        if len(iguais_qtd_portas) > 1:
            pai = r.randint(0, len(iguais_qtd_portas)-1)
            pai = iguais_qtd_portas[pai]

        else:
            pai = iguais_qtd_portas[0]

        indice_maior_fitness.clear()
        iguais.clear()
        iguais_qtd_portas.clear()

        if PORTAS_EE[0][no-1] > PORTAS_EE[pai][no-1]:
            for i in range(len(GENS_EVOL[0])):
                if GENS_EVOL[0][i] != GENS_EVOL[pai][i]:

                    if i >= ni and i != ni+Ln and i < ni+Ln:
                        if GENS_EVOL[0][i][2] != GENS_EVOL[pai][i][2]:
                            if GENS_EVOL[0][i][2] == 900:
                                if GENS_EVOL[pai][i][2] == 100:
                                    MATRIZ_REGIAO_FACTIVEL[0][1][0] = MATRIZ_REGIAO_FACTIVEL[0][1][0] + 1
                                if GENS_EVOL[pai][i][2] == 110:
                                    MATRIZ_REGIAO_FACTIVEL[0][2][0] = MATRIZ_REGIAO_FACTIVEL[0][2][0] + 1
                                if GENS_EVOL[pai][i][2] == 130:
                                    MATRIZ_REGIAO_FACTIVEL[0][3][0] = MATRIZ_REGIAO_FACTIVEL[0][3][0] + 1
                                if GENS_EVOL[pai][i][2] == 800:
                                    MATRIZ_REGIAO_FACTIVEL[0][4][0] = MATRIZ_REGIAO_FACTIVEL[0][4][0] + 1
                                if GENS_EVOL[pai][i][2] == 150:
                                    MATRIZ_REGIAO_FACTIVEL[0][5][0] = MATRIZ_REGIAO_FACTIVEL[0][5][0] + 1
                                if GENS_EVOL[pai][i][2] == 160:
                                    MATRIZ_REGIAO_FACTIVEL[0][6][0] = MATRIZ_REGIAO_FACTIVEL[0][6][0] + 1
                                if GENS_EVOL[pai][i][2] == 980:
                                    MATRIZ_REGIAO_FACTIVEL[0][7][0] = MATRIZ_REGIAO_FACTIVEL[0][7][0] + 1
                                if GENS_EVOL[pai][i][2] == 990:
                                    MATRIZ_REGIAO_FACTIVEL[0][8][0] = MATRIZ_REGIAO_FACTIVEL[0][8][0] + 1
                                                            
                                                                    
                            if GENS_EVOL[0][i][2] == 100:
                                if GENS_EVOL[pai][i][2] == 900:
                                    MATRIZ_REGIAO_FACTIVEL[1][0][0] = MATRIZ_REGIAO_FACTIVEL[1][0][0] + 1
                                if GENS_EVOL[pai][i][2] == 110:
                                    MATRIZ_REGIAO_FACTIVEL[1][2][0] = MATRIZ_REGIAO_FACTIVEL[1][2][0] + 1
                                if GENS_EVOL[pai][i][2] == 130:
                                    MATRIZ_REGIAO_FACTIVEL[1][3][0] = MATRIZ_REGIAO_FACTIVEL[1][3][0] + 1
                                if GENS_EVOL[pai][i][2] == 800:
                                    MATRIZ_REGIAO_FACTIVEL[1][4][0] = MATRIZ_REGIAO_FACTIVEL[1][4][0] + 1
                                if GENS_EVOL[pai][i][2] == 150:
                                    MATRIZ_REGIAO_FACTIVEL[1][5][0] = MATRIZ_REGIAO_FACTIVEL[1][5][0] + 1
                                if GENS_EVOL[pai][i][2] == 160:
                                    MATRIZ_REGIAO_FACTIVEL[1][6][0] = MATRIZ_REGIAO_FACTIVEL[1][6][0] + 1
                                if GENS_EVOL[pai][i][2] == 980:
                                    MATRIZ_REGIAO_FACTIVEL[1][7][0] = MATRIZ_REGIAO_FACTIVEL[1][7][0] + 1
                                if GENS_EVOL[pai][i][2] == 990:
                                    MATRIZ_REGIAO_FACTIVEL[1][8][0] = MATRIZ_REGIAO_FACTIVEL[1][8][0] + 1                            
                            if GENS_EVOL[0][i][2] == 110:
                                if GENS_EVOL[pai][i][2] == 900:
                                    MATRIZ_REGIAO_FACTIVEL[2][0][0] = MATRIZ_REGIAO_FACTIVEL[2][0][0] + 1
                                if GENS_EVOL[pai][i][2] == 100:
                                    MATRIZ_REGIAO_FACTIVEL[2][1][0] = MATRIZ_REGIAO_FACTIVEL[2][1][0] + 1
                                if GENS_EVOL[pai][i][2] == 130:
                                    MATRIZ_REGIAO_FACTIVEL[2][3][0] = MATRIZ_REGIAO_FACTIVEL[2][3][0] + 1
                                if GENS_EVOL[pai][i][2] == 800:
                                    MATRIZ_REGIAO_FACTIVEL[2][4][0] = MATRIZ_REGIAO_FACTIVEL[2][4][0] + 1
                                if GENS_EVOL[pai][i][2] == 150:
                                    MATRIZ_REGIAO_FACTIVEL[2][5][0] = MATRIZ_REGIAO_FACTIVEL[2][5][0] + 1
                                if GENS_EVOL[pai][i][2] == 160:
                                    MATRIZ_REGIAO_FACTIVEL[2][6][0] = MATRIZ_REGIAO_FACTIVEL[2][6][0] + 1
                                if GENS_EVOL[pai][i][2] == 980:
                                    MATRIZ_REGIAO_FACTIVEL[2][7][0] = MATRIZ_REGIAO_FACTIVEL[2][7][0] + 1
                                if GENS_EVOL[pai][i][2] == 990:
                                    MATRIZ_REGIAO_FACTIVEL[2][8][0] = MATRIZ_REGIAO_FACTIVEL[2][8][0] + 1                                    
                            if GENS_EVOL[0][i][2] == 130:
                                if GENS_EVOL[pai][i][2] == 900:
                                    MATRIZ_REGIAO_FACTIVEL[3][0][0] = MATRIZ_REGIAO_FACTIVEL[3][0][0] + 1
                                if GENS_EVOL[pai][i][2] == 100:
                                    MATRIZ_REGIAO_FACTIVEL[3][1][0] = MATRIZ_REGIAO_FACTIVEL[3][1][0] + 1
                                if GENS_EVOL[pai][i][2] == 110:
                                    MATRIZ_REGIAO_FACTIVEL[3][2][0] = MATRIZ_REGIAO_FACTIVEL[3][2][0] + 1
                                if GENS_EVOL[pai][i][2] == 800:
                                    MATRIZ_REGIAO_FACTIVEL[3][4][0] = MATRIZ_REGIAO_FACTIVEL[3][4][0] + 1
                                if GENS_EVOL[pai][i][2] == 150:
                                    MATRIZ_REGIAO_FACTIVEL[3][5][0] = MATRIZ_REGIAO_FACTIVEL[3][5][0] + 1
                                if GENS_EVOL[pai][i][2] == 160:
                                    MATRIZ_REGIAO_FACTIVEL[3][6][0] = MATRIZ_REGIAO_FACTIVEL[3][6][0] + 1
                                if GENS_EVOL[pai][i][2] == 980:
                                    MATRIZ_REGIAO_FACTIVEL[3][7][0] = MATRIZ_REGIAO_FACTIVEL[3][7][0] + 1
                                if GENS_EVOL[pai][i][2] == 990:
                                    MATRIZ_REGIAO_FACTIVEL[3][8][0] = MATRIZ_REGIAO_FACTIVEL[3][8][0] + 1                                    
                            if GENS_EVOL[0][i][2] == 800:
                                if GENS_EVOL[pai][i][2] == 900:
                                    MATRIZ_REGIAO_FACTIVEL[4][0][0] = MATRIZ_REGIAO_FACTIVEL[4][0][0] + 1
                                if GENS_EVOL[pai][i][2] == 100:
                                    MATRIZ_REGIAO_FACTIVEL[4][1][0] = MATRIZ_REGIAO_FACTIVEL[4][1][0] + 1
                                if GENS_EVOL[pai][i][2] == 110:
                                    MATRIZ_REGIAO_FACTIVEL[4][2][0] = MATRIZ_REGIAO_FACTIVEL[4][2][0] + 1
                                if GENS_EVOL[pai][i][2] == 130:
                                    MATRIZ_REGIAO_FACTIVEL[4][3][0] = MATRIZ_REGIAO_FACTIVEL[4][3][0] + 1
                                if GENS_EVOL[pai][i][2] == 150:
                                    MATRIZ_REGIAO_FACTIVEL[4][5][0] = MATRIZ_REGIAO_FACTIVEL[4][5][0] + 1
                                if GENS_EVOL[pai][i][2] == 160:
                                    MATRIZ_REGIAO_FACTIVEL[4][6][0] = MATRIZ_REGIAO_FACTIVEL[4][6][0] + 1
                                if GENS_EVOL[pai][i][2] == 980:
                                    MATRIZ_REGIAO_FACTIVEL[4][7][0] = MATRIZ_REGIAO_FACTIVEL[4][7][0] + 1
                                if GENS_EVOL[pai][i][2] == 990:
                                    MATRIZ_REGIAO_FACTIVEL[4][8][0] = MATRIZ_REGIAO_FACTIVEL[4][8][0] + 1

                            if GENS_EVOL[0][i][2] == 150:
                                if GENS_EVOL[pai][i][2] == 900:
                                    MATRIZ_REGIAO_FACTIVEL[5][0][0] = MATRIZ_REGIAO_FACTIVEL[5][0][0] + 1
                                if GENS_EVOL[pai][i][2] == 100:
                                    MATRIZ_REGIAO_FACTIVEL[5][1][0] = MATRIZ_REGIAO_FACTIVEL[5][1][0] + 1
                                if GENS_EVOL[pai][i][2] == 110:
                                    MATRIZ_REGIAO_FACTIVEL[5][2][0] = MATRIZ_REGIAO_FACTIVEL[5][2][0] + 1
                                if GENS_EVOL[pai][i][2] == 130:
                                    MATRIZ_REGIAO_FACTIVEL[5][3][0] = MATRIZ_REGIAO_FACTIVEL[5][3][0] + 1
                                if GENS_EVOL[pai][i][2] == 800:
                                    MATRIZ_REGIAO_FACTIVEL[5][4][0] = MATRIZ_REGIAO_FACTIVEL[5][4][0] + 1
                                if GENS_EVOL[pai][i][2] == 160:
                                    MATRIZ_REGIAO_FACTIVEL[5][6][0] = MATRIZ_REGIAO_FACTIVEL[5][6][0] + 1
                                if GENS_EVOL[pai][i][2] == 980:
                                    MATRIZ_REGIAO_FACTIVEL[5][7][0] = MATRIZ_REGIAO_FACTIVEL[5][7][0] + 1
                                if GENS_EVOL[pai][i][2] == 990:
                                    MATRIZ_REGIAO_FACTIVEL[5][8][0] = MATRIZ_REGIAO_FACTIVEL[5][8][0] + 1                             
                            if GENS_EVOL[0][i][2] == 160:
                                if GENS_EVOL[pai][i][2] == 900:
                                    MATRIZ_REGIAO_FACTIVEL[6][0][0] = MATRIZ_REGIAO_FACTIVEL[6][0][0] + 1
                                if GENS_EVOL[pai][i][2] == 100:
                                    MATRIZ_REGIAO_FACTIVEL[6][1][0] = MATRIZ_REGIAO_FACTIVEL[6][1][0] + 1
                                if GENS_EVOL[pai][i][2] == 110:
                                    MATRIZ_REGIAO_FACTIVEL[6][2][0] = MATRIZ_REGIAO_FACTIVEL[6][2][0] + 1
                                if GENS_EVOL[pai][i][2] == 130:
                                    MATRIZ_REGIAO_FACTIVEL[6][3][0] = MATRIZ_REGIAO_FACTIVEL[6][3][0] + 1
                                if GENS_EVOL[pai][i][2] == 800:
                                    MATRIZ_REGIAO_FACTIVEL[6][4][0] = MATRIZ_REGIAO_FACTIVEL[6][4][0] + 1
                                if GENS_EVOL[pai][i][2] == 150:
                                    MATRIZ_REGIAO_FACTIVEL[6][5][0] = MATRIZ_REGIAO_FACTIVEL[6][5][0] + 1
                                if GENS_EVOL[pai][i][2] == 980:
                                    MATRIZ_REGIAO_FACTIVEL[6][7][0] = MATRIZ_REGIAO_FACTIVEL[6][7][0] + 1
                                if GENS_EVOL[pai][i][2] == 990:
                                    MATRIZ_REGIAO_FACTIVEL[6][8][0] = MATRIZ_REGIAO_FACTIVEL[6][8][0] + 1
                            if GENS_EVOL[0][i][2] == 980:
                                if GENS_EVOL[pai][i][2] == 900:
                                    MATRIZ_REGIAO_FACTIVEL[7][0][0] = MATRIZ_REGIAO_FACTIVEL[7][0][0] + 1
                                if GENS_EVOL[pai][i][2] == 100:
                                    MATRIZ_REGIAO_FACTIVEL[7][1][0] = MATRIZ_REGIAO_FACTIVEL[7][1][0] + 1
                                if GENS_EVOL[pai][i][2] == 110:
                                    MATRIZ_REGIAO_FACTIVEL[7][2][0] = MATRIZ_REGIAO_FACTIVEL[7][2][0] + 1
                                if GENS_EVOL[pai][i][2] == 130:
                                    MATRIZ_REGIAO_FACTIVEL[7][3][0] = MATRIZ_REGIAO_FACTIVEL[7][3][0] + 1
                                if GENS_EVOL[pai][i][2] == 800:
                                    MATRIZ_REGIAO_FACTIVEL[7][4][0] = MATRIZ_REGIAO_FACTIVEL[7][4][0] + 1
                                if GENS_EVOL[pai][i][2] == 150:
                                    MATRIZ_REGIAO_FACTIVEL[7][5][0] = MATRIZ_REGIAO_FACTIVEL[7][5][0] + 1
                                if GENS_EVOL[pai][i][2] == 160:
                                    MATRIZ_REGIAO_FACTIVEL[7][6][0] = MATRIZ_REGIAO_FACTIVEL[7][6][0] + 1
                                if GENS_EVOL[pai][i][2] == 990:
                                    MATRIZ_REGIAO_FACTIVEL[7][8][0] = MATRIZ_REGIAO_FACTIVEL[7][8][0] + 1
                            if GENS_EVOL[0][i][2] == 990:
                                if GENS_EVOL[pai][i][2] == 900:
                                    MATRIZ_REGIAO_FACTIVEL[8][0][0] = MATRIZ_REGIAO_FACTIVEL[8][0][0] + 1
                                if GENS_EVOL[pai][i][2] == 100:
                                    MATRIZ_REGIAO_FACTIVEL[8][1][0] = MATRIZ_REGIAO_FACTIVEL[8][1][0] + 1
                                if GENS_EVOL[pai][i][2] == 110:
                                    MATRIZ_REGIAO_FACTIVEL[8][2][0] = MATRIZ_REGIAO_FACTIVEL[8][2][0] + 1
                                if GENS_EVOL[pai][i][2] == 130:
                                    MATRIZ_REGIAO_FACTIVEL[8][3][0] = MATRIZ_REGIAO_FACTIVEL[8][3][0] + 1
                                if GENS_EVOL[pai][i][2] == 800:
                                    MATRIZ_REGIAO_FACTIVEL[8][4][0] = MATRIZ_REGIAO_FACTIVEL[8][4][0] + 1
                                if GENS_EVOL[pai][i][2] == 150:
                                    MATRIZ_REGIAO_FACTIVEL[8][5][0] = MATRIZ_REGIAO_FACTIVEL[8][5][0] + 1
                                if GENS_EVOL[pai][i][2] == 160:
                                    MATRIZ_REGIAO_FACTIVEL[8][6][0] = MATRIZ_REGIAO_FACTIVEL[8][6][0] + 1
                                if GENS_EVOL[pai][i][2] == 980:
                                    MATRIZ_REGIAO_FACTIVEL[8][7][0] = MATRIZ_REGIAO_FACTIVEL[8][7][0] + 1  
    

                    
        GENS_EVOL[0] = copy.deepcopy(GENS_EVOL[pai])





def atualiza_pai_PORTAS_FACTIVEL_CONTROLEMUX():
    soma = 0
    fitness_soma = [] # Array que armazena a soma de todas as saídas de cada circuito
    aux = []
    factivel = False 
    for k in range(ee_lambda + 1):
        fitness_soma.append([])
    for i in range(len(FITNESS_EE)):
        for j in range(len(FITNESS_EE[i])):
            soma = soma + FITNESS_EE[i][j]
        fitness_soma[i] = copy.deepcopy(soma)
        soma = 0

    for i in range(len(fitness_soma)):
        if fitness_soma[i] == (no * len(OUTPUTS[0])):
            factivel = True
            break


    if factivel == False:
        for s in range(len(fitness_soma)):
            if fitness_soma[s] == max(fitness_soma):
                aux.append(s)
                
        sorteia = r.randint(0, len(aux)-1)


        GENS_EVOL[0] = copy.deepcopy(GENS_EVOL[aux[sorteia]])            

    if factivel == True:
        comuns_ee_local = []
        soma_ee_local = 0
        for i in range(ee_lambda + 1):
            for j in range(len(COMUNS_EE[i])):
                soma_ee_local += COMUNS_EE[i][j]
            comuns_ee_local.append(soma_ee_local)
            soma_ee_local = 0


        factiveis_obtidos = []
        maior_fitness = max(fitness_soma)
        for i in range(len(fitness_soma)):
            if fitness_soma[i] == maior_fitness:
                factiveis_obtidos.append(i)


        qtd_comuns_importantes = []
        for i in range(len(factiveis_obtidos)):
            qtd_comuns_importantes.append(comuns_ee_local[factiveis_obtidos[i]])


        maior_valor_comuns = max(qtd_comuns_importantes)


        indice_comuns_iguais = []
        for i in range(len(qtd_comuns_importantes)):
            if qtd_comuns_importantes[i] == maior_valor_comuns:
                indice_comuns_iguais.append(factiveis_obtidos[i])
                                            
        pai = indice_comuns_iguais[r.randint(0, len(indice_comuns_iguais)-1)]

        FITNESS_EE[0] = copy.deepcopy(FITNESS_EE[pai])
        COMUNS_EE[0] = copy.deepcopy(COMUNS_EE[pai])
        GENS_EVOL[0] = copy.deepcopy(GENS_EVOL[pai])
        MUX_CKT[0] = copy.deepcopy(MUX_CKT[pai])
        PORTAS_CKT[0] = copy.deepcopy(PORTAS_CKT[pai])
        WIRES_CKT[0] = copy.deepcopy(WIRES_CKT[pai])


def atualiza_pai_CROSSOVER_NOVO_GENES_ATIVOS():

    fitness_saida = []
    for i in range(no):
        fitness_saida.append([])

    for i in range(no):
        for j in range(len(FITNESS_EE)):
            fitness_saida[i].append(FITNESS_EE[j][i])

    indice_melhores_saidas = []
    melhores_saidas = []

    for i in range(no):
        melhores_saidas.append([])

    for i in range(len(fitness_saida)):
        melhor = max(fitness_saida[i])
        for j in range(len(fitness_saida[i])):
            if fitness_saida[i][j] == melhor:
                melhores_saidas[i].append(j)

    todos_indices = []
    for i in range(len(melhores_saidas)):
        for j in range(len(melhores_saidas[i])):
            todos_indices.append(melhores_saidas[i][j])

    qtd_iguais = []
    for i in range(1 + ee_lambda):
        qtd_iguais.append(todos_indices.count(i))
        
        
    maiores_melhores_saidas = []
    for i in range(len(qtd_iguais)):
        if qtd_iguais[i] == max(qtd_iguais):
            maiores_melhores_saidas.append(i)

    ## Determina quais saídas estão presentes nos melhores indivíduos presentes
    saidas_presentes = []
    for i in range(len(maiores_melhores_saidas)):
        saidas_presentes.append([])


    for i in range(len(maiores_melhores_saidas)):
        for j in range(len(melhores_saidas)):
            if maiores_melhores_saidas[i] in melhores_saidas[j]:
                saidas_presentes[i].append(j)

    #######

    ## Determina a quantidade de genes ativos dos melhores individuos presentes
    genes_ativos_melhores_individuos = []
    genes_temporario = []
    for i in range(len(saidas_presentes)):
        for j in range(len(saidas_presentes[i])):
            for k in range(len(MEUARRAY[i][j])):
                if MEUARRAY[i][j][k] == "X":
                    if k not in genes_temporario:
                        genes_temporario.append(k)
        genes_ativos_melhores_individuos.append(len(genes_temporario))
        genes_temporario.clear()
    #######
    maiores_melhores_saidas_qtd_genes = []
    valor_maximo_genes_ativos = max(genes_ativos_melhores_individuos)
    for i in range(len(genes_ativos_melhores_individuos)):
        if genes_ativos_melhores_individuos[i] == valor_maximo_genes_ativos:
            maiores_melhores_saidas_qtd_genes.append(i)
            

    
            
    INDIVIDUO_INICIAL = maiores_melhores_saidas[maiores_melhores_saidas_qtd_genes[r.randint(0, len(maiores_melhores_saidas_qtd_genes)-1)]]

    
    saidas_individuo_inicial = []
    for i in range(len(melhores_saidas)):
        if INDIVIDUO_INICIAL in melhores_saidas[i]:
            saidas_individuo_inicial.append(i)

    saidas_a_processar = []
    for i in range(no):
        if i not in saidas_individuo_inicial:
            saidas_a_processar.append(i)


    individuo_saidas_a_processar = []
    #for i in range(len(saidas_a_processar)):
    #    individuo_saidas_a_processar.append(melhores_saidas[saidas_a_processar[i]][r.randint(0, len(melhores_saidas[saidas_a_processar[i]])-1)])


    ## Determina as saidas com mais genes ativos para serem incorporadas
    genes_temporarios = []
    ativos_saida_atual = []
    for i in range(len(saidas_a_processar)):
        ativos_saida_atual = []
        for j in range(len(melhores_saidas[saidas_a_processar[i]])):
            for k in range(len(MEUARRAY[melhores_saidas[saidas_a_processar[i]][j]][saidas_a_processar[i]])):
                if MEUARRAY[melhores_saidas[saidas_a_processar[i]][j]][saidas_a_processar[i]][k] == "X":
                    if k not in genes_temporarios:
                        genes_temporarios.append(k)
            ativos_saida_atual.append(len(genes_temporarios))
            genes_temporarios = []
        opcoes = []
        maximo_ativos = max(ativos_saida_atual)
        for elemento in range(len(ativos_saida_atual)):
            if ativos_saida_atual[elemento] == maximo_ativos:
                opcoes.append(elemento)
        #print("SAIDAS A PROCESSAR: ", saidas_a_processar)
        #print("SAIDA EM PROCESSO: ", saidas_a_processar[i])
        #print("ATIVOS SAIDA ATUAL: ", ativos_saida_atual)
        #print("OPCOES: ", opcoes)
        #print("MELHORES SAIDAS ", melhores_saidas)
        individuo_saidas_a_processar.append(melhores_saidas[saidas_a_processar[i]][opcoes[r.randint(0, len(opcoes)-1)]])
        

    #######
    

    for i in range(len(melhores_saidas)):
        indice = r.randint(0, len(melhores_saidas[i])-1)
        indice_melhores_saidas.append(melhores_saidas[i][indice])

    novo_individuo = []
    individuo_inicial = []

##PERFEITO ATÉ AQUI
# Determina a fitness do individuo final
    fitness_final_novo_individuo = []

    for i in range(len(fitness_saida)):
        fitness_final_novo_individuo.append(max(fitness_saida[i]))


##
    if 1 < 0:
        variavel = 0
    else:
        novo_individuo = copy.deepcopy(GENS_EVOL[INDIVIDUO_INICIAL])
        individuo_inicial.append(INDIVIDUO_INICIAL)
        gene_disponivel = []
        ###
        GENES_ATIVOS_MOM = []
        GENES_ATIVOS_MOM = copy.deepcopy(MEUARRAY[INDIVIDUO_INICIAL][0])
        for x in range(len(GENES_ATIVOS_MOM)):
            if GENES_ATIVOS_MOM[x] == "X":
                GENES_ATIVOS_MOM[x] = "-"
        ###


        for i in range(len(saidas_individuo_inicial)):
            for p in range(len(MEUARRAY[INDIVIDUO_INICIAL][saidas_individuo_inicial[i]])):
                if MEUARRAY[INDIVIDUO_INICIAL][saidas_individuo_inicial[i]][p] == "X":
                    GENES_ATIVOS_MOM[p] = "X"


        for i in range(len(GENES_ATIVOS_MOM)):
            if GENES_ATIVOS_MOM[i] != "X" and i >= ni and i < Ln+ni:
                gene_disponivel.append(i)
                
        
                                                               
        for k in range(len(saidas_a_processar)):
            saida_atual = saidas_a_processar[k]
            individuo_saida_atual = individuo_saidas_a_processar[k]
            copia_individuo_atual = copy.deepcopy(GENS_EVOL[individuo_saidas_a_processar[k]])

            if 1 < 0:

                novo_individuo = copy.deepcopy(GENS_EVOL[individuo_saida_atual])

            else:



                genes_saida_atual = []
                indice_genes_saida_atual = []
                for i in range(len(MEUARRAY[individuo_saida_atual][saida_atual])):
                    if MEUARRAY[individuo_saida_atual][saida_atual][i] == "X" and i >= ni and i < Ln+ni: ##Talvez essa condição i>= ni não faça sentido
                    
                        valor_a_ser_adicionado = copy.deepcopy(GENS_EVOL[individuo_saida_atual][i])
                        genes_saida_atual.append(valor_a_ser_adicionado)
                        indice_genes_saida_atual.append(i)


                saida_corrigir_um = []
                if len(genes_saida_atual) != 0:
                    saida_corrigir_um.append(genes_saida_atual[len(genes_saida_atual)-1])
                else:
                    saida_corrigir_um.append(GENS_EVOL[individuo_saida_atual][Ln+ni+saida_atual])


                ## ATÉ AQUI APARENTEMENTE OK

                while len(genes_saida_atual) != 0:

                    for i in range(len(indice_genes_saida_atual)):

                        if len(genes_saida_atual) == 1:

                            saida_corrigir_um[0] = copy.deepcopy(genes_saida_atual[0])
                      
                        gene_analisando = []
                        if len(genes_saida_atual) > 0:
                            for m in range(len(genes_saida_atual[0])):

                                gene_analisando.append(int(genes_saida_atual[0][m]))

                            if len(gene_disponivel) == 0:
                                print("--------------------------------------- FALTA ESPAÇO --------------------------------------")
                                exit()


                        if novo_individuo[indice_genes_saida_atual[i]] == gene_analisando:

                            genes_saida_atual.pop(0)
                            for v in range(len(gene_disponivel)):
                                if gene_disponivel[v] == indice_genes_saida_atual[i]:
                                    gene_disponivel.pop(v)
                                    break

                        else:
                            minha_condicao = True #aqui
                            for j in range(len(gene_disponivel)):
                                atual_indices_existentes = []
                                for h in range(len(gene_analisando)):
                                    if h < 2:
                                        atual_indices_existentes.append(gene_analisando[h])
                                        
                                atual_maior_indice_existente = max(atual_indices_existentes)
                                        
                                if gene_disponivel[j] > atual_maior_indice_existente:

                                    novo_individuo[gene_disponivel[j]] = copy.deepcopy(gene_analisando)



                                    novo_indice = gene_disponivel[j]

                                    genes_saida_atual.pop(0)

                                    gene_disponivel.pop(j)
                                    minha_condicao = False #aqui
                                    break
                                        
                                            
                            for w in range(len(genes_saida_atual)):
                                valor_procurado = indice_genes_saida_atual[i]
                                if genes_saida_atual[w][0] == valor_procurado:
                                    genes_saida_atual[w][0] = copy.deepcopy(str(novo_indice))
                                if genes_saida_atual[w][1] == valor_procurado:
                                    genes_saida_atual[w][1] = copy.deepcopy(str(novo_indice))
                                if saida_corrigir_um[0][0] == valor_procurado:
                                    saida_corrigir_um[0][0] = copy.deepcopy(str(novo_indice))
                                if saida_corrigir_um[0][1] == valor_procurado:
                                    saida_corrigir_um[0][1] = copy.deepcopy(str(novo_indice))
                            

                saida_corrigir = []
                if type(saida_corrigir_um[0]) == list:
                    for m in range(len(saida_corrigir_um[0])):
                        saida_corrigir_um[0][m] = int(saida_corrigir_um[0][m])
                    
                    for i in range(len(novo_individuo)):
                        if novo_individuo[i] == saida_corrigir_um[0]:
                            saida_corrigir.append(i)
                else:
                    saida_corrigir.append(int(saida_corrigir_um[0]))
                    

                    
                        
                novo_individuo[ni+Ln+saida_atual] = copy.deepcopy(saida_corrigir[0])

            GENS_EVOL[individuo_saidas_a_processar[k]] = copy.deepcopy(copia_individuo_atual)

        array = copy.deepcopy(novo_individuo)
        anteriores = []
        for i in range(len(array)):
            atual = array[i]
            for j in range(len(array)):
                if array[j] == atual and i!=j:
                    novo_indice = i
                    indice_anterior = j
                    anteriores.append(indice_anterior)
                    for k in range(len(array)):
                        if k >= ni and k < Ln+ni and k > novo_indice and (novo_indice not in anteriores):
                            #print("k", k)
                            #print("array[k]", array[k])
                            if array[k][0] == indice_anterior:
                                array[k][0] = novo_indice
                            if array[k][1] == indice_anterior:
                                array[k][1] = novo_indice
        novo_individuo = copy.deepcopy(array)

        GENS_EVOL_ANTERIOR = []
        GENS_EVOL_ANTERIOR = copy.deepcopy(GENS_EVOL)        
        GENS_EVOL[0] = copy.deepcopy(novo_individuo)
        #LAMBDA_FILHOS.append(novo_individuo)
        SAM_ativo(0)
        #nos_ativos()                                                         
        FITNESS_EE_ANTERIOR = []
        FITNESS_EE_ANTERIOR = copy.deepcopy(FITNESS_EE)

        acumulador = 0
        for i in range(len(FITNESS_EE[0])):
            acumulador = acumulador + FITNESS_EE[0][i]
        melhor_antes = acumulador

        monta_tabela(0)
        acumulador2 = 0
        for i in range(len(FITNESS_EE[0])):
            acumulador2 = acumulador2 + FITNESS_EE[0][i]
        melhor_depois = acumulador2
        #print("melhor depois", melhor_depois)
        if melhor_depois < melhor_antes:
            print("AQUI")

        FITNESS_EE[0] = copy.deepcopy(fitness_final_novo_individuo)












def atualiza_pai_CROSSOVER_NOVO():
    arquivo_evolucao_aqui = open('evolucao.txt', 'a')
    arquivo_evolucao_aqui.write("\n --> PROCEDIMENTO DE CROSSOVER")
    fitness_saida = []
    for i in range(no):
        fitness_saida.append([])

    for i in range(no):
        for j in range(len(FITNESS_EE)):
            fitness_saida[i].append(FITNESS_EE[j][i])

    indice_melhores_saidas = []
    melhores_saidas = []

    for i in range(no):
        melhores_saidas.append([])

    for i in range(len(fitness_saida)):
        melhor = max(fitness_saida[i])
        for j in range(len(fitness_saida[i])):
            if fitness_saida[i][j] == melhor:
                melhores_saidas[i].append(j)

    todos_indices = []
    for i in range(len(melhores_saidas)):
        for j in range(len(melhores_saidas[i])):
            todos_indices.append(melhores_saidas[i][j])

    qtd_iguais = []
    for i in range(1 + ee_lambda):
        qtd_iguais.append(todos_indices.count(i))
        
        
    maiores_melhores_saidas = []
    for i in range(len(qtd_iguais)):
        if qtd_iguais[i] == max(qtd_iguais):
            maiores_melhores_saidas.append(i)
            
    INDIVIDUO_INICIAL = maiores_melhores_saidas[r.randint(0, len(maiores_melhores_saidas)-1)]

    
    saidas_individuo_inicial = []
    for i in range(len(melhores_saidas)):
        if INDIVIDUO_INICIAL in melhores_saidas[i]:
            saidas_individuo_inicial.append(i)

    saidas_a_processar = []
    for i in range(no):
        if i not in saidas_individuo_inicial:
            saidas_a_processar.append(i)


    individuo_saidas_a_processar = []
    for i in range(len(saidas_a_processar)):
        individuo_saidas_a_processar.append(melhores_saidas[saidas_a_processar[i]][r.randint(0, len(melhores_saidas[saidas_a_processar[i]])-1)])
        

    for i in range(len(melhores_saidas)):
        indice = r.randint(0, len(melhores_saidas[i])-1)
        indice_melhores_saidas.append(melhores_saidas[i][indice])

    novo_individuo = []
    individuo_inicial = []


    arquivo_evolucao_aqui.write("\n -INDIVIDUO INICIAL: " + str(INDIVIDUO_INICIAL))
    arquivo_evolucao_aqui.write("\n ->SAIDAS A PROCESSAR: " + str(saidas_a_processar))
    arquivo_evolucao_aqui.write("\n ->INDIVIDUO SAIDAS A PROCESSAR: " + str(individuo_saidas_a_processar))
    arquivo_evolucao_aqui.write("\n")
    arquivo_evolucao_aqui.write("\n")

    if len(saidas_a_processar) != 0:
        GLOBAL_QTD_CROSSOVER[0] += 1
        GLOBAL_QTD_CROSSOVER_SAIDA[0] += len(saidas_a_processar)

##PERFEITO ATÉ AQUI
# Determina a fitness do individuo final
    fitness_final_novo_individuo = []

    for i in range(len(fitness_saida)):
        fitness_final_novo_individuo.append(max(fitness_saida[i]))


##
    if 1 < 0:
        variavel = 0
    else:
        novo_individuo = copy.deepcopy(GENS_EVOL[INDIVIDUO_INICIAL])
        individuo_inicial.append(INDIVIDUO_INICIAL)
        gene_disponivel = []
        ###
        GENES_ATIVOS_MOM = []
        GENES_ATIVOS_MOM = copy.deepcopy(MEUARRAY[INDIVIDUO_INICIAL][0])
        for x in range(len(GENES_ATIVOS_MOM)):
            if GENES_ATIVOS_MOM[x] == "X":
                GENES_ATIVOS_MOM[x] = "-"
        ###


        for i in range(len(saidas_individuo_inicial)):
            for p in range(len(MEUARRAY[INDIVIDUO_INICIAL][saidas_individuo_inicial[i]])):
                if MEUARRAY[INDIVIDUO_INICIAL][saidas_individuo_inicial[i]][p] == "X":
                    GENES_ATIVOS_MOM[p] = "X"


        for i in range(len(GENES_ATIVOS_MOM)):
            if GENES_ATIVOS_MOM[i] != "X" and i >= ni and i < Ln+ni:
                gene_disponivel.append(i)
                
        
                                                               
        for k in range(len(saidas_a_processar)):
            saida_atual = saidas_a_processar[k]
            individuo_saida_atual = individuo_saidas_a_processar[k]
            copia_individuo_atual = copy.deepcopy(GENS_EVOL[individuo_saidas_a_processar[k]])

            if 1 < 0:

                novo_individuo = copy.deepcopy(GENS_EVOL[individuo_saida_atual])

            else:



                genes_saida_atual = []
                indice_genes_saida_atual = []
                for i in range(len(MEUARRAY[individuo_saida_atual][saida_atual])):
                    if MEUARRAY[individuo_saida_atual][saida_atual][i] == "X" and i >= ni and i < Ln+ni: ##Talvez essa condição i>= ni não faça sentido
                    
                        valor_a_ser_adicionado = copy.deepcopy(GENS_EVOL[individuo_saida_atual][i])
                        genes_saida_atual.append(valor_a_ser_adicionado)
                        indice_genes_saida_atual.append(i)


                saida_corrigir_um = []
                if len(genes_saida_atual) != 0:
                    saida_corrigir_um.append(genes_saida_atual[len(genes_saida_atual)-1])
                else:
                    saida_corrigir_um.append(GENS_EVOL[individuo_saida_atual][Ln+ni+saida_atual])


                ## ATÉ AQUI APARENTEMENTE OK

                while len(genes_saida_atual) != 0:

                    for i in range(len(indice_genes_saida_atual)):

                        if len(genes_saida_atual) == 1:

                            saida_corrigir_um[0] = copy.deepcopy(genes_saida_atual[0])
                      
                        gene_analisando = []
                        if len(genes_saida_atual) > 0:
                            for m in range(len(genes_saida_atual[0])):

                                gene_analisando.append(int(genes_saida_atual[0][m]))

                            if len(gene_disponivel) == 0:
                                print("--------------------------------------- FALTA ESPAÇO --------------------------------------")
                                exit()


                        if novo_individuo[indice_genes_saida_atual[i]] == gene_analisando:

                            genes_saida_atual.pop(0)
                            for v in range(len(gene_disponivel)):
                                if gene_disponivel[v] == indice_genes_saida_atual[i]:
                                    gene_disponivel.pop(v)
                                    break

                        else:
                            minha_condicao = True #aqui
                            for j in range(len(gene_disponivel)):
                                atual_indices_existentes = []
                                for h in range(len(gene_analisando)):
                                    if h < 2:
                                        atual_indices_existentes.append(gene_analisando[h])
                                        
                                atual_maior_indice_existente = max(atual_indices_existentes)
                                        
                                if gene_disponivel[j] > atual_maior_indice_existente:

                                    novo_individuo[gene_disponivel[j]] = copy.deepcopy(gene_analisando)



                                    novo_indice = gene_disponivel[j]

                                    genes_saida_atual.pop(0)

                                    gene_disponivel.pop(j)
                                    minha_condicao = False #aqui
                                    break
                                        
                                            
                            for w in range(len(genes_saida_atual)):
                                valor_procurado = indice_genes_saida_atual[i]
                                if genes_saida_atual[w][0] == valor_procurado:
                                    genes_saida_atual[w][0] = copy.deepcopy(str(novo_indice))
                                if genes_saida_atual[w][1] == valor_procurado:
                                    genes_saida_atual[w][1] = copy.deepcopy(str(novo_indice))
                                if saida_corrigir_um[0][0] == valor_procurado:
                                    saida_corrigir_um[0][0] = copy.deepcopy(str(novo_indice))
                                if saida_corrigir_um[0][1] == valor_procurado:
                                    saida_corrigir_um[0][1] = copy.deepcopy(str(novo_indice))
                            

                saida_corrigir = []
                if type(saida_corrigir_um[0]) == list:
                    for m in range(len(saida_corrigir_um[0])):
                        saida_corrigir_um[0][m] = int(saida_corrigir_um[0][m])
                    
                    for i in range(len(novo_individuo)):
                        if novo_individuo[i] == saida_corrigir_um[0]:
                            saida_corrigir.append(i)
                else:
                    saida_corrigir.append(int(saida_corrigir_um[0]))
                    

                    
                        
                novo_individuo[ni+Ln+saida_atual] = copy.deepcopy(saida_corrigir[0])

            GENS_EVOL[individuo_saidas_a_processar[k]] = copy.deepcopy(copia_individuo_atual)

        array = copy.deepcopy(novo_individuo)
        anteriores = []
        for i in range(len(array)):
            atual = array[i]
            for j in range(len(array)):
                if array[j] == atual and i!=j:
                    novo_indice = i
                    indice_anterior = j
                    anteriores.append(indice_anterior)
                    for k in range(len(array)):
                        if k >= ni and k < Ln+ni and k > novo_indice and (novo_indice not in anteriores):
                            #print("k", k)
                            #print("array[k]", array[k])
                            if array[k][0] == indice_anterior:
                                array[k][0] = novo_indice
                            if array[k][1] == indice_anterior:
                                array[k][1] = novo_indice
        novo_individuo = copy.deepcopy(array)

        GENS_EVOL_ANTERIOR = []
        GENS_EVOL_ANTERIOR = copy.deepcopy(GENS_EVOL)        
        GENS_EVOL[0] = copy.deepcopy(novo_individuo)
        #LAMBDA_FILHOS.append(novo_individuo)
        SAM_ativo(0)
        #nos_ativos()                                                         
        FITNESS_EE_ANTERIOR = []
        FITNESS_EE_ANTERIOR = copy.deepcopy(FITNESS_EE)
        #arquivo_evolucao_aqui.write("\n FITNESS_EE ANTERIOR: " + str(FITNESS_EE_ANTERIOR))
        
        acumulador = 0
        for i in range(len(FITNESS_EE[0])):
            acumulador = acumulador + FITNESS_EE[0][i]
        melhor_antes = acumulador

        monta_tabela(0)
        acumulador2 = 0
        for i in range(len(FITNESS_EE[0])):
            acumulador2 = acumulador2 + FITNESS_EE[0][i]
        melhor_depois = acumulador2
        #print("melhor depois", melhor_depois)
        if melhor_depois < melhor_antes:
            print("AQUI")

        FITNESS_EE[0] = copy.deepcopy(fitness_final_novo_individuo)

        #arquivo_evolucao_aqui.write("\n FITNESS_EE DEPOIS: " + str(FITNESS_EE))

        arquivo_evolucao_aqui.close()










def atualiza_pai_CROSSOVER_NOVO_MUX():
    arquivo_evolucao_aqui = open('evolucao.txt', 'a')
    arquivo_evolucao_aqui.write("\n --> PROCEDIMENTO DE CROSSOVER")
    fitness_saida = []
    for i in range(no):
        fitness_saida.append([])

    for i in range(no):
        for j in range(len(FITNESS_EE)):
            fitness_saida[i].append(FITNESS_EE[j][i])

    indice_melhores_saidas = []
    melhores_saidas = []

    for i in range(no):
        melhores_saidas.append([])

    for i in range(len(fitness_saida)):
        melhor = max(fitness_saida[i])
        for j in range(len(fitness_saida[i])):
            if fitness_saida[i][j] == melhor:
                melhores_saidas[i].append(j)

    todos_indices = []
    for i in range(len(melhores_saidas)):
        for j in range(len(melhores_saidas[i])):
            todos_indices.append(melhores_saidas[i][j])

    qtd_iguais = []
    for i in range(1 + ee_lambda):
        qtd_iguais.append(todos_indices.count(i))
        
        
    maiores_melhores_saidas = []
    for i in range(len(qtd_iguais)):
        if qtd_iguais[i] == max(qtd_iguais):
            maiores_melhores_saidas.append(i)
            
    INDIVIDUO_INICIAL = maiores_melhores_saidas[r.randint(0, len(maiores_melhores_saidas)-1)]

    
    saidas_individuo_inicial = []
    for i in range(len(melhores_saidas)):
        if INDIVIDUO_INICIAL in melhores_saidas[i]:
            saidas_individuo_inicial.append(i)

    saidas_a_processar = []
    for i in range(no):
        if i not in saidas_individuo_inicial:
            saidas_a_processar.append(i)


    individuo_saidas_a_processar = []
    for i in range(len(saidas_a_processar)):
        individuo_saidas_a_processar.append(melhores_saidas[saidas_a_processar[i]][r.randint(0, len(melhores_saidas[saidas_a_processar[i]])-1)])
        

    for i in range(len(melhores_saidas)):
        indice = r.randint(0, len(melhores_saidas[i])-1)
        indice_melhores_saidas.append(melhores_saidas[i][indice])

    novo_individuo = []
    individuo_inicial = []


    arquivo_evolucao_aqui.write("\n -INDIVIDUO INICIAL: " + str(INDIVIDUO_INICIAL))
    arquivo_evolucao_aqui.write("\n ->SAIDAS A PROCESSAR: " + str(saidas_a_processar))
    arquivo_evolucao_aqui.write("\n ->INDIVIDUO SAIDAS A PROCESSAR: " + str(individuo_saidas_a_processar))
    arquivo_evolucao_aqui.write("\n")
    arquivo_evolucao_aqui.write("\n")

    if len(saidas_a_processar) != 0:
        GLOBAL_QTD_CROSSOVER[0] += 1
        GLOBAL_QTD_CROSSOVER_SAIDA[0] += len(saidas_a_processar)

##PERFEITO ATÉ AQUI
# Determina a fitness do individuo final
    fitness_final_novo_individuo = []

    for i in range(len(fitness_saida)):
        fitness_final_novo_individuo.append(max(fitness_saida[i]))


##
    if 1 < 0:
        variavel = 0
    else:
        novo_individuo = copy.deepcopy(GENS_EVOL[INDIVIDUO_INICIAL])
        individuo_inicial.append(INDIVIDUO_INICIAL)
        gene_disponivel = []
        ###
        GENES_ATIVOS_MOM = []
        GENES_ATIVOS_MOM = copy.deepcopy(MEUARRAY[INDIVIDUO_INICIAL][0])
        for x in range(len(GENES_ATIVOS_MOM)):
            if GENES_ATIVOS_MOM[x] == "X":
                GENES_ATIVOS_MOM[x] = "-"
        ###


        for i in range(len(saidas_individuo_inicial)):
            for p in range(len(MEUARRAY[INDIVIDUO_INICIAL][saidas_individuo_inicial[i]])):
                if MEUARRAY[INDIVIDUO_INICIAL][saidas_individuo_inicial[i]][p] == "X":
                    GENES_ATIVOS_MOM[p] = "X"


        for i in range(len(GENES_ATIVOS_MOM)):
            if GENES_ATIVOS_MOM[i] != "X" and i >= ni and i < Ln+ni:
                gene_disponivel.append(i)
                
        
                                                               
        for k in range(len(saidas_a_processar)):
            saida_atual = saidas_a_processar[k]
            individuo_saida_atual = individuo_saidas_a_processar[k]
            copia_individuo_atual = copy.deepcopy(GENS_EVOL[individuo_saidas_a_processar[k]])

            if 1 < 0:

                novo_individuo = copy.deepcopy(GENS_EVOL[individuo_saida_atual])

            else:



                genes_saida_atual = []
                indice_genes_saida_atual = []
                for i in range(len(MEUARRAY[individuo_saida_atual][saida_atual])):
                    if MEUARRAY[individuo_saida_atual][saida_atual][i] == "X" and i >= ni and i < Ln+ni: ##Talvez essa condição i>= ni não faça sentido
                    
                        valor_a_ser_adicionado = copy.deepcopy(GENS_EVOL[individuo_saida_atual][i])
                        genes_saida_atual.append(valor_a_ser_adicionado)
                        indice_genes_saida_atual.append(i)


                saida_corrigir_um = []
                if len(genes_saida_atual) != 0:
                    saida_corrigir_um.append(genes_saida_atual[len(genes_saida_atual)-1])
                else:
                    saida_corrigir_um.append(GENS_EVOL[individuo_saida_atual][Ln+ni+saida_atual])


                ## ATÉ AQUI APARENTEMENTE OK

                while len(genes_saida_atual) != 0:

                    for i in range(len(indice_genes_saida_atual)):

                        if len(genes_saida_atual) == 1:

                            saida_corrigir_um[0] = copy.deepcopy(genes_saida_atual[0])
                      
                        gene_analisando = []
                        if len(genes_saida_atual) > 0:
                            for m in range(len(genes_saida_atual[0])):

                                gene_analisando.append(int(genes_saida_atual[0][m]))

                            if len(gene_disponivel) == 0:
                                print("--------------------------------------- FALTA ESPAÇO --------------------------------------")
                                exit()


                        if novo_individuo[indice_genes_saida_atual[i]] == gene_analisando:

                            genes_saida_atual.pop(0)
                            for v in range(len(gene_disponivel)):
                                if gene_disponivel[v] == indice_genes_saida_atual[i]:
                                    gene_disponivel.pop(v)
                                    break

                        else:
                            minha_condicao = True #aqui
                            for j in range(len(gene_disponivel)):
                                atual_indices_existentes = []
                                for h in range(len(gene_analisando)):
                                    if h < 2 or h == 3:
                                        atual_indices_existentes.append(gene_analisando[h])
                                        
                                atual_maior_indice_existente = max(atual_indices_existentes)
                                        
                                if gene_disponivel[j] > atual_maior_indice_existente:

                                    novo_individuo[gene_disponivel[j]] = copy.deepcopy(gene_analisando)



                                    novo_indice = gene_disponivel[j]

                                    genes_saida_atual.pop(0)

                                    gene_disponivel.pop(j)
                                    minha_condicao = False #aqui
                                    break
                                        
                                            
                            for w in range(len(genes_saida_atual)):
                                valor_procurado = indice_genes_saida_atual[i]
                                if genes_saida_atual[w][0] == valor_procurado:
                                    genes_saida_atual[w][0] = copy.deepcopy(str(novo_indice))
                                if genes_saida_atual[w][1] == valor_procurado:
                                    genes_saida_atual[w][1] = copy.deepcopy(str(novo_indice))
                                if genes_saida_atual[w][3] == valor_procurado:
                                    genes_saida_atual[w][3] = copy.deepcopy(str(novo_indice))
                                if saida_corrigir_um[0][0] == valor_procurado:
                                    saida_corrigir_um[0][0] = copy.deepcopy(str(novo_indice))
                                if saida_corrigir_um[0][1] == valor_procurado:
                                    saida_corrigir_um[0][1] = copy.deepcopy(str(novo_indice))
                                if saida_corrigir_um[0][3] == valor_procurado:
                                    saida_corrigir_um[0][3] = copy.deepcopy(str(novo_indice))
                            

                saida_corrigir = []
                if type(saida_corrigir_um[0]) == list:
                    for m in range(len(saida_corrigir_um[0])):
                        saida_corrigir_um[0][m] = int(saida_corrigir_um[0][m])
                    
                    for i in range(len(novo_individuo)):
                        if novo_individuo[i] == saida_corrigir_um[0]:
                            saida_corrigir.append(i)
                else:
                    saida_corrigir.append(int(saida_corrigir_um[0]))
                    

                    
                        
                novo_individuo[ni+Ln+saida_atual] = copy.deepcopy(saida_corrigir[0])

            GENS_EVOL[individuo_saidas_a_processar[k]] = copy.deepcopy(copia_individuo_atual)

        array = copy.deepcopy(novo_individuo)
        anteriores = []
        for i in range(len(array)):
            atual = array[i]
            for j in range(len(array)):
                if array[j] == atual and i!=j:
                    novo_indice = i
                    indice_anterior = j
                    anteriores.append(indice_anterior)
                    for k in range(len(array)):
                        if k >= ni and k < Ln+ni and k > novo_indice and (novo_indice not in anteriores):
                            #print("k", k)
                            #print("array[k]", array[k])
                            if array[k][0] == indice_anterior:
                                array[k][0] = novo_indice
                            if array[k][1] == indice_anterior:
                                array[k][1] = novo_indice
                            if array[k][3] == indice_anterior:
                                array[k][3] = novo_indice
        novo_individuo = copy.deepcopy(array)

        GENS_EVOL_ANTERIOR = []
        GENS_EVOL_ANTERIOR = copy.deepcopy(GENS_EVOL)        
        GENS_EVOL[0] = copy.deepcopy(novo_individuo)
        #LAMBDA_FILHOS.append(novo_individuo)
        SAM_ativo_mux(0)
        #nos_ativos()                                                         
        FITNESS_EE_ANTERIOR = []
        FITNESS_EE_ANTERIOR = copy.deepcopy(FITNESS_EE)
        #arquivo_evolucao_aqui.write("\n FITNESS_EE ANTERIOR: " + str(FITNESS_EE_ANTERIOR))
        
        acumulador = 0
        for i in range(len(FITNESS_EE[0])):
            acumulador = acumulador + FITNESS_EE[0][i]
        melhor_antes = acumulador

        monta_tabela_mux(0)
        acumulador2 = 0
        for i in range(len(FITNESS_EE[0])):
            acumulador2 = acumulador2 + FITNESS_EE[0][i]
        melhor_depois = acumulador2
        #print("melhor depois", melhor_depois)
        if melhor_depois < melhor_antes:
            print("AQUI")

        FITNESS_EE[0] = copy.deepcopy(fitness_final_novo_individuo)

        #arquivo_evolucao_aqui.write("\n FITNESS_EE DEPOIS: " + str(FITNESS_EE))

        arquivo_evolucao_aqui.close()




def atualiza_pai_CROSSOVER_NOVO_MUX_PORTA():
    arquivo_evolucao_aqui = open('evolucao.txt', 'a')
    arquivo_evolucao_aqui.write("\n --> PROCEDIMENTO DE CROSSOVER")
    fitness_saida = []
    for i in range(no):
        fitness_saida.append([])

    for i in range(no):
        for j in range(len(FITNESS_EE)):
            fitness_saida[i].append(FITNESS_EE[j][i])

    indice_melhores_saidas = []
    melhores_saidas = []

    for i in range(no):
        melhores_saidas.append([])

    for i in range(len(fitness_saida)):
        melhor = max(fitness_saida[i])
        for j in range(len(fitness_saida[i])):
            if fitness_saida[i][j] == melhor:
                melhores_saidas[i].append(j)

    todos_indices = []
    for i in range(len(melhores_saidas)):
        for j in range(len(melhores_saidas[i])):
            todos_indices.append(melhores_saidas[i][j])

    qtd_iguais = []
    for i in range(1 + ee_lambda):
        qtd_iguais.append(todos_indices.count(i))
        
        
    maiores_melhores_saidas = []
    for i in range(len(qtd_iguais)):
        if qtd_iguais[i] == max(qtd_iguais):
            maiores_melhores_saidas.append(i)
            
    INDIVIDUO_INICIAL = maiores_melhores_saidas[r.randint(0, len(maiores_melhores_saidas)-1)]

    
    saidas_individuo_inicial = []
    for i in range(len(melhores_saidas)):
        if INDIVIDUO_INICIAL in melhores_saidas[i]:
            saidas_individuo_inicial.append(i)

    saidas_a_processar = []
    for i in range(no):
        if i not in saidas_individuo_inicial:
            saidas_a_processar.append(i)


    individuo_saidas_a_processar = []
    for i in range(len(saidas_a_processar)):
        individuo_saidas_a_processar.append(melhores_saidas[saidas_a_processar[i]][r.randint(0, len(melhores_saidas[saidas_a_processar[i]])-1)])
        

    for i in range(len(melhores_saidas)):
        indice = r.randint(0, len(melhores_saidas[i])-1)
        indice_melhores_saidas.append(melhores_saidas[i][indice])

    novo_individuo = []
    individuo_inicial = []


    arquivo_evolucao_aqui.write("\n -INDIVIDUO INICIAL: " + str(INDIVIDUO_INICIAL))
    arquivo_evolucao_aqui.write("\n ->SAIDAS A PROCESSAR: " + str(saidas_a_processar))
    arquivo_evolucao_aqui.write("\n ->INDIVIDUO SAIDAS A PROCESSAR: " + str(individuo_saidas_a_processar))
    arquivo_evolucao_aqui.write("\n")
    arquivo_evolucao_aqui.write("\n")

    if len(saidas_a_processar) != 0:
        GLOBAL_QTD_CROSSOVER[0] += 1
        GLOBAL_QTD_CROSSOVER_SAIDA[0] += len(saidas_a_processar)

##PERFEITO ATÉ AQUI
# Determina a fitness do individuo final
    fitness_final_novo_individuo = []

    for i in range(len(fitness_saida)):
        fitness_final_novo_individuo.append(max(fitness_saida[i]))


##
    if 1 < 0:
        variavel = 0
    else:
        novo_individuo = copy.deepcopy(GENS_EVOL[INDIVIDUO_INICIAL])
        individuo_inicial.append(INDIVIDUO_INICIAL)
        gene_disponivel = []
        ###
        GENES_ATIVOS_MOM = []
        GENES_ATIVOS_MOM = copy.deepcopy(MEUARRAY[INDIVIDUO_INICIAL][0])
        for x in range(len(GENES_ATIVOS_MOM)):
            if GENES_ATIVOS_MOM[x] == "X":
                GENES_ATIVOS_MOM[x] = "-"
        ###


        for i in range(len(saidas_individuo_inicial)):
            for p in range(len(MEUARRAY[INDIVIDUO_INICIAL][saidas_individuo_inicial[i]])):
                if MEUARRAY[INDIVIDUO_INICIAL][saidas_individuo_inicial[i]][p] == "X":
                    GENES_ATIVOS_MOM[p] = "X"


        for i in range(len(GENES_ATIVOS_MOM)):
            if GENES_ATIVOS_MOM[i] != "X" and i >= ni and i < Ln+ni:
                gene_disponivel.append(i)
                
        
                                                               
        for k in range(len(saidas_a_processar)):
            saida_atual = saidas_a_processar[k]
            individuo_saida_atual = individuo_saidas_a_processar[k]
            copia_individuo_atual = copy.deepcopy(GENS_EVOL[individuo_saidas_a_processar[k]])

            if 1 < 0:

                novo_individuo = copy.deepcopy(GENS_EVOL[individuo_saida_atual])

            else:



                genes_saida_atual = []
                indice_genes_saida_atual = []
                for i in range(len(MEUARRAY[individuo_saida_atual][saida_atual])):
                    if MEUARRAY[individuo_saida_atual][saida_atual][i] == "X" and i >= ni and i < Ln+ni: ##Talvez essa condição i>= ni não faça sentido
                    
                        valor_a_ser_adicionado = copy.deepcopy(GENS_EVOL[individuo_saida_atual][i])
                        genes_saida_atual.append(valor_a_ser_adicionado)
                        indice_genes_saida_atual.append(i)


                saida_corrigir_um = []
                if len(genes_saida_atual) != 0:
                    saida_corrigir_um.append(genes_saida_atual[len(genes_saida_atual)-1])
                else:
                    saida_corrigir_um.append(GENS_EVOL[individuo_saida_atual][Ln+ni+saida_atual])


                ## ATÉ AQUI APARENTEMENTE OK

                while len(genes_saida_atual) != 0:

                    for i in range(len(indice_genes_saida_atual)):

                        if len(genes_saida_atual) == 1:

                            saida_corrigir_um[0] = copy.deepcopy(genes_saida_atual[0])
                      
                        gene_analisando = []
                        if len(genes_saida_atual) > 0:
                            for m in range(len(genes_saida_atual[0])):

                                gene_analisando.append(int(genes_saida_atual[0][m]))

                            if len(gene_disponivel) == 0:
                                print("--------------------------------------- FALTA ESPAÇO --------------------------------------")
                                exit()


                        if novo_individuo[indice_genes_saida_atual[i]] == gene_analisando:

                            genes_saida_atual.pop(0)
                            for v in range(len(gene_disponivel)):
                                if gene_disponivel[v] == indice_genes_saida_atual[i]:
                                    gene_disponivel.pop(v)
                                    break

                        else:
                            minha_condicao = True #aqui
                            for j in range(len(gene_disponivel)):
                                atual_indices_existentes = []
                                for h in range(len(gene_analisando)):
                                    if h < 2 or h == 3:
                                        atual_indices_existentes.append(gene_analisando[h])
                                        
                                atual_maior_indice_existente = max(atual_indices_existentes)
                                        
                                if gene_disponivel[j] > atual_maior_indice_existente:

                                    novo_individuo[gene_disponivel[j]] = copy.deepcopy(gene_analisando)



                                    novo_indice = gene_disponivel[j]

                                    genes_saida_atual.pop(0)

                                    gene_disponivel.pop(j)
                                    minha_condicao = False #aqui
                                    break
                                        
                                            
                            for w in range(len(genes_saida_atual)):
                                valor_procurado = indice_genes_saida_atual[i]
                                if genes_saida_atual[w][0] == valor_procurado:
                                    genes_saida_atual[w][0] = copy.deepcopy(str(novo_indice))
                                if genes_saida_atual[w][1] == valor_procurado:
                                    genes_saida_atual[w][1] = copy.deepcopy(str(novo_indice))
                                if genes_saida_atual[w][3] == valor_procurado:
                                    genes_saida_atual[w][3] = copy.deepcopy(str(novo_indice))
                                if saida_corrigir_um[0][0] == valor_procurado:
                                    saida_corrigir_um[0][0] = copy.deepcopy(str(novo_indice))
                                if saida_corrigir_um[0][1] == valor_procurado:
                                    saida_corrigir_um[0][1] = copy.deepcopy(str(novo_indice))
                                if saida_corrigir_um[0][3] == valor_procurado:
                                    saida_corrigir_um[0][3] = copy.deepcopy(str(novo_indice))
                            

                saida_corrigir = []
                if type(saida_corrigir_um[0]) == list:
                    for m in range(len(saida_corrigir_um[0])):
                        saida_corrigir_um[0][m] = int(saida_corrigir_um[0][m])
                    
                    for i in range(len(novo_individuo)):
                        if novo_individuo[i] == saida_corrigir_um[0]:
                            saida_corrigir.append(i)
                else:
                    saida_corrigir.append(int(saida_corrigir_um[0]))
                    

                    
                        
                novo_individuo[ni+Ln+saida_atual] = copy.deepcopy(saida_corrigir[0])

            GENS_EVOL[individuo_saidas_a_processar[k]] = copy.deepcopy(copia_individuo_atual)

        array = copy.deepcopy(novo_individuo)
        anteriores = []
        for i in range(len(array)):
            atual = array[i]
            for j in range(len(array)):
                if array[j] == atual and i!=j:
                    novo_indice = i
                    indice_anterior = j
                    anteriores.append(indice_anterior)
                    for k in range(len(array)):
                        if k >= ni and k < Ln+ni and k > novo_indice and (novo_indice not in anteriores):
                            #print("k", k)
                            #print("array[k]", array[k])
                            if array[k][0] == indice_anterior:
                                array[k][0] = novo_indice
                            if array[k][1] == indice_anterior:
                                array[k][1] = novo_indice
                            if array[k][3] == indice_anterior:
                                array[k][3] = novo_indice
        novo_individuo = copy.deepcopy(array)

        GENS_EVOL_ANTERIOR = []
        GENS_EVOL_ANTERIOR = copy.deepcopy(GENS_EVOL)        
        GENS_EVOL[0] = copy.deepcopy(novo_individuo)
        #LAMBDA_FILHOS.append(novo_individuo)
        SAM_ativo_mux(0)
        #nos_ativos()                                                         
        FITNESS_EE_ANTERIOR = []
        FITNESS_EE_ANTERIOR = copy.deepcopy(FITNESS_EE)
        #arquivo_evolucao_aqui.write("\n FITNESS_EE ANTERIOR: " + str(FITNESS_EE_ANTERIOR))
        
        acumulador = 0
        for i in range(len(FITNESS_EE[0])):
            acumulador = acumulador + FITNESS_EE[0][i]
        melhor_antes = acumulador

        monta_tabela_mux_porta(0)
        acumulador2 = 0
        for i in range(len(FITNESS_EE[0])):
            acumulador2 = acumulador2 + FITNESS_EE[0][i]
        melhor_depois = acumulador2
        #print("melhor depois", melhor_depois)
        if melhor_depois < melhor_antes:
            print("AQUI")

        FITNESS_EE[0] = copy.deepcopy(fitness_final_novo_individuo)

        #arquivo_evolucao_aqui.write("\n FITNESS_EE DEPOIS: " + str(FITNESS_EE))

        arquivo_evolucao_aqui.close()




def atualiza_pai_CROSSOVER_NOVO_MUX2():
    arquivo_evolucao_aqui = open('evolucao.txt', 'a')
    arquivo_evolucao_aqui.write("\n --> PROCEDIMENTO DE CROSSOVER")
    fitness_saida = []
    for i in range(no):
        fitness_saida.append([])

    for i in range(no):
        for j in range(len(FITNESS_EE)):
            fitness_saida[i].append(FITNESS_EE[j][i])

    indice_melhores_saidas = []
    melhores_saidas = []

    for i in range(no):
        melhores_saidas.append([])

    for i in range(len(fitness_saida)):
        melhor = max(fitness_saida[i])
        for j in range(len(fitness_saida[i])):
            if fitness_saida[i][j] == melhor:
                melhores_saidas[i].append(j)

    todos_indices = []
    for i in range(len(melhores_saidas)):
        for j in range(len(melhores_saidas[i])):
            todos_indices.append(melhores_saidas[i][j])

    qtd_iguais = []
    for i in range(1 + ee_lambda):
        qtd_iguais.append(todos_indices.count(i))
        
        
    maiores_melhores_saidas = []
    for i in range(len(qtd_iguais)):
        if qtd_iguais[i] == max(qtd_iguais):
            maiores_melhores_saidas.append(i)
            
    INDIVIDUO_INICIAL = maiores_melhores_saidas[r.randint(0, len(maiores_melhores_saidas)-1)]

    
    saidas_individuo_inicial = []
    for i in range(len(melhores_saidas)):
        if INDIVIDUO_INICIAL in melhores_saidas[i]:
            saidas_individuo_inicial.append(i)

    saidas_a_processar = []
    for i in range(no):
        if i not in saidas_individuo_inicial:
            saidas_a_processar.append(i)


    individuo_saidas_a_processar = []
    for i in range(len(saidas_a_processar)):
        individuo_saidas_a_processar.append(melhores_saidas[saidas_a_processar[i]][r.randint(0, len(melhores_saidas[saidas_a_processar[i]])-1)])
        

    for i in range(len(melhores_saidas)):
        indice = r.randint(0, len(melhores_saidas[i])-1)
        indice_melhores_saidas.append(melhores_saidas[i][indice])

    novo_individuo = []
    individuo_inicial = []


    arquivo_evolucao_aqui.write("\n -INDIVIDUO INICIAL: " + str(INDIVIDUO_INICIAL))
    arquivo_evolucao_aqui.write("\n ->SAIDAS A PROCESSAR: " + str(saidas_a_processar))
    arquivo_evolucao_aqui.write("\n ->INDIVIDUO SAIDAS A PROCESSAR: " + str(individuo_saidas_a_processar))
    arquivo_evolucao_aqui.write("\n")
    arquivo_evolucao_aqui.write("\n")

    if len(saidas_a_processar) != 0:
        GLOBAL_QTD_CROSSOVER[0] += 1
        GLOBAL_QTD_CROSSOVER_SAIDA[0] += len(saidas_a_processar)

##PERFEITO ATÉ AQUI
# Determina a fitness do individuo final
    fitness_final_novo_individuo = []

    for i in range(len(fitness_saida)):
        fitness_final_novo_individuo.append(max(fitness_saida[i]))


##
    if 1 < 0:
        variavel = 0
    else:
        novo_individuo = copy.deepcopy(GENS_EVOL[INDIVIDUO_INICIAL])
        individuo_inicial.append(INDIVIDUO_INICIAL)
        gene_disponivel = []
        ###
        GENES_ATIVOS_MOM = []
        GENES_ATIVOS_MOM = copy.deepcopy(MEUARRAY[INDIVIDUO_INICIAL][0])
        for x in range(len(GENES_ATIVOS_MOM)):
            if GENES_ATIVOS_MOM[x] == "X":
                GENES_ATIVOS_MOM[x] = "-"
        ###


        for i in range(len(saidas_individuo_inicial)):
            for p in range(len(MEUARRAY[INDIVIDUO_INICIAL][saidas_individuo_inicial[i]])):
                if MEUARRAY[INDIVIDUO_INICIAL][saidas_individuo_inicial[i]][p] == "X":
                    GENES_ATIVOS_MOM[p] = "X"


        for i in range(len(GENES_ATIVOS_MOM)):
            if GENES_ATIVOS_MOM[i] != "X" and i >= ni and i < Ln+ni:
                gene_disponivel.append(i)
                
        
                                                               
        for k in range(len(saidas_a_processar)):
            saida_atual = saidas_a_processar[k]
            individuo_saida_atual = individuo_saidas_a_processar[k]
            copia_individuo_atual = copy.deepcopy(GENS_EVOL[individuo_saidas_a_processar[k]])

            if 1 < 0:

                novo_individuo = copy.deepcopy(GENS_EVOL[individuo_saida_atual])

            else:



                genes_saida_atual = []
                indice_genes_saida_atual = []
                for i in range(len(MEUARRAY[individuo_saida_atual][saida_atual])):
                    if MEUARRAY[individuo_saida_atual][saida_atual][i] == "X" and i >= ni and i < Ln+ni: ##Talvez essa condição i>= ni não faça sentido
                    
                        valor_a_ser_adicionado = copy.deepcopy(GENS_EVOL[individuo_saida_atual][i])
                        genes_saida_atual.append(valor_a_ser_adicionado)
                        indice_genes_saida_atual.append(i)


                saida_corrigir_um = []
                if len(genes_saida_atual) != 0:
                    saida_corrigir_um.append(genes_saida_atual[len(genes_saida_atual)-1])
                else:
                    saida_corrigir_um.append(GENS_EVOL[individuo_saida_atual][Ln+ni+saida_atual])


                ## ATÉ AQUI APARENTEMENTE OK

                while len(genes_saida_atual) != 0:

                    for i in range(len(indice_genes_saida_atual)):

                        if len(genes_saida_atual) == 1:

                            saida_corrigir_um[0] = copy.deepcopy(genes_saida_atual[0])
                      
                        gene_analisando = []
                        if len(genes_saida_atual) > 0:
                            for m in range(len(genes_saida_atual[0])):

                                gene_analisando.append(int(genes_saida_atual[0][m]))

                            if len(gene_disponivel) == 0:
                                print("--------------------------------------- FALTA ESPAÇO --------------------------------------")
                                exit()


                        if novo_individuo[indice_genes_saida_atual[i]] == gene_analisando:

                            genes_saida_atual.pop(0)
                            for v in range(len(gene_disponivel)):
                                if gene_disponivel[v] == indice_genes_saida_atual[i]:
                                    gene_disponivel.pop(v)
                                    break

                        else:
                            minha_condicao = True #aqui
                            for j in range(len(gene_disponivel)):
                                atual_indices_existentes = []
                                for h in range(len(gene_analisando)):
                                    if h < 2 or h == 3:
                                        atual_indices_existentes.append(gene_analisando[h])
                                        
                                atual_maior_indice_existente = max(atual_indices_existentes)
                                        
                                if gene_disponivel[j] > atual_maior_indice_existente:

                                    novo_individuo[gene_disponivel[j]] = copy.deepcopy(gene_analisando)



                                    novo_indice = gene_disponivel[j]

                                    genes_saida_atual.pop(0)

                                    gene_disponivel.pop(j)
                                    minha_condicao = False #aqui
                                    break
                                        
                                            
                            for w in range(len(genes_saida_atual)):
                                valor_procurado = indice_genes_saida_atual[i]
                                if genes_saida_atual[w][0] == valor_procurado:
                                    genes_saida_atual[w][0] = copy.deepcopy(str(novo_indice))
                                if genes_saida_atual[w][1] == valor_procurado:
                                    genes_saida_atual[w][1] = copy.deepcopy(str(novo_indice))
                                if genes_saida_atual[w][3] == valor_procurado:
                                    genes_saida_atual[w][3] = copy.deepcopy(str(novo_indice))
                                if saida_corrigir_um[0][0] == valor_procurado:
                                    saida_corrigir_um[0][0] = copy.deepcopy(str(novo_indice))
                                if saida_corrigir_um[0][1] == valor_procurado:
                                    saida_corrigir_um[0][1] = copy.deepcopy(str(novo_indice))
                                if saida_corrigir_um[0][3] == valor_procurado:
                                    saida_corrigir_um[0][3] = copy.deepcopy(str(novo_indice))
                            

                saida_corrigir = []
                if type(saida_corrigir_um[0]) == list:
                    for m in range(len(saida_corrigir_um[0])):
                        saida_corrigir_um[0][m] = int(saida_corrigir_um[0][m])
                    
                    for i in range(len(novo_individuo)):
                        if novo_individuo[i] == saida_corrigir_um[0]:
                            saida_corrigir.append(i)
                else:
                    saida_corrigir.append(int(saida_corrigir_um[0]))
                    

                    
                        
                novo_individuo[ni+Ln+saida_atual] = copy.deepcopy(saida_corrigir[0])

            GENS_EVOL[individuo_saidas_a_processar[k]] = copy.deepcopy(copia_individuo_atual)

        array = copy.deepcopy(novo_individuo)
        anteriores = []
        for i in range(len(array)):
            atual = array[i]
            for j in range(len(array)):
                if array[j] == atual and i!=j:
                    novo_indice = i
                    indice_anterior = j
                    anteriores.append(indice_anterior)
                    for k in range(len(array)):
                        if k >= ni and k < Ln+ni and k > novo_indice and (novo_indice not in anteriores):
                            #print("k", k)
                            #print("array[k]", array[k])
                            if array[k][0] == indice_anterior:
                                array[k][0] = novo_indice
                            if array[k][1] == indice_anterior:
                                array[k][1] = novo_indice
                            if array[k][3] == indice_anterior:
                                array[k][3] = novo_indice
        novo_individuo = copy.deepcopy(array)

        GENS_EVOL_ANTERIOR = []
        GENS_EVOL_ANTERIOR = copy.deepcopy(GENS_EVOL)        
        GENS_EVOL[0] = copy.deepcopy(novo_individuo)
        #LAMBDA_FILHOS.append(novo_individuo)
        SAM_ativo_mux(0)
        #nos_ativos()                                                         
        FITNESS_EE_ANTERIOR = []
        FITNESS_EE_ANTERIOR = copy.deepcopy(FITNESS_EE)
        #arquivo_evolucao_aqui.write("\n FITNESS_EE ANTERIOR: " + str(FITNESS_EE_ANTERIOR))
        
        acumulador = 0
        for i in range(len(FITNESS_EE[0])):
            acumulador = acumulador + FITNESS_EE[0][i]
        melhor_antes = acumulador

        monta_tabela_mux2(0)
        acumulador2 = 0
        for i in range(len(FITNESS_EE[0])):
            acumulador2 = acumulador2 + FITNESS_EE[0][i]
        melhor_depois = acumulador2
        #print("melhor depois", melhor_depois)
        if melhor_depois < melhor_antes:
            print("AQUI")

        FITNESS_EE[0] = copy.deepcopy(fitness_final_novo_individuo)

        #arquivo_evolucao_aqui.write("\n FITNESS_EE DEPOIS: " + str(FITNESS_EE))

        arquivo_evolucao_aqui.close()



def atualiza_pai_CROSSOVER():

    fitness_saida = []
    for i in range(no):
        fitness_saida.append([])

    for i in range(no):
        for j in range(len(FITNESS_EE)):
            fitness_saida[i].append(FITNESS_EE[j][i])

    indice_melhores_saidas = []
    melhores_saidas = []

    for i in range(no):
        melhores_saidas.append([])

    for i in range(len(fitness_saida)):
        melhor = max(fitness_saida[i])
        for j in range(len(fitness_saida[i])):
            if fitness_saida[i][j] == melhor:
                melhores_saidas[i].append(j)

    todos_indices = []
    for i in range(len(melhores_saidas)):
        for j in range(len(melhores_saidas[i])):
            todos_indices.append(melhores_saidas[i][j])

    qtd_iguais = []
    for i in range(ee_mu_pop + ee_lambda_pop):
        qtd_iguais.append(todos_indices.count(i))

        
    maiores_melhores_saidas = []
    for i in range(len(qtd_iguais)):
        if qtd_iguais[i] == max(qtd_iguais):
            maiores_melhores_saidas.append(i)
            
    INDIVIDUO_INICIAL = maiores_melhores_saidas[r.randint(0, len(maiores_melhores_saidas)-1)]
    saidas_individuo_inicial = []
    for i in range(len(melhores_saidas)):
        if INDIVIDUO_INICIAL in melhores_saidas[i]:
            saidas_individuo_inicial.append(i)

    saidas_a_processar = []
    for i in range(no):
        if i not in saidas_individuo_inicial:
            saidas_a_processar.append(i)

    individuo_saidas_a_processar = []
    for i in range(len(saidas_a_processar)):
        individuo_saidas_a_processar.append(melhores_saidas[saidas_a_processar[i]][r.randint(0, len(melhores_saidas[saidas_a_processar[i]])-1)])
        


    for i in range(len(melhores_saidas)):
        indice = r.randint(0, len(melhores_saidas[i])-1)
        indice_melhores_saidas.append(melhores_saidas[i][indice])

    novo_individuo = []
    individuo_inicial = []



    if 1 < 0:
        variavel = 0
    else:
        novo_individuo = copy.deepcopy(GENS_EVOL[INDIVIDUO_INICIAL])
        individuo_inicial.append(INDIVIDUO_INICIAL)
        gene_disponivel = []
        for i in range(len(saidas_individuo_inicial)):
            if i == 0:
                MEUARRAY[INDIVIDUO_INICIAL][0] = copy.deepcopy(MEUARRAY[INDIVIDUO_INICIAL][saidas_individuo_inicial[i]])
            else:
                for p in range(len(MEUARRAY[INDIVIDUO_INICIAL][saidas_individuo_inicial[i]])):
                    if MEUARRAY[INDIVIDUO_INICIAL][saidas_individuo_inicial[i]][p] == "X":
                        MEUARRAY[INDIVIDUO_INICIAL][0][p] = "X"
                                                               
        for i in range(len(MEUARRAY[INDIVIDUO_INICIAL][0])):
            if MEUARRAY[INDIVIDUO_INICIAL][0][i] != "X" and i >= ni and i < Ln+ni:
                gene_disponivel.append(i)
        for k in range(len(saidas_a_processar)):
            saida_atual = saidas_a_processar[k]
            individuo_saida_atual = individuo_saidas_a_processar[k]
            copia_individuo_atual = copy.deepcopy(GENS_EVOL[individuo_saidas_a_processar[k]])

            if 1 < 0:

                novo_individuo = copy.deepcopy(GENS_EVOL[individuo_saida_atual])
                individuo_inicial.append(indice_melhores_saidas[k])
                
                gene_disponivel = []
                for i in range(len(MEUARRAY[individuo_inicial[0]][0])):
                    if MEUARRAY[individuo_inicial[0]][0][i] != "X" and i >= ni and i < Ln+ni:
                        gene_disponivel.append(i)
            else:



                genes_saida_atual = []
                indice_genes_saida_atual = []
                for i in range(len(MEUARRAY[individuo_saida_atual][saida_atual])):
                    if MEUARRAY[individuo_saida_atual][saida_atual][i] == "X" and i >= ni and i < Ln+ni:
                        genes_saida_atual.append(GENS_EVOL[individuo_saida_atual][i])
                        indice_genes_saida_atual.append(i)


                saida_corrigir_um = []
                if len(genes_saida_atual) != 0:
                    saida_corrigir_um.append(genes_saida_atual[len(genes_saida_atual)-1])
                else:
                    saida_corrigir_um.append(GENS_EVOL[individuo_saida_atual][Ln+ni+saida_atual])




                while len(genes_saida_atual) != 0:
                    for i in range(len(indice_genes_saida_atual)):

                        gene_analisando = []
                        if len(genes_saida_atual) > 0:
                            for m in range(len(genes_saida_atual[0])):

                                gene_analisando.append(int(genes_saida_atual[0][m]))

                            if len(gene_disponivel) == 0:
                                print("--------------------------------------- FALTA ESPAÇO --------------------------------------")
                                exit()


                        if novo_individuo[indice_genes_saida_atual[i]] == gene_analisando:

                            genes_saida_atual.pop(0)
                            for v in range(len(gene_disponivel)):
                                if gene_disponivel[v] == indice_genes_saida_atual[i]:
                                    gene_disponivel.pop(v)
                                    break

                        else:

                            for j in range(len(gene_disponivel)):
                                if gene_disponivel[j] >= indice_genes_saida_atual[i]:

                                    novo_individuo[gene_disponivel[j]] = copy.deepcopy(gene_analisando)



                                    novo_indice = gene_disponivel[j]
                                    genes_saida_atual.pop(0)

                                    gene_disponivel.pop(j)
                                    break
                            for w in range(len(genes_saida_atual)):
                                valor_procurado = indice_genes_saida_atual[i]
                                if genes_saida_atual[w][0] == valor_procurado:
                                    genes_saida_atual[w][0] = copy.deepcopy(str(novo_indice))
                                if genes_saida_atual[w][1] == valor_procurado:
                                    genes_saida_atual[w][1] = copy.deepcopy(str(novo_indice))
                                if saida_corrigir_um[0][0] == valor_procurado:
                                    saida_corrigir_um[0][0] = copy.deepcopy(str(novo_indice))
                                if saida_corrigir_um[0][1] == valor_procurado:
                                    saida_corrigir_um[0][1] = copy.deepcopy(str(novo_indice))
                            

                saida_corrigir = []
                if type(saida_corrigir_um[0]) == list:
                    for m in range(len(saida_corrigir_um[0])):
                        saida_corrigir_um[0][m] = int(saida_corrigir_um[0][m])
                    
                    for i in range(len(novo_individuo)):
                        if novo_individuo[i] == saida_corrigir_um[0]:
                            saida_corrigir.append(i)
                else:
                    saida_corrigir.append(int(saida_corrigir_um[0]))
                    

                    
                        
                novo_individuo[ni+Ln+saida_atual] = copy.deepcopy(saida_corrigir[0])

            GENS_EVOL[individuo_saidas_a_processar[k]] = copy.deepcopy(copia_individuo_atual)

        array = copy.deepcopy(novo_individuo)
        anteriores = []
        for i in range(len(array)):
            atual = array[i]
            for j in range(len(array)):
                if array[j] == atual and i!=j:
                    novo_indice = i
                    indice_anterior = j
                    anteriores.append(indice_anterior)
                    for k in range(len(array)):
                        if k >= ni and k < Ln+ni and k > novo_indice and (novo_indice not in anteriores):
                            #print("k", k)
                            #print("array[k]", array[k])
                            if array[k][0] == indice_anterior:
                                array[k][0] = novo_indice
                            if array[k][1] == indice_anterior:
                                array[k][1] = novo_indice
        novo_individuo = copy.deepcopy(array)

        GENS_EVOL_ANTERIOR = []
        GENS_EVOL_ANTERIOR = copy.deepcopy(GENS_EVOL)        
        GENS_EVOL[0] = copy.deepcopy(novo_individuo)
        #LAMBDA_FILHOS.append(novo_individuo)
        SAM_ativo(0)
        #nos_ativos()                                                         
        FITNESS_EE_ANTERIOR = []
        FITNESS_EE_ANTERIOR = copy.deepcopy(FITNESS_EE)

        acumulador = 0
        for i in range(len(FITNESS_EE[0])):
            acumulador = acumulador + FITNESS_EE[0][i]
        melhor_antes = acumulador

        monta_tabela(0)
        acumulador2 = 0
        for i in range(len(FITNESS_EE[0])):
            acumulador2 = acumulador2 + FITNESS_EE[0][i]
        melhor_depois = acumulador2
        #print("melhor depois", melhor_depois)
        if melhor_depois < melhor_antes:
            print("AQUI")



def CROSSOVER_pop_NOVO(pai1, pai2):

    fitness_saida = []
    for i in range(no):
        fitness_saida.append([])

    for i in range(no):
        for j in range(len(FITNESS_EE)):
            if j == pai1:
                fitness_saida[i].append(FITNESS_EE[j][i])
            elif j == pai2:
                fitness_saida[i].append(FITNESS_EE[j][i])
            else:
                fitness_saida[i].append(0)

    indice_melhores_saidas = []
    melhores_saidas = []

    for i in range(no):
        melhores_saidas.append([])

    for i in range(len(fitness_saida)):
        melhor = max(fitness_saida[i])
        for j in range(len(fitness_saida[i])):
            if fitness_saida[i][j] == melhor:
                melhores_saidas[i].append(j)

                
    todos_indices = []
    for i in range(len(melhores_saidas)):
        for j in range(len(melhores_saidas[i])):
            todos_indices.append(melhores_saidas[i][j])

    qtd_iguais = []
    for i in range(ee_mu_pop + ee_lambda_pop):
        qtd_iguais.append(todos_indices.count(i))
        
        
    maiores_melhores_saidas = []
    for i in range(len(qtd_iguais)):
        if qtd_iguais[i] == max(qtd_iguais):
            maiores_melhores_saidas.append(i)
            
    INDIVIDUO_INICIAL = maiores_melhores_saidas[r.randint(0, len(maiores_melhores_saidas)-1)]

    
    saidas_individuo_inicial = []
    for i in range(len(melhores_saidas)):
        if INDIVIDUO_INICIAL in melhores_saidas[i]:
            saidas_individuo_inicial.append(i)

    saidas_a_processar = []
    for i in range(no):
        if i not in saidas_individuo_inicial:
            saidas_a_processar.append(i)


    individuo_saidas_a_processar = []
    for i in range(len(saidas_a_processar)):
        individuo_saidas_a_processar.append(melhores_saidas[saidas_a_processar[i]][r.randint(0, len(melhores_saidas[saidas_a_processar[i]])-1)])
        

    for i in range(len(melhores_saidas)):
        indice = r.randint(0, len(melhores_saidas[i])-1)
        indice_melhores_saidas.append(melhores_saidas[i][indice])

    novo_individuo = []
    individuo_inicial = []

##PERFEITO ATÉ AQUI

    if 1 < 0:
        variavel = 0
    else:
        novo_individuo = copy.deepcopy(GENS_EVOL[INDIVIDUO_INICIAL])
        individuo_inicial.append(INDIVIDUO_INICIAL)
        gene_disponivel = []
        ###
        GENES_ATIVOS_MOM = []
        GENES_ATIVOS_MOM = copy.deepcopy(MEUARRAY[INDIVIDUO_INICIAL][0])
        for x in range(len(GENES_ATIVOS_MOM)):
            if GENES_ATIVOS_MOM[x] == "X":
                GENES_ATIVOS_MOM[x] = "-"
        ###


        for i in range(len(saidas_individuo_inicial)):
            for p in range(len(MEUARRAY[INDIVIDUO_INICIAL][saidas_individuo_inicial[i]])):
                if MEUARRAY[INDIVIDUO_INICIAL][saidas_individuo_inicial[i]][p] == "X":
                    GENES_ATIVOS_MOM[p] = "X"


        for i in range(len(GENES_ATIVOS_MOM)):
            if GENES_ATIVOS_MOM[i] != "X" and i >= ni and i < Ln+ni:
                gene_disponivel.append(i)
                
        
                                                               
        for k in range(len(saidas_a_processar)):
            saida_atual = saidas_a_processar[k]
            individuo_saida_atual = individuo_saidas_a_processar[k]
            copia_individuo_atual = copy.deepcopy(GENS_EVOL[individuo_saidas_a_processar[k]])

            if 1 < 0:

                novo_individuo = copy.deepcopy(GENS_EVOL[individuo_saida_atual])

            else:



                genes_saida_atual = []
                indice_genes_saida_atual = []
                for i in range(len(MEUARRAY[individuo_saida_atual][saida_atual])):
                    if MEUARRAY[individuo_saida_atual][saida_atual][i] == "X" and i >= ni and i < Ln+ni: ##Talvez essa condição i>= ni não faça sentido
                    
                        valor_a_ser_adicionado = copy.deepcopy(GENS_EVOL[individuo_saida_atual][i])
                        genes_saida_atual.append(valor_a_ser_adicionado)
                        indice_genes_saida_atual.append(i)


                saida_corrigir_um = []
                if len(genes_saida_atual) != 0:
                    saida_corrigir_um.append(genes_saida_atual[len(genes_saida_atual)-1])
                else:
                    saida_corrigir_um.append(GENS_EVOL[individuo_saida_atual][Ln+ni+saida_atual])


                ## ATÉ AQUI APARENTEMENTE OK

                while len(genes_saida_atual) != 0:

                    for i in range(len(indice_genes_saida_atual)):

                        if len(genes_saida_atual) == 1:

                            saida_corrigir_um[0] = copy.deepcopy(genes_saida_atual[0])
                      
                        gene_analisando = []
                        if len(genes_saida_atual) > 0:
                            for m in range(len(genes_saida_atual[0])):

                                gene_analisando.append(int(genes_saida_atual[0][m]))

                            if len(gene_disponivel) == 0:
                                print("--------------------------------------- FALTA ESPAÇO --------------------------------------")
                                exit()


                        if novo_individuo[indice_genes_saida_atual[i]] == gene_analisando:

                            genes_saida_atual.pop(0)
                            for v in range(len(gene_disponivel)):
                                if gene_disponivel[v] == indice_genes_saida_atual[i]:
                                    gene_disponivel.pop(v)
                                    break

                        else:
                            minha_condicao = True #aqui
                            for j in range(len(gene_disponivel)):
                                atual_indices_existentes = []
                                for h in range(len(gene_analisando)):
                                    if h < 2:
                                        atual_indices_existentes.append(gene_analisando[h])
                                        
                                atual_maior_indice_existente = max(atual_indices_existentes)
                                        
                                if gene_disponivel[j] > atual_maior_indice_existente:

                                    novo_individuo[gene_disponivel[j]] = copy.deepcopy(gene_analisando)



                                    novo_indice = gene_disponivel[j]

                                    genes_saida_atual.pop(0)

                                    gene_disponivel.pop(j)
                                    minha_condicao = False #aqui
                                    break
                                        
                                            
                            for w in range(len(genes_saida_atual)):
                                valor_procurado = indice_genes_saida_atual[i]
                                if genes_saida_atual[w][0] == valor_procurado:
                                    genes_saida_atual[w][0] = copy.deepcopy(str(novo_indice))
                                if genes_saida_atual[w][1] == valor_procurado:
                                    genes_saida_atual[w][1] = copy.deepcopy(str(novo_indice))
                                if saida_corrigir_um[0][0] == valor_procurado:
                                    saida_corrigir_um[0][0] = copy.deepcopy(str(novo_indice))
                                if saida_corrigir_um[0][1] == valor_procurado:
                                    saida_corrigir_um[0][1] = copy.deepcopy(str(novo_indice))
                            

                saida_corrigir = []
                if type(saida_corrigir_um[0]) == list:
                    for m in range(len(saida_corrigir_um[0])):
                        saida_corrigir_um[0][m] = int(saida_corrigir_um[0][m])
                    
                    for i in range(len(novo_individuo)):
                        if novo_individuo[i] == saida_corrigir_um[0]:
                            saida_corrigir.append(i)
                else:
                    saida_corrigir.append(int(saida_corrigir_um[0]))
                    

                    
                        
                novo_individuo[ni+Ln+saida_atual] = copy.deepcopy(saida_corrigir[0])

            GENS_EVOL[individuo_saidas_a_processar[k]] = copy.deepcopy(copia_individuo_atual)

        array = copy.deepcopy(novo_individuo)
        anteriores = []
        for i in range(len(array)):
            atual = array[i]
            for j in range(len(array)):
                if array[j] == atual and i!=j:
                    novo_indice = i
                    indice_anterior = j
                    anteriores.append(indice_anterior)
                    for k in range(len(array)):
                        if k >= ni and k < Ln+ni and k > novo_indice and (novo_indice not in anteriores):
                            #print("k", k)
                            #print("array[k]", array[k])
                            if array[k][0] == indice_anterior:
                                array[k][0] = novo_indice
                            if array[k][1] == indice_anterior:
                                array[k][1] = novo_indice
        novo_individuo = copy.deepcopy(array)
        #print("NOVO INDIVIDUO", novo_individuo)

        #GENS_EVOL_ANTERIOR = []
        #GENS_EVOL_ANTERIOR = copy.deepcopy(GENS_EVOL)        
        #GENS_EVOL[0] = copy.deepcopy(novo_individuo)
        LAMBDA_FILHOS.append(novo_individuo)
        #SAM_ativo(0)
        #nos_ativos()                                                         
        #FITNESS_EE_ANTERIOR = []
        #FITNESS_EE_ANTERIOR = copy.deepcopy(FITNESS_EE)



        #acumulador = 0
        #for i in range(len(FITNESS_EE[0])):
        #    acumulador = acumulador + FITNESS_EE[0][i]
        #melhor_antes = acumulador#

        #monta_tabela(0)
        #acumulador2 = 0
        #for i in range(len(FITNESS_EE[0])):
        #    acumulador2 = acumulador2 + FITNESS_EE[0][i]
        #melhor_depois = acumulador2
        #print("melhor depois", melhor_depois)
        #if melhor_depois < melhor_antes:
        #    print("AQUI")


def CROSSOVER_pop_NOVO_SUPER():

    fitness_saida = []
    for i in range(no):
        fitness_saida.append([])

    for i in range(no):
        for j in range(len(FITNESS_EE)):
            fitness_saida[i].append(FITNESS_EE[j][i])

    indice_melhores_saidas = []
    melhores_saidas = []

    for i in range(no):
        melhores_saidas.append([])

    for i in range(len(fitness_saida)):
        melhor = max(fitness_saida[i])
        for j in range(len(fitness_saida[i])):
            if fitness_saida[i][j] == melhor:
                melhores_saidas[i].append(j)

                
    todos_indices = []
    for i in range(len(melhores_saidas)):
        for j in range(len(melhores_saidas[i])):
            todos_indices.append(melhores_saidas[i][j])

    qtd_iguais = []
    for i in range(ee_mu_pop + ee_lambda_pop):
        qtd_iguais.append(todos_indices.count(i))
        
        
    maiores_melhores_saidas = []
    for i in range(len(qtd_iguais)):
        if qtd_iguais[i] == max(qtd_iguais):
            maiores_melhores_saidas.append(i)
            
    INDIVIDUO_INICIAL = maiores_melhores_saidas[r.randint(0, len(maiores_melhores_saidas)-1)]

    
    saidas_individuo_inicial = []
    for i in range(len(melhores_saidas)):
        if INDIVIDUO_INICIAL in melhores_saidas[i]:
            saidas_individuo_inicial.append(i)

    saidas_a_processar = []
    for i in range(no):
        if i not in saidas_individuo_inicial:
            saidas_a_processar.append(i)


    individuo_saidas_a_processar = []
    for i in range(len(saidas_a_processar)):
        individuo_saidas_a_processar.append(melhores_saidas[saidas_a_processar[i]][r.randint(0, len(melhores_saidas[saidas_a_processar[i]])-1)])
        

    for i in range(len(melhores_saidas)):
        indice = r.randint(0, len(melhores_saidas[i])-1)
        indice_melhores_saidas.append(melhores_saidas[i][indice])

    novo_individuo = []
    individuo_inicial = []

##PERFEITO ATÉ AQUI

    if 1 < 0:
        variavel = 0
    else:
        novo_individuo = copy.deepcopy(GENS_EVOL[INDIVIDUO_INICIAL])
        individuo_inicial.append(INDIVIDUO_INICIAL)
        gene_disponivel = []
        ###
        GENES_ATIVOS_MOM = []
        GENES_ATIVOS_MOM = copy.deepcopy(MEUARRAY[INDIVIDUO_INICIAL][0])
        for x in range(len(GENES_ATIVOS_MOM)):
            if GENES_ATIVOS_MOM[x] == "X":
                GENES_ATIVOS_MOM[x] = "-"
        ###


        for i in range(len(saidas_individuo_inicial)):
            for p in range(len(MEUARRAY[INDIVIDUO_INICIAL][saidas_individuo_inicial[i]])):
                if MEUARRAY[INDIVIDUO_INICIAL][saidas_individuo_inicial[i]][p] == "X":
                    GENES_ATIVOS_MOM[p] = "X"


        for i in range(len(GENES_ATIVOS_MOM)):
            if GENES_ATIVOS_MOM[i] != "X" and i >= ni and i < Ln+ni:
                gene_disponivel.append(i)
                
        
                                                               
        for k in range(len(saidas_a_processar)):
            saida_atual = saidas_a_processar[k]
            individuo_saida_atual = individuo_saidas_a_processar[k]
            copia_individuo_atual = copy.deepcopy(GENS_EVOL[individuo_saidas_a_processar[k]])

            if 1 < 0:

                novo_individuo = copy.deepcopy(GENS_EVOL[individuo_saida_atual])

            else:



                genes_saida_atual = []
                indice_genes_saida_atual = []
                for i in range(len(MEUARRAY[individuo_saida_atual][saida_atual])):
                    if MEUARRAY[individuo_saida_atual][saida_atual][i] == "X" and i >= ni and i < Ln+ni: ##Talvez essa condição i>= ni não faça sentido
                    
                        valor_a_ser_adicionado = copy.deepcopy(GENS_EVOL[individuo_saida_atual][i])
                        genes_saida_atual.append(valor_a_ser_adicionado)
                        indice_genes_saida_atual.append(i)


                saida_corrigir_um = []
                if len(genes_saida_atual) != 0:
                    saida_corrigir_um.append(genes_saida_atual[len(genes_saida_atual)-1])
                else:
                    saida_corrigir_um.append(GENS_EVOL[individuo_saida_atual][Ln+ni+saida_atual])


                ## ATÉ AQUI APARENTEMENTE OK

                while len(genes_saida_atual) != 0:

                    for i in range(len(indice_genes_saida_atual)):

                        if len(genes_saida_atual) == 1:

                            saida_corrigir_um[0] = copy.deepcopy(genes_saida_atual[0])
                      
                        gene_analisando = []
                        if len(genes_saida_atual) > 0:
                            for m in range(len(genes_saida_atual[0])):

                                gene_analisando.append(int(genes_saida_atual[0][m]))

                            if len(gene_disponivel) == 0:
                                print("--------------------------------------- FALTA ESPAÇO --------------------------------------")
                                exit()


                        if novo_individuo[indice_genes_saida_atual[i]] == gene_analisando:

                            genes_saida_atual.pop(0)
                            for v in range(len(gene_disponivel)):
                                if gene_disponivel[v] == indice_genes_saida_atual[i]:
                                    gene_disponivel.pop(v)
                                    break

                        else:
                            minha_condicao = True #aqui
                            for j in range(len(gene_disponivel)):
                                atual_indices_existentes = []
                                for h in range(len(gene_analisando)):
                                    if h < 2:
                                        atual_indices_existentes.append(gene_analisando[h])
                                        
                                atual_maior_indice_existente = max(atual_indices_existentes)
                                        
                                if gene_disponivel[j] > atual_maior_indice_existente:

                                    novo_individuo[gene_disponivel[j]] = copy.deepcopy(gene_analisando)



                                    novo_indice = gene_disponivel[j]

                                    genes_saida_atual.pop(0)

                                    gene_disponivel.pop(j)
                                    minha_condicao = False #aqui
                                    break
                                        
                                            
                            for w in range(len(genes_saida_atual)):
                                valor_procurado = indice_genes_saida_atual[i]
                                if genes_saida_atual[w][0] == valor_procurado:
                                    genes_saida_atual[w][0] = copy.deepcopy(str(novo_indice))
                                if genes_saida_atual[w][1] == valor_procurado:
                                    genes_saida_atual[w][1] = copy.deepcopy(str(novo_indice))
                                if saida_corrigir_um[0][0] == valor_procurado:
                                    saida_corrigir_um[0][0] = copy.deepcopy(str(novo_indice))
                                if saida_corrigir_um[0][1] == valor_procurado:
                                    saida_corrigir_um[0][1] = copy.deepcopy(str(novo_indice))
                            

                saida_corrigir = []
                if type(saida_corrigir_um[0]) == list:
                    for m in range(len(saida_corrigir_um[0])):
                        saida_corrigir_um[0][m] = int(saida_corrigir_um[0][m])
                    
                    for i in range(len(novo_individuo)):
                        if novo_individuo[i] == saida_corrigir_um[0]:
                            saida_corrigir.append(i)
                else:
                    saida_corrigir.append(int(saida_corrigir_um[0]))
                    

                    
                        
                novo_individuo[ni+Ln+saida_atual] = copy.deepcopy(saida_corrigir[0])

            GENS_EVOL[individuo_saidas_a_processar[k]] = copy.deepcopy(copia_individuo_atual)

        array = copy.deepcopy(novo_individuo)
        anteriores = []
        for i in range(len(array)):
            atual = array[i]
            for j in range(len(array)):
                if array[j] == atual and i!=j:
                    novo_indice = i
                    indice_anterior = j
                    anteriores.append(indice_anterior)
                    for k in range(len(array)):
                        if k >= ni and k < Ln+ni and k > novo_indice and (novo_indice not in anteriores):
                            #print("k", k)
                            #print("array[k]", array[k])
                            if array[k][0] == indice_anterior:
                                array[k][0] = novo_indice
                            if array[k][1] == indice_anterior:
                                array[k][1] = novo_indice
        novo_individuo = copy.deepcopy(array)
        #print("NOVO INDIVIDUO", novo_individuo)

        #GENS_EVOL_ANTERIOR = []
        #GENS_EVOL_ANTERIOR = copy.deepcopy(GENS_EVOL)        
        #GENS_EVOL[0] = copy.deepcopy(novo_individuo)
        LAMBDA_FILHOS.append(novo_individuo)
        #SAM_ativo(0)
        #nos_ativos()                                                         
        #FITNESS_EE_ANTERIOR = []
        #FITNESS_EE_ANTERIOR = copy.deepcopy(FITNESS_EE)



        #acumulador = 0
        #for i in range(len(FITNESS_EE[0])):
        #    acumulador = acumulador + FITNESS_EE[0][i]
        #melhor_antes = acumulador#

        #monta_tabela(0)
        #acumulador2 = 0
        #for i in range(len(FITNESS_EE[0])):
        #    acumulador2 = acumulador2 + FITNESS_EE[0][i]
        #melhor_depois = acumulador2
        #print("melhor depois", melhor_depois)
        #if melhor_depois < melhor_antes:
        #    print("AQUI")



def CROSSOVER_pop(pai1, pai2, pai3, pai4):

    fitness_saida = []
    for i in range(no):
        fitness_saida.append([])

    for i in range(no):
        for j in range(len(FITNESS_EE)):
            if j == pai1:
                fitness_saida[i].append(FITNESS_EE[j][i])
            elif j == pai2:
                fitness_saida[i].append(FITNESS_EE[j][i])
            elif j == pai3:
                fitness_saida[i].append(FITNESS_EE[j][i])
            elif j == pai4:
                fitness_saida[i].append(FITNESS_EE[j][i])
            else:
                fitness_saida[i].append(0)

    indice_melhores_saidas = []
    melhores_saidas = []

    for i in range(no):
        melhores_saidas.append([])

    for i in range(len(fitness_saida)):
        melhor = max(fitness_saida[i])
        for j in range(len(fitness_saida[i])):
            if fitness_saida[i][j] == melhor:
                melhores_saidas[i].append(j)

    todos_indices = []
    for i in range(len(melhores_saidas)):
        for j in range(len(melhores_saidas[i])):
            todos_indices.append(melhores_saidas[i][j])

    qtd_iguais = []
    for i in range(ee_mu_pop + ee_lambda_pop):
        qtd_iguais.append(todos_indices.count(i))

        
    maiores_melhores_saidas = []
    for i in range(len(qtd_iguais)):
        if qtd_iguais[i] == max(qtd_iguais):
            maiores_melhores_saidas.append(i)
            
    INDIVIDUO_INICIAL = maiores_melhores_saidas[r.randint(0, len(maiores_melhores_saidas)-1)]
    saidas_individuo_inicial = []
    for i in range(len(melhores_saidas)):
        if INDIVIDUO_INICIAL in melhores_saidas[i]:
            saidas_individuo_inicial.append(i)

    saidas_a_processar = []
    for i in range(no):
        if i not in saidas_individuo_inicial:
            saidas_a_processar.append(i)

    individuo_saidas_a_processar = []
    for i in range(len(saidas_a_processar)):
        individuo_saidas_a_processar.append(melhores_saidas[saidas_a_processar[i]][r.randint(0, len(melhores_saidas[saidas_a_processar[i]])-1)])
        


    for i in range(len(melhores_saidas)):
        indice = r.randint(0, len(melhores_saidas[i])-1)
        indice_melhores_saidas.append(melhores_saidas[i][indice])

    novo_individuo = []
    individuo_inicial = []



    if 1 < 0:
        variavel = 0
    else:
        novo_individuo = copy.deepcopy(GENS_EVOL[INDIVIDUO_INICIAL])
        individuo_inicial.append(INDIVIDUO_INICIAL)
        gene_disponivel = []
        for i in range(len(saidas_individuo_inicial)):
            if i == 0:
                MEUARRAY[INDIVIDUO_INICIAL][0] = copy.deepcopy(MEUARRAY[INDIVIDUO_INICIAL][saidas_individuo_inicial[i]])
            else:
                for p in range(len(MEUARRAY[INDIVIDUO_INICIAL][saidas_individuo_inicial[i]])):
                    if MEUARRAY[INDIVIDUO_INICIAL][saidas_individuo_inicial[i]][p] == "X":
                        MEUARRAY[INDIVIDUO_INICIAL][0][p] = "X"
                                                               
        for i in range(len(MEUARRAY[INDIVIDUO_INICIAL][0])):
            if MEUARRAY[INDIVIDUO_INICIAL][0][i] != "X" and i >= ni and i < Ln+ni:  ##Talvez essa condição i >= ni não faça sentido
                gene_disponivel.append(i)
        for k in range(len(saidas_a_processar)):
            saida_atual = saidas_a_processar[k]
            individuo_saida_atual = individuo_saidas_a_processar[k]
            copia_individuo_atual = copy.deepcopy(GENS_EVOL[individuo_saidas_a_processar[k]])

            if 1 < 0:

                novo_individuo = copy.deepcopy(GENS_EVOL[individuo_saida_atual])
                individuo_inicial.append(indice_melhores_saidas[k])
                
                gene_disponivel = []
                for i in range(len(MEUARRAY[individuo_inicial[0]][0])):
                    if MEUARRAY[individuo_inicial[0]][0][i] != "X" and i >= ni and i < Ln+ni:
                        gene_disponivel.append(i)
            else:



                genes_saida_atual = []
                indice_genes_saida_atual = []
                for i in range(len(MEUARRAY[individuo_saida_atual][saida_atual])):
                    if MEUARRAY[individuo_saida_atual][saida_atual][i] == "X" and i >= ni and i < Ln+ni: ##Talvez essa condição i>= ni não faça sentido
                        #### OLHA AQUI
                        valor_a_ser_adicionado = copy.deepcopy(GENS_EVOL[individuo_saida_atual][i])
                        #genes_saida_atual.append(GENS_EVOL[individuo_saida_atual][i])
                        genes_saida_atual.append(valor_a_ser_adicionado)
                        indice_genes_saida_atual.append(i)


                saida_corrigir_um = []
                if len(genes_saida_atual) != 0:
                    saida_corrigir_um.append(genes_saida_atual[len(genes_saida_atual)-1])
                else:
                    saida_corrigir_um.append(GENS_EVOL[individuo_saida_atual][Ln+ni+saida_atual])




                while len(genes_saida_atual) != 0:
                    #print(len(genes_saida_atual))
                    #if len(genes_saida_atual) == 1:
                    #    print("saida_corrigir_um antes: ", saida_corrigir_um)
                    #    saida_corrigir_um[0] = copy.deepcopy(genes_saida_atual[0])
                    #    print("sair corrigir um depois: ", saida_corrigir_um)
                    #print("AQUI", genes_saida_atual)
                    indice_genes_utilizados_aqui = []
                    for i in range(len(indice_genes_saida_atual)):
                        #print(len(genes_saida_atual))
                        if len(genes_saida_atual) == 1:
                            #print("saida_corrigir_um antes: ", saida_corrigir_um)
                            saida_corrigir_um[0] = copy.deepcopy(genes_saida_atual[0])
                            #print("sair corrigir um depois: ", saida_corrigir_um)                        
                        gene_analisando = []
                        if len(genes_saida_atual) > 0:
                            for m in range(len(genes_saida_atual[0])):

                                gene_analisando.append(int(genes_saida_atual[0][m]))

                            if len(gene_disponivel) == 0:
                                print("--------------------------------------- FALTA ESPAÇO --------------------------------------")
                                exit()


                        if novo_individuo[indice_genes_saida_atual[i]] == gene_analisando:

                            genes_saida_atual.pop(0)
                            for v in range(len(gene_disponivel)):
                                if gene_disponivel[v] == indice_genes_saida_atual[i]:
                                    gene_disponivel.pop(v)
                                    break

                        else:
                            minha_condicao = True #aqui
                            for j in range(len(gene_disponivel)):
                                if gene_disponivel[j] >= indice_genes_saida_atual[i]:

                                    novo_individuo[gene_disponivel[j]] = copy.deepcopy(gene_analisando)



                                    novo_indice = gene_disponivel[j]
                                    indice_genes_utilizados_aqui.append(novo_indice) #aqui
                                    #if len(genes_saida_atual) != 0:
                                    genes_saida_atual.pop(0)

                                    gene_disponivel.pop(j)
                                    minha_condicao = False #aqui
                                    break
                            if minha_condicao == True: ## aqui tudo
                                if len(genes_saida_atual) == 1:
                                    indice_existente1 = int(genes_saida_atual[0][0])
                                    indice_existente2 = int(genes_saida_atual[0][1])
                                    indices_existentes = []
                                    indices_existentes.append(indice_existente1)
                                    indices_existentes.append(indice_existente2)
                                    maior_indice_existente = max(indices_existentes)
                                    for j in range(len(gene_disponivel)):
                                        if gene_disponivel[j] > maior_indice_existente and gene_disponivel[j] > max(indice_genes_utilizados_aqui):
                                            novo_individuo[gene_disponivel[j]] = copy.deepcopy(gene_analisando)
                                            novo_indice = gene_disponivel[j]
                                            genes_saida_atual.pop(0)
                                            gene_disponivel.pop(j)
                                            break
                                        
                                            
                            for w in range(len(genes_saida_atual)):
                                valor_procurado = indice_genes_saida_atual[i]
                                if genes_saida_atual[w][0] == valor_procurado:
                                    genes_saida_atual[w][0] = copy.deepcopy(str(novo_indice))
                                if genes_saida_atual[w][1] == valor_procurado:
                                    genes_saida_atual[w][1] = copy.deepcopy(str(novo_indice))
                                if saida_corrigir_um[0][0] == valor_procurado:
                                    saida_corrigir_um[0][0] = copy.deepcopy(str(novo_indice))
                                if saida_corrigir_um[0][1] == valor_procurado:
                                    saida_corrigir_um[0][1] = copy.deepcopy(str(novo_indice))
                            

                saida_corrigir = []
                if type(saida_corrigir_um[0]) == list:
                    for m in range(len(saida_corrigir_um[0])):
                        saida_corrigir_um[0][m] = int(saida_corrigir_um[0][m])
                    
                    for i in range(len(novo_individuo)):
                        if novo_individuo[i] == saida_corrigir_um[0]:
                            saida_corrigir.append(i)
                else:
                    saida_corrigir.append(int(saida_corrigir_um[0]))
                    

                    
                        
                novo_individuo[ni+Ln+saida_atual] = copy.deepcopy(saida_corrigir[0])

            GENS_EVOL[individuo_saidas_a_processar[k]] = copy.deepcopy(copia_individuo_atual)

        array = copy.deepcopy(novo_individuo)
        anteriores = []
        for i in range(len(array)):
            atual = array[i]
            for j in range(len(array)):
                if array[j] == atual and i!=j:
                    novo_indice = i
                    indice_anterior = j
                    anteriores.append(indice_anterior)
                    for k in range(len(array)):
                        if k >= ni and k < Ln+ni and k > novo_indice and (novo_indice not in anteriores):
                            #print("k", k)
                            #print("array[k]", array[k])
                            if array[k][0] == indice_anterior:
                                array[k][0] = novo_indice
                            if array[k][1] == indice_anterior:
                                array[k][1] = novo_indice
        novo_individuo = copy.deepcopy(array)
        #print("NOVO INDIVIDUO", novo_individuo)

        #GENS_EVOL_ANTERIOR = []
        #GENS_EVOL_ANTERIOR = copy.deepcopy(GENS_EVOL)        
        #GENS_EVOL[0] = copy.deepcopy(novo_individuo)
        LAMBDA_FILHOS.append(novo_individuo)
        #SAM_ativo(0)
        #nos_ativos()                                                         
        #FITNESS_EE_ANTERIOR = []
        #FITNESS_EE_ANTERIOR = copy.deepcopy(FITNESS_EE)



        #acumulador = 0
        #for i in range(len(FITNESS_EE[0])):
        #    acumulador = acumulador + FITNESS_EE[0][i]
        #melhor_antes = acumulador#

        #monta_tabela(0)
        #acumulador2 = 0
        #for i in range(len(FITNESS_EE[0])):
        #    acumulador2 = acumulador2 + FITNESS_EE[0][i]
        #melhor_depois = acumulador2
        #print("melhor depois", melhor_depois)
        #if melhor_depois < melhor_antes:
        #    print("AQUI")




def atualiza_pai_NOVO2():
    fitness_saida = []
    for i in range(no):
        fitness_saida.append([])

    for i in range(no):
        for j in range(len(FITNESS_EE)):
            fitness_saida[i].append(FITNESS_EE[j][i])

    indice_melhores_saidas = []
    melhores_saidas = []

    for i in range(no):
        melhores_saidas.append([])

    for i in range(len(fitness_saida)):
        melhor = max(fitness_saida[i])
        for j in range(len(fitness_saida[i])):
            if fitness_saida[i][j] == melhor:
                melhores_saidas[i].append(j)

    for i in range(len(melhores_saidas)):
        indice = r.randint(0, len(melhores_saidas[i])-1)
        indice_melhores_saidas.append(melhores_saidas[i][indice])

    novo_individuo = []
    individuo_inicial = []

    if 1 < 0:
        variavel = 0
    else:

        for k in range(len(indice_melhores_saidas)):
            saida_atual = k
            individuo_saida_atual = indice_melhores_saidas[k]

            copia_individuo_atual = copy.deepcopy(GENS_EVOL[indice_melhores_saidas[k]])

            if saida_atual == 0:

                novo_individuo = copy.deepcopy(GENS_EVOL[individuo_saida_atual])
                individuo_inicial.append(indice_melhores_saidas[k])
                
                gene_disponivel = []
                for i in range(len(MEUARRAY[individuo_inicial[0]][0])):
                    if MEUARRAY[individuo_inicial[0]][0][i] != "X" and i >= ni and i < Ln+ni:
                        gene_disponivel.append(i)
            else:



                genes_saida_atual = []
                indice_genes_saida_atual = []
                for i in range(len(MEUARRAY[individuo_saida_atual][saida_atual])):
                    if MEUARRAY[individuo_saida_atual][saida_atual][i] == "X" and i >= ni and i < Ln+ni:
                        genes_saida_atual.append(GENS_EVOL[individuo_saida_atual][i])
                        indice_genes_saida_atual.append(i)

                saida_corrigir_um = []
                if len(genes_saida_atual) != 0:
                    saida_corrigir_um.append(genes_saida_atual[len(genes_saida_atual)-1])
                else:
                    saida_corrigir_um.append(GENS_EVOL[individuo_saida_atual][Ln+ni+saida_atual])




                while len(genes_saida_atual) != 0:
                    for i in range(len(indice_genes_saida_atual)):

                        gene_analisando = []
                        if len(genes_saida_atual) > 0:
                            for m in range(len(genes_saida_atual[0])):

                                gene_analisando.append(int(genes_saida_atual[0][m]))

                            if len(gene_disponivel) == 0:
                                print("--------------------------------------- FALTA ESPAÇO --------------------------------------")
                      
                        if novo_individuo[indice_genes_saida_atual[i]] == gene_analisando:


                            genes_saida_atual.pop(0)
                            for v in range(len(gene_disponivel)):
                                if gene_disponivel[v] == indice_genes_saida_atual[i]:
                                    gene_disponivel.pop(v)
                                    break

                        else:

                            for j in range(len(gene_disponivel)):
                                if gene_disponivel[j] >= indice_genes_saida_atual[i]:

                                    novo_individuo[gene_disponivel[j]] = copy.deepcopy(gene_analisando)



                                    novo_indice = gene_disponivel[j]

                                    genes_saida_atual.pop(0)

                                    gene_disponivel.pop(j)

                                    break
                            for w in range(len(genes_saida_atual)):
                                valor_procurado = indice_genes_saida_atual[i]
                                if genes_saida_atual[w][0] == valor_procurado:
                                    genes_saida_atual[w][0] = copy.deepcopy(str(novo_indice))
                                if genes_saida_atual[w][1] == valor_procurado:
                                    genes_saida_atual[w][1] = copy.deepcopy(str(novo_indice))
                                if saida_corrigir_um[0][0] == valor_procurado:
                                    saida_corrigir_um[0][0] = copy.deepcopy(str(novo_indice))
                                if saida_corrigir_um[0][1] == valor_procurado:
                                    saida_corrigir_um[0][1] = copy.deepcopy(str(novo_indice))
                            

                saida_corrigir = []
                if type(saida_corrigir_um[0]) == list:
                    for m in range(len(saida_corrigir_um[0])):
                        saida_corrigir_um[0][m] = int(saida_corrigir_um[0][m])
                    
                    for i in range(len(novo_individuo)):
                        if novo_individuo[i] == saida_corrigir_um[0]:
                            saida_corrigir.append(i)
                else:
                    saida_corrigir.append(int(saida_corrigir_um[0]))
                    

                    
                        
                novo_individuo[ni+Ln+saida_atual] = copy.deepcopy(saida_corrigir[0])

            GENS_EVOL[indice_melhores_saidas[k]] = copy.deepcopy(copia_individuo_atual)

        array = copy.deepcopy(novo_individuo)
        anteriores = []
        for i in range(len(array)):
            atual = array[i]
            for j in range(len(array)):
                if array[j] == atual and i!=j:
                    novo_indice = i
                    indice_anterior = j
                    anteriores.append(indice_anterior)
                    for k in range(len(array)):
                        if k >= ni and k < Ln+no and k > novo_indice and (novo_indice not in anteriores):
                            if array[k][0] == indice_anterior:
                                array[k][0] = novo_indice
                            if array[k][1] == indice_anterior:
                                array[k][1] = novo_indice
        novo_individuo = copy.deepcopy(array)

        GENS_EVOL_ANTERIOR = []
        GENS_EVOL_ANTERIOR = copy.deepcopy(GENS_EVOL)        
        GENS_EVOL[0] = copy.deepcopy(novo_individuo)

        SAM_ativo(0)
                                                        
        FITNESS_EE_ANTERIOR = []
        FITNESS_EE_ANTERIOR = copy.deepcopy(FITNESS_EE)

        acumulador = 0
        for i in range(len(FITNESS_EE[0])):
            acumulador = acumulador + FITNESS_EE[0][i]
        melhor_antes = acumulador

        monta_tabela(0)
        acumulador2 = 0
        for i in range(len(FITNESS_EE[0])):
            acumulador2 = acumulador2 + FITNESS_EE[0][i]
        melhor_depois = acumulador2

        if melhor_depois < melhor_antes:
            print("AQUI")




def atualiza_pai_NOVO():
    
    fitness_saida = []
    for i in range(no):
        fitness_saida.append([])

    for i in range(no):
        for j in range(len(FITNESS_EE)):
            fitness_saida[i].append(FITNESS_EE[j][i])
    
    indice_melhores_saidas = []
    melhores_saidas = []
    for i in range(no):
        melhores_saidas.append([])


    for i in range(len(fitness_saida)):
        melhor = max(fitness_saida[i])
        for j in range(len(fitness_saida[i])):
            if fitness_saida[i][j] == melhor:
                melhores_saidas[i].append(j)#

  

    for i in range(len(melhores_saidas)):
        indice = r.randint(0,len(melhores_saidas[i])-1)
        indice_melhores_saidas.append(melhores_saidas[i][indice])

    novo_individuo = []
    individuo_inicial = []
    arrumar_indice = []
    gene_disponivel = []
    gene_disponivel_utilizado = []
    indice_genes_ativos_comuns_diferentes = []

    if 1 < 0:
        variavel = 0
    else:
        diferente = False
        for k in range(len(indice_melhores_saidas)):

            saida_atual = k
            individuo_saida_atual = indice_melhores_saidas[k]

            if saida_atual == 0:
                novo_individuo = copy.deepcopy(GENS_EVOL[individuo_saida_atual])
                individuo_inicial.append(indice_melhores_saidas[k])

            else:

                
                indice_genes_ativos_comuns_diferentes = []
                arrumar_indice = []


                auxiliar_contador = 0

                for i in range(len(MEUARRAY[individuo_saida_atual][saida_atual])):

                    if MEUARRAY[individuo_saida_atual][saida_atual][i] == "X" and MEUARRAY[individuo_inicial[0]][0][i] == "X":

                        if GENS_EVOL[individuo_saida_atual][i] == novo_individuo[i] and diferente == False: ##GENS_EVOL[individuo_inicial[0]][i]

                            variavel_nada = 0
                            #Nada se faz
                        else:
                            if i >= ni:
                                indice_genes_ativos_comuns_diferentes.append(i)
                                #Ambos são ativos, mas diferentes
                                diferente = True #A partir desse momento os próximos genes tem que ser corrigidos

                    arrumar_indice_inativo = []
                    if MEUARRAY[individuo_saida_atual][saida_atual][i] == "X" and MEUARRAY[individuo_inicial[0]][0][i] != "X":

                        if i >=ni:

                            if diferente == True:
                                arrumar_indice.append(i)
                            else:

                                arrumar_indice.append(i)
                        

                gene_disponivel = []
                for i in range(len(MEUARRAY[individuo_inicial[0]][0])):
                    if MEUARRAY[individuo_inicial[0]][0][i] != "X" and i >= ni:
                        gene_disponivel.append(i)


                for i in range(len(indice_genes_ativos_comuns_diferentes)):
                    arrumar_indice.append(indice_genes_ativos_comuns_diferentes[i])
                arrumar_indice.sort()


                #COPIAR OS GENES PARA AS POSIÇÕES LIVRES
                gene_disponivel_utilizado = []
                #for i in range(len(arrumar_indice)):
                #    if gene_disponivel[i] >= arrumar_indice[i] and (i not in gene_disponivel_utilizado):
                #        gene_disponivel_utilizado.append(i)
                #    else:
                #        if arrumar_indice[i] >= ni+Ln:
                #            gene_disponivel_utilizado.append(ni+Ln+saida_atual)
                #        else:
                #            
                #            j = i
                #            
                #            while j in gene_disponivel_utilizado:
                #                j = j+1
                #                
                #            while gene_disponivel[j] < arrumar_indice[i]:
                #                
                #                j = j+1
                #            gene_disponivel_utilizado.append(j)
                #            i = j


                for i in range(len(arrumar_indice)):
                    if arrumar_indice[i] >= ni+Ln:
                        gene_disponivel_utilizado.append(ni+Ln+saida_atual)
                    else:
                        for j in range(len(gene_disponivel)):
                            if gene_disponivel[j] >= arrumar_indice[i] and (j not in gene_disponivel_utilizado):
                                gene_disponivel_utilizado.append(j)
                                break



                for i in range(len(arrumar_indice)):

                    novo_individuo[gene_disponivel[gene_disponivel_utilizado[i]]] = copy.deepcopy(GENS_EVOL[individuo_saida_atual][arrumar_indice[i]])

                #ARRUMAR OS ÍNDICES
                for i in range(len(arrumar_indice)):
                    if arrumar_indice[i] < ni+Ln:

                        valor_procurado = novo_individuo[gene_disponivel[gene_disponivel_utilizado[i]]][0]
                        for j in range(len(arrumar_indice)):
                            if arrumar_indice[j] == valor_procurado:
                                novo_indice = gene_disponivel[gene_disponivel_utilizado[j]]
                                novo_individuo[gene_disponivel[gene_disponivel_utilizado[i]]][0] = copy.deepcopy(novo_indice)

                        valor_procurado2 = novo_individuo[gene_disponivel[gene_disponivel_utilizado[i]]][1]
                        for j in range(len(arrumar_indice)):
                            if arrumar_indice[j] == valor_procurado2:
                            
                                novo_indice2 = gene_disponivel[gene_disponivel_utilizado[j]]
                                novo_individuo[gene_disponivel[gene_disponivel_utilizado[i]]][1] = copy.deepcopy(novo_indice2)


                                
                #ARRUMAR SAIDA
                if len(arrumar_indice) > 0:
                    saida = gene_disponivel[gene_disponivel_utilizado[(len(arrumar_indice))-1]]
                    novo_individuo[ni+Ln+saida_atual] = copy.deepcopy(saida)
                else:
                    novo_individuo[ni+Ln+saida_atual] = copy.deepcopy(GENS_EVOL[individuo_saida_atual][ni+Ln+saida_atual])

                #ARRUMAR MEUARRAY

                for i in range(len(gene_disponivel_utilizado)):
                    MEUARRAY[individuo_inicial[0]][0][gene_disponivel[gene_disponivel_utilizado[i]]] = "X"

        array = copy.deepcopy(novo_individuo)
        anteriores = []
        for i in range(len(array)):
           atual = array[i]
           for j in range(len(array)):
               if array[j] == atual and i != j:
                   novo_indice = i
                   indice_anterior = j
                   anteriores.append(indice_anterior)
                   for k in range(len(array)):
                       if k >= ni and k < Ln+no and k > novo_indice and (novo_indice not in anteriores):
                           if array[k][0] == indice_anterior:
                               array[k][0] = novo_indice
                           if array[k][1] == indice_anterior:
                               array[k][1] = novo_indice

                                    
        novo_individuo = copy.deepcopy(array)
        GENS_EVOL_ANTERIOR = []
        GENS_EVOL_ANTERIOR = copy.deepcopy(GENS_EVOL)        
        GENS_EVOL[0] = copy.deepcopy(novo_individuo)

        nos_ativos()                                                         
        FITNESS_EE_ANTERIOR = []
        FITNESS_EE_ANTERIOR = copy.deepcopy(FITNESS_EE)

        acumulador = 0
        for i in range(len(FITNESS_EE[0])):
            acumulador = acumulador + FITNESS_EE[0][i]
        melhor_antes = acumulador

        monta_tabela(0)
        acumulador2 = 0
        for i in range(len(FITNESS_EE[0])):
            acumulador2 = acumulador2 + FITNESS_EE[0][i]
        melhor_depois = acumulador2

        if melhor_depois < melhor_antes:
            print("AQUI")
            print("SAIDA ATUAL: ", saida_atual)
            print("INDIVIDUO SAIDA ATUAL:", individuo_saida_atual)
            print("FITNESS_EE_ANTERIOR: ", FITNESS_EE_ANTERIOR)
            print("indice melhores saidas:", indice_melhores_saidas)
            print("fitness_saida:", fitness_saida)
            print("melhores_saidas:", melhores_saidas)
            print("GENS_EVOL_ANTERIOR: ", GENS_EVOL_ANTERIOR)
            print("novo individuo: ", GENS_EVOL[0]),
            print("FITNESS_EE:", FITNESS_EE)
            print("arrumar_indice: ", arrumar_indice)
            print("gene_disponivel_utilizado:", gene_disponivel_utilizado)
            print("indice_genes_ativos_comuns_diferentes: ", indice_genes_ativos_comuns_diferentes)
            print("gene_disponivel", gene_disponivel)


        arrumar_indice.clear()
        gene_disponivel_utilizado.clear()
        gene_disponivel.clear()
        indice_genes_ativos_comuns_diferentes.clear()


def atualiza_pai_WIRES_FACTIVEL(): #Quando o circuito atende a tabela verdade, conta-se o número de portas
    soma = 0
    fitness_soma = [] # Array que armazena a soma de todas as saídas de cada circuito
    aux = []
    factivel = False 
    for k in range(ee_lambda + 1):
        fitness_soma.append([])
    for i in range(len(FITNESS_EE)):
        for j in range(len(FITNESS_EE[i])):
            soma = soma + FITNESS_EE[i][j]
        fitness_soma[i] = copy.deepcopy(soma)
        soma = 0

    for i in range(len(fitness_soma)):
        if fitness_soma[i] == (no * len(OUTPUTS[0])):
            factivel = True
 

    if factivel == False:
        for s in range(len(fitness_soma)):
            if fitness_soma[s] == max(fitness_soma):
                aux.append(s)
        sorteia = r.randint(0, len(aux)-1)

        if fitness_soma[0] < fitness_soma[aux[sorteia]]:
            for i in range(len(GENS_EVOL[0])):
                if GENS_EVOL[0][i] != GENS_EVOL[aux[sorteia]][i]:

                    if i >= ni and i < ni+Ln:
                        if GENS_EVOL[0][i][2] != GENS_EVOL[aux[sorteia]][i][2]:
                            if GENS_EVOL[0][i][2] == 900:
                                if GENS_EVOL[aux[sorteia]][i][2] == 100:
                                    MATRIZ_REGIAO_INFACTIVEL[0][1][0] = MATRIZ_REGIAO_INFACTIVEL[0][1][0] + 1
                                if GENS_EVOL[aux[sorteia]][i][2] == 110:
                                    MATRIZ_REGIAO_INFACTIVEL[0][2][0] = MATRIZ_REGIAO_INFACTIVEL[0][2][0] + 1
                                if GENS_EVOL[aux[sorteia]][i][2] == 130:
                                    MATRIZ_REGIAO_INFACTIVEL[0][3][0] = MATRIZ_REGIAO_INFACTIVEL[0][3][0] + 1
                                if GENS_EVOL[aux[sorteia]][i][2] == 800:
                                    MATRIZ_REGIAO_INFACTIVEL[0][4][0] = MATRIZ_REGIAO_INFACTIVEL[0][4][0] + 1
                                if GENS_EVOL[aux[sorteia]][i][2] == 150:
                                    MATRIZ_REGIAO_INFACTIVEL[0][5][0] = MATRIZ_REGIAO_INFACTIVEL[0][5][0] + 1
                                if GENS_EVOL[aux[sorteia]][i][2] == 160:
                                    MATRIZ_REGIAO_INFACTIVEL[0][6][0] = MATRIZ_REGIAO_INFACTIVEL[0][6][0] + 1
                                if GENS_EVOL[aux[sorteia]][i][2] == 980:
                                    MATRIZ_REGIAO_INFACTIVEL[0][7][0] = MATRIZ_REGIAO_INFACTIVEL[0][7][0] + 1
                                if GENS_EVOL[aux[sorteia]][i][2] == 990:
                                    MATRIZ_REGIAO_INFACTIVEL[0][8][0] = MATRIZ_REGIAO_INFACTIVEL[0][8][0] + 1
                                                            
                                                                    
                            if GENS_EVOL[0][i][2] == 100:
                                if GENS_EVOL[aux[sorteia]][i][2] == 900:
                                    MATRIZ_REGIAO_INFACTIVEL[1][0][0] = MATRIZ_REGIAO_INFACTIVEL[1][0][0] + 1
                                if GENS_EVOL[aux[sorteia]][i][2] == 110:
                                    MATRIZ_REGIAO_INFACTIVEL[1][2][0] = MATRIZ_REGIAO_INFACTIVEL[1][2][0] + 1
                                if GENS_EVOL[aux[sorteia]][i][2] == 130:
                                    MATRIZ_REGIAO_INFACTIVEL[1][3][0] = MATRIZ_REGIAO_INFACTIVEL[1][3][0] + 1
                                if GENS_EVOL[aux[sorteia]][i][2] == 800:
                                    MATRIZ_REGIAO_INFACTIVEL[1][4][0] = MATRIZ_REGIAO_INFACTIVEL[1][4][0] + 1
                                if GENS_EVOL[aux[sorteia]][i][2] == 150:
                                    MATRIZ_REGIAO_INFACTIVEL[1][5][0] = MATRIZ_REGIAO_INFACTIVEL[1][5][0] + 1
                                if GENS_EVOL[aux[sorteia]][i][2] == 160:
                                    MATRIZ_REGIAO_INFACTIVEL[1][6][0] = MATRIZ_REGIAO_INFACTIVEL[1][6][0] + 1
                                if GENS_EVOL[aux[sorteia]][i][2] == 980:
                                    MATRIZ_REGIAO_INFACTIVEL[1][7][0] = MATRIZ_REGIAO_INFACTIVEL[1][7][0] + 1
                                if GENS_EVOL[aux[sorteia]][i][2] == 990:
                                    MATRIZ_REGIAO_INFACTIVEL[1][8][0] = MATRIZ_REGIAO_INFACTIVEL[1][8][0] + 1                            
                            if GENS_EVOL[0][i][2] == 110:
                                if GENS_EVOL[aux[sorteia]][i][2] == 900:
                                    MATRIZ_REGIAO_INFACTIVEL[2][0][0] = MATRIZ_REGIAO_INFACTIVEL[2][0][0] + 1
                                if GENS_EVOL[aux[sorteia]][i][2] == 100:
                                    MATRIZ_REGIAO_INFACTIVEL[2][1][0] = MATRIZ_REGIAO_INFACTIVEL[2][1][0] + 1
                                if GENS_EVOL[aux[sorteia]][i][2] == 130:
                                    MATRIZ_REGIAO_INFACTIVEL[2][3][0] = MATRIZ_REGIAO_INFACTIVEL[2][3][0] + 1
                                if GENS_EVOL[aux[sorteia]][i][2] == 800:
                                    MATRIZ_REGIAO_INFACTIVEL[2][4][0] = MATRIZ_REGIAO_INFACTIVEL[2][4][0] + 1
                                if GENS_EVOL[aux[sorteia]][i][2] == 150:
                                    MATRIZ_REGIAO_INFACTIVEL[2][5][0] = MATRIZ_REGIAO_INFACTIVEL[2][5][0] + 1
                                if GENS_EVOL[aux[sorteia]][i][2] == 160:
                                    MATRIZ_REGIAO_INFACTIVEL[2][6][0] = MATRIZ_REGIAO_INFACTIVEL[2][6][0] + 1
                                if GENS_EVOL[aux[sorteia]][i][2] == 980:
                                    MATRIZ_REGIAO_INFACTIVEL[2][7][0] = MATRIZ_REGIAO_INFACTIVEL[2][7][0] + 1
                                if GENS_EVOL[aux[sorteia]][i][2] == 990:
                                    MATRIZ_REGIAO_INFACTIVEL[2][8][0] = MATRIZ_REGIAO_INFACTIVEL[2][8][0] + 1                                    
                            if GENS_EVOL[0][i][2] == 130:
                                if GENS_EVOL[aux[sorteia]][i][2] == 900:
                                    MATRIZ_REGIAO_INFACTIVEL[3][0][0] = MATRIZ_REGIAO_INFACTIVEL[3][0][0] + 1
                                if GENS_EVOL[aux[sorteia]][i][2] == 100:
                                    MATRIZ_REGIAO_INFACTIVEL[3][1][0] = MATRIZ_REGIAO_INFACTIVEL[3][1][0] + 1
                                if GENS_EVOL[aux[sorteia]][i][2] == 110:
                                    MATRIZ_REGIAO_INFACTIVEL[3][2][0] = MATRIZ_REGIAO_INFACTIVEL[3][2][0] + 1
                                if GENS_EVOL[aux[sorteia]][i][2] == 800:
                                    MATRIZ_REGIAO_INFACTIVEL[3][4][0] = MATRIZ_REGIAO_INFACTIVEL[3][4][0] + 1
                                if GENS_EVOL[aux[sorteia]][i][2] == 150:
                                    MATRIZ_REGIAO_INFACTIVEL[3][5][0] = MATRIZ_REGIAO_INFACTIVEL[3][5][0] + 1
                                if GENS_EVOL[aux[sorteia]][i][2] == 160:
                                    MATRIZ_REGIAO_INFACTIVEL[3][6][0] = MATRIZ_REGIAO_INFACTIVEL[3][6][0] + 1
                                if GENS_EVOL[aux[sorteia]][i][2] == 980:
                                    MATRIZ_REGIAO_INFACTIVEL[3][7][0] = MATRIZ_REGIAO_INFACTIVEL[3][7][0] + 1
                                if GENS_EVOL[aux[sorteia]][i][2] == 990:
                                    MATRIZ_REGIAO_INFACTIVEL[3][8][0] = MATRIZ_REGIAO_INFACTIVEL[3][8][0] + 1                                    
                            if GENS_EVOL[0][i][2] == 800:
                                if GENS_EVOL[aux[sorteia]][i][2] == 900:
                                    MATRIZ_REGIAO_INFACTIVEL[4][0][0] = MATRIZ_REGIAO_INFACTIVEL[4][0][0] + 1
                                if GENS_EVOL[aux[sorteia]][i][2] == 100:
                                    MATRIZ_REGIAO_INFACTIVEL[4][1][0] = MATRIZ_REGIAO_INFACTIVEL[4][1][0] + 1
                                if GENS_EVOL[aux[sorteia]][i][2] == 110:
                                    MATRIZ_REGIAO_INFACTIVEL[4][2][0] = MATRIZ_REGIAO_INFACTIVEL[4][2][0] + 1
                                if GENS_EVOL[aux[sorteia]][i][2] == 130:
                                    MATRIZ_REGIAO_INFACTIVEL[4][3][0] = MATRIZ_REGIAO_INFACTIVEL[4][3][0] + 1
                                if GENS_EVOL[aux[sorteia]][i][2] == 150:
                                    MATRIZ_REGIAO_INFACTIVEL[4][5][0] = MATRIZ_REGIAO_INFACTIVEL[4][5][0] + 1
                                if GENS_EVOL[aux[sorteia]][i][2] == 160:
                                    MATRIZ_REGIAO_INFACTIVEL[4][6][0] = MATRIZ_REGIAO_INFACTIVEL[4][6][0] + 1
                                if GENS_EVOL[aux[sorteia]][i][2] == 980:
                                    MATRIZ_REGIAO_INFACTIVEL[4][7][0] = MATRIZ_REGIAO_INFACTIVEL[4][7][0] + 1
                                if GENS_EVOL[aux[sorteia]][i][2] == 990:
                                    MATRIZ_REGIAO_INFACTIVEL[4][8][0] = MATRIZ_REGIAO_INFACTIVEL[4][8][0] + 1

                            if GENS_EVOL[0][i][2] == 150:
                                if GENS_EVOL[aux[sorteia]][i][2] == 900:
                                    MATRIZ_REGIAO_INFACTIVEL[5][0][0] = MATRIZ_REGIAO_INFACTIVEL[5][0][0] + 1
                                if GENS_EVOL[aux[sorteia]][i][2] == 100:
                                    MATRIZ_REGIAO_INFACTIVEL[5][1][0] = MATRIZ_REGIAO_INFACTIVEL[5][1][0] + 1
                                if GENS_EVOL[aux[sorteia]][i][2] == 110:
                                    MATRIZ_REGIAO_INFACTIVEL[5][2][0] = MATRIZ_REGIAO_INFACTIVEL[5][2][0] + 1
                                if GENS_EVOL[aux[sorteia]][i][2] == 130:
                                    MATRIZ_REGIAO_INFACTIVEL[5][3][0] = MATRIZ_REGIAO_INFACTIVEL[5][3][0] + 1
                                if GENS_EVOL[aux[sorteia]][i][2] == 800:
                                    MATRIZ_REGIAO_INFACTIVEL[5][4][0] = MATRIZ_REGIAO_INFACTIVEL[5][4][0] + 1
                                if GENS_EVOL[aux[sorteia]][i][2] == 160:
                                    MATRIZ_REGIAO_INFACTIVEL[5][6][0] = MATRIZ_REGIAO_INFACTIVEL[5][6][0] + 1
                                if GENS_EVOL[aux[sorteia]][i][2] == 980:
                                    MATRIZ_REGIAO_INFACTIVEL[5][7][0] = MATRIZ_REGIAO_INFACTIVEL[5][7][0] + 1
                                if GENS_EVOL[aux[sorteia]][i][2] == 990:
                                    MATRIZ_REGIAO_INFACTIVEL[5][8][0] = MATRIZ_REGIAO_INFACTIVEL[5][8][0] + 1                             
                            if GENS_EVOL[0][i][2] == 160:
                                if GENS_EVOL[aux[sorteia]][i][2] == 900:
                                    MATRIZ_REGIAO_INFACTIVEL[6][0][0] = MATRIZ_REGIAO_INFACTIVEL[6][0][0] + 1
                                if GENS_EVOL[aux[sorteia]][i][2] == 100:
                                    MATRIZ_REGIAO_INFACTIVEL[6][1][0] = MATRIZ_REGIAO_INFACTIVEL[6][1][0] + 1
                                if GENS_EVOL[aux[sorteia]][i][2] == 110:
                                    MATRIZ_REGIAO_INFACTIVEL[6][2][0] = MATRIZ_REGIAO_INFACTIVEL[6][2][0] + 1
                                if GENS_EVOL[aux[sorteia]][i][2] == 130:
                                    MATRIZ_REGIAO_INFACTIVEL[6][3][0] = MATRIZ_REGIAO_INFACTIVEL[6][3][0] + 1
                                if GENS_EVOL[aux[sorteia]][i][2] == 800:
                                    MATRIZ_REGIAO_INFACTIVEL[6][4][0] = MATRIZ_REGIAO_INFACTIVEL[6][4][0] + 1
                                if GENS_EVOL[aux[sorteia]][i][2] == 150:
                                    MATRIZ_REGIAO_INFACTIVEL[6][5][0] = MATRIZ_REGIAO_INFACTIVEL[6][5][0] + 1
                                if GENS_EVOL[aux[sorteia]][i][2] == 980:
                                    MATRIZ_REGIAO_INFACTIVEL[6][7][0] = MATRIZ_REGIAO_INFACTIVEL[6][7][0] + 1
                                if GENS_EVOL[aux[sorteia]][i][2] == 990:
                                    MATRIZ_REGIAO_INFACTIVEL[6][8][0] = MATRIZ_REGIAO_INFACTIVEL[6][8][0] + 1
                            if GENS_EVOL[0][i][2] == 980:
                                if GENS_EVOL[aux[sorteia]][i][2] == 900:
                                    MATRIZ_REGIAO_INFACTIVEL[7][0][0] = MATRIZ_REGIAO_INFACTIVEL[7][0][0] + 1
                                if GENS_EVOL[aux[sorteia]][i][2] == 100:
                                    MATRIZ_REGIAO_INFACTIVEL[7][1][0] = MATRIZ_REGIAO_INFACTIVEL[7][1][0] + 1
                                if GENS_EVOL[aux[sorteia]][i][2] == 110:
                                    MATRIZ_REGIAO_INFACTIVEL[7][2][0] = MATRIZ_REGIAO_INFACTIVEL[7][2][0] + 1
                                if GENS_EVOL[aux[sorteia]][i][2] == 130:
                                    MATRIZ_REGIAO_INFACTIVEL[7][3][0] = MATRIZ_REGIAO_INFACTIVEL[7][3][0] + 1
                                if GENS_EVOL[aux[sorteia]][i][2] == 800:
                                    MATRIZ_REGIAO_INFACTIVEL[7][4][0] = MATRIZ_REGIAO_INFACTIVEL[7][4][0] + 1
                                if GENS_EVOL[aux[sorteia]][i][2] == 150:
                                    MATRIZ_REGIAO_INFACTIVEL[7][5][0] = MATRIZ_REGIAO_INFACTIVEL[7][5][0] + 1
                                if GENS_EVOL[aux[sorteia]][i][2] == 160:
                                    MATRIZ_REGIAO_INFACTIVEL[7][6][0] = MATRIZ_REGIAO_INFACTIVEL[7][6][0] + 1
                                if GENS_EVOL[aux[sorteia]][i][2] == 990:
                                    MATRIZ_REGIAO_INFACTIVEL[7][8][0] = MATRIZ_REGIAO_INFACTIVEL[7][8][0] + 1
                            if GENS_EVOL[0][i][2] == 990:
                                if GENS_EVOL[aux[sorteia]][i][2] == 900:
                                    MATRIZ_REGIAO_INFACTIVEL[8][0][0] = MATRIZ_REGIAO_INFACTIVEL[8][0][0] + 1
                                if GENS_EVOL[aux[sorteia]][i][2] == 100:
                                    MATRIZ_REGIAO_INFACTIVEL[8][1][0] = MATRIZ_REGIAO_INFACTIVEL[8][1][0] + 1
                                if GENS_EVOL[aux[sorteia]][i][2] == 110:
                                    MATRIZ_REGIAO_INFACTIVEL[8][2][0] = MATRIZ_REGIAO_INFACTIVEL[8][2][0] + 1
                                if GENS_EVOL[aux[sorteia]][i][2] == 130:
                                    MATRIZ_REGIAO_INFACTIVEL[8][3][0] = MATRIZ_REGIAO_INFACTIVEL[8][3][0] + 1
                                if GENS_EVOL[aux[sorteia]][i][2] == 800:
                                    MATRIZ_REGIAO_INFACTIVEL[8][4][0] = MATRIZ_REGIAO_INFACTIVEL[8][4][0] + 1
                                if GENS_EVOL[aux[sorteia]][i][2] == 150:
                                    MATRIZ_REGIAO_INFACTIVEL[8][5][0] = MATRIZ_REGIAO_INFACTIVEL[8][5][0] + 1
                                if GENS_EVOL[aux[sorteia]][i][2] == 160:
                                    MATRIZ_REGIAO_INFACTIVEL[8][6][0] = MATRIZ_REGIAO_INFACTIVEL[8][6][0] + 1
                                if GENS_EVOL[aux[sorteia]][i][2] == 980:
                                    MATRIZ_REGIAO_INFACTIVEL[8][7][0] = MATRIZ_REGIAO_INFACTIVEL[8][7][0] + 1                                     
        GENS_EVOL[0] = copy.deepcopy(GENS_EVOL[aux[sorteia]])            

    if factivel == True:
        WIRES_LOCAL = []
        for i in range(ee_lambda + 1):
            WIRES_LOCAL.append([])
            for j in range(1):
                WIRES_LOCAL[i].append([])
                WIRES_LOCAL[i][0] = copy.deepcopy(WIRES_CKT[i])
        maior_fitness = max(fitness_soma)

        indice_maior_fitness = []
        iguais = []
        iguais_qtd_portas = []
        for i in range(len(fitness_soma)):
            if fitness_soma[i] == maior_fitness:
                indice_maior_fitness.append(i)

        for i in range(len(indice_maior_fitness)):
            iguais.append(WIRES_LOCAL[indice_maior_fitness[i]][0])
        maior_wires = max(iguais)

        for i in range(len(WIRES_LOCAL)):

            if WIRES_LOCAL[i][0] == maior_wires and fitness_soma[i] == maior_fitness:
                iguais_qtd_portas.append(i)

        if len(iguais_qtd_portas) > 1:
            pai = r.randint(0, len(iguais_qtd_portas)-1)
            pai = iguais_qtd_portas[pai]

        else:
            pai = iguais_qtd_portas[0]

        indice_maior_fitness.clear()
        iguais.clear()
        iguais_qtd_portas.clear()

        if WIRES_LOCAL[0][0] < WIRES_LOCAL[pai][0]:
            for i in range(len(GENS_EVOL[0])):
                if GENS_EVOL[0][i] != GENS_EVOL[pai][i]:

                    if i >= ni and i != ni+Ln and i < ni+Ln:
                        if GENS_EVOL[0][i][2] != GENS_EVOL[pai][i][2]:
                            if GENS_EVOL[0][i][2] == 900:
                                if GENS_EVOL[pai][i][2] == 100:
                                    MATRIZ_REGIAO_FACTIVEL[0][1][0] = MATRIZ_REGIAO_FACTIVEL[0][1][0] + 1
                                if GENS_EVOL[pai][i][2] == 110:
                                    MATRIZ_REGIAO_FACTIVEL[0][2][0] = MATRIZ_REGIAO_FACTIVEL[0][2][0] + 1
                                if GENS_EVOL[pai][i][2] == 130:
                                    MATRIZ_REGIAO_FACTIVEL[0][3][0] = MATRIZ_REGIAO_FACTIVEL[0][3][0] + 1
                                if GENS_EVOL[pai][i][2] == 800:
                                    MATRIZ_REGIAO_FACTIVEL[0][4][0] = MATRIZ_REGIAO_FACTIVEL[0][4][0] + 1
                                if GENS_EVOL[pai][i][2] == 150:
                                    MATRIZ_REGIAO_FACTIVEL[0][5][0] = MATRIZ_REGIAO_FACTIVEL[0][5][0] + 1
                                if GENS_EVOL[pai][i][2] == 160:
                                    MATRIZ_REGIAO_FACTIVEL[0][6][0] = MATRIZ_REGIAO_FACTIVEL[0][6][0] + 1
                                if GENS_EVOL[pai][i][2] == 980:
                                    MATRIZ_REGIAO_FACTIVEL[0][7][0] = MATRIZ_REGIAO_FACTIVEL[0][7][0] + 1
                                if GENS_EVOL[pai][i][2] == 990:
                                    MATRIZ_REGIAO_FACTIVEL[0][8][0] = MATRIZ_REGIAO_FACTIVEL[0][8][0] + 1
                                                            
                                                                    
                            if GENS_EVOL[0][i][2] == 100:
                                if GENS_EVOL[pai][i][2] == 900:
                                    MATRIZ_REGIAO_FACTIVEL[1][0][0] = MATRIZ_REGIAO_FACTIVEL[1][0][0] + 1
                                if GENS_EVOL[pai][i][2] == 110:
                                    MATRIZ_REGIAO_FACTIVEL[1][2][0] = MATRIZ_REGIAO_FACTIVEL[1][2][0] + 1
                                if GENS_EVOL[pai][i][2] == 130:
                                    MATRIZ_REGIAO_FACTIVEL[1][3][0] = MATRIZ_REGIAO_FACTIVEL[1][3][0] + 1
                                if GENS_EVOL[pai][i][2] == 800:
                                    MATRIZ_REGIAO_FACTIVEL[1][4][0] = MATRIZ_REGIAO_FACTIVEL[1][4][0] + 1
                                if GENS_EVOL[pai][i][2] == 150:
                                    MATRIZ_REGIAO_FACTIVEL[1][5][0] = MATRIZ_REGIAO_FACTIVEL[1][5][0] + 1
                                if GENS_EVOL[pai][i][2] == 160:
                                    MATRIZ_REGIAO_FACTIVEL[1][6][0] = MATRIZ_REGIAO_FACTIVEL[1][6][0] + 1
                                if GENS_EVOL[pai][i][2] == 980:
                                    MATRIZ_REGIAO_FACTIVEL[1][7][0] = MATRIZ_REGIAO_FACTIVEL[1][7][0] + 1
                                if GENS_EVOL[pai][i][2] == 990:
                                    MATRIZ_REGIAO_FACTIVEL[1][8][0] = MATRIZ_REGIAO_FACTIVEL[1][8][0] + 1                            
                            if GENS_EVOL[0][i][2] == 110:
                                if GENS_EVOL[pai][i][2] == 900:
                                    MATRIZ_REGIAO_FACTIVEL[2][0][0] = MATRIZ_REGIAO_FACTIVEL[2][0][0] + 1
                                if GENS_EVOL[pai][i][2] == 100:
                                    MATRIZ_REGIAO_FACTIVEL[2][1][0] = MATRIZ_REGIAO_FACTIVEL[2][1][0] + 1
                                if GENS_EVOL[pai][i][2] == 130:
                                    MATRIZ_REGIAO_FACTIVEL[2][3][0] = MATRIZ_REGIAO_FACTIVEL[2][3][0] + 1
                                if GENS_EVOL[pai][i][2] == 800:
                                    MATRIZ_REGIAO_FACTIVEL[2][4][0] = MATRIZ_REGIAO_FACTIVEL[2][4][0] + 1
                                if GENS_EVOL[pai][i][2] == 150:
                                    MATRIZ_REGIAO_FACTIVEL[2][5][0] = MATRIZ_REGIAO_FACTIVEL[2][5][0] + 1
                                if GENS_EVOL[pai][i][2] == 160:
                                    MATRIZ_REGIAO_FACTIVEL[2][6][0] = MATRIZ_REGIAO_FACTIVEL[2][6][0] + 1
                                if GENS_EVOL[pai][i][2] == 980:
                                    MATRIZ_REGIAO_FACTIVEL[2][7][0] = MATRIZ_REGIAO_FACTIVEL[2][7][0] + 1
                                if GENS_EVOL[pai][i][2] == 990:
                                    MATRIZ_REGIAO_FACTIVEL[2][8][0] = MATRIZ_REGIAO_FACTIVEL[2][8][0] + 1                                    
                            if GENS_EVOL[0][i][2] == 130:
                                if GENS_EVOL[pai][i][2] == 900:
                                    MATRIZ_REGIAO_FACTIVEL[3][0][0] = MATRIZ_REGIAO_FACTIVEL[3][0][0] + 1
                                if GENS_EVOL[pai][i][2] == 100:
                                    MATRIZ_REGIAO_FACTIVEL[3][1][0] = MATRIZ_REGIAO_FACTIVEL[3][1][0] + 1
                                if GENS_EVOL[pai][i][2] == 110:
                                    MATRIZ_REGIAO_FACTIVEL[3][2][0] = MATRIZ_REGIAO_FACTIVEL[3][2][0] + 1
                                if GENS_EVOL[pai][i][2] == 800:
                                    MATRIZ_REGIAO_FACTIVEL[3][4][0] = MATRIZ_REGIAO_FACTIVEL[3][4][0] + 1
                                if GENS_EVOL[pai][i][2] == 150:
                                    MATRIZ_REGIAO_FACTIVEL[3][5][0] = MATRIZ_REGIAO_FACTIVEL[3][5][0] + 1
                                if GENS_EVOL[pai][i][2] == 160:
                                    MATRIZ_REGIAO_FACTIVEL[3][6][0] = MATRIZ_REGIAO_FACTIVEL[3][6][0] + 1
                                if GENS_EVOL[pai][i][2] == 980:
                                    MATRIZ_REGIAO_FACTIVEL[3][7][0] = MATRIZ_REGIAO_FACTIVEL[3][7][0] + 1
                                if GENS_EVOL[pai][i][2] == 990:
                                    MATRIZ_REGIAO_FACTIVEL[3][8][0] = MATRIZ_REGIAO_FACTIVEL[3][8][0] + 1                                    
                            if GENS_EVOL[0][i][2] == 800:
                                if GENS_EVOL[pai][i][2] == 900:
                                    MATRIZ_REGIAO_FACTIVEL[4][0][0] = MATRIZ_REGIAO_FACTIVEL[4][0][0] + 1
                                if GENS_EVOL[pai][i][2] == 100:
                                    MATRIZ_REGIAO_FACTIVEL[4][1][0] = MATRIZ_REGIAO_FACTIVEL[4][1][0] + 1
                                if GENS_EVOL[pai][i][2] == 110:
                                    MATRIZ_REGIAO_FACTIVEL[4][2][0] = MATRIZ_REGIAO_FACTIVEL[4][2][0] + 1
                                if GENS_EVOL[pai][i][2] == 130:
                                    MATRIZ_REGIAO_FACTIVEL[4][3][0] = MATRIZ_REGIAO_FACTIVEL[4][3][0] + 1
                                if GENS_EVOL[pai][i][2] == 150:
                                    MATRIZ_REGIAO_FACTIVEL[4][5][0] = MATRIZ_REGIAO_FACTIVEL[4][5][0] + 1
                                if GENS_EVOL[pai][i][2] == 160:
                                    MATRIZ_REGIAO_FACTIVEL[4][6][0] = MATRIZ_REGIAO_FACTIVEL[4][6][0] + 1
                                if GENS_EVOL[pai][i][2] == 980:
                                    MATRIZ_REGIAO_FACTIVEL[4][7][0] = MATRIZ_REGIAO_FACTIVEL[4][7][0] + 1
                                if GENS_EVOL[pai][i][2] == 990:
                                    MATRIZ_REGIAO_FACTIVEL[4][8][0] = MATRIZ_REGIAO_FACTIVEL[4][8][0] + 1

                            if GENS_EVOL[0][i][2] == 150:
                                if GENS_EVOL[pai][i][2] == 900:
                                    MATRIZ_REGIAO_FACTIVEL[5][0][0] = MATRIZ_REGIAO_FACTIVEL[5][0][0] + 1
                                if GENS_EVOL[pai][i][2] == 100:
                                    MATRIZ_REGIAO_FACTIVEL[5][1][0] = MATRIZ_REGIAO_FACTIVEL[5][1][0] + 1
                                if GENS_EVOL[pai][i][2] == 110:
                                    MATRIZ_REGIAO_FACTIVEL[5][2][0] = MATRIZ_REGIAO_FACTIVEL[5][2][0] + 1
                                if GENS_EVOL[pai][i][2] == 130:
                                    MATRIZ_REGIAO_FACTIVEL[5][3][0] = MATRIZ_REGIAO_FACTIVEL[5][3][0] + 1
                                if GENS_EVOL[pai][i][2] == 800:
                                    MATRIZ_REGIAO_FACTIVEL[5][4][0] = MATRIZ_REGIAO_FACTIVEL[5][4][0] + 1
                                if GENS_EVOL[pai][i][2] == 160:
                                    MATRIZ_REGIAO_FACTIVEL[5][6][0] = MATRIZ_REGIAO_FACTIVEL[5][6][0] + 1
                                if GENS_EVOL[pai][i][2] == 980:
                                    MATRIZ_REGIAO_FACTIVEL[5][7][0] = MATRIZ_REGIAO_FACTIVEL[5][7][0] + 1
                                if GENS_EVOL[pai][i][2] == 990:
                                    MATRIZ_REGIAO_FACTIVEL[5][8][0] = MATRIZ_REGIAO_FACTIVEL[5][8][0] + 1                             
                            if GENS_EVOL[0][i][2] == 160:
                                if GENS_EVOL[pai][i][2] == 900:
                                    MATRIZ_REGIAO_FACTIVEL[6][0][0] = MATRIZ_REGIAO_FACTIVEL[6][0][0] + 1
                                if GENS_EVOL[pai][i][2] == 100:
                                    MATRIZ_REGIAO_FACTIVEL[6][1][0] = MATRIZ_REGIAO_FACTIVEL[6][1][0] + 1
                                if GENS_EVOL[pai][i][2] == 110:
                                    MATRIZ_REGIAO_FACTIVEL[6][2][0] = MATRIZ_REGIAO_FACTIVEL[6][2][0] + 1
                                if GENS_EVOL[pai][i][2] == 130:
                                    MATRIZ_REGIAO_FACTIVEL[6][3][0] = MATRIZ_REGIAO_FACTIVEL[6][3][0] + 1
                                if GENS_EVOL[pai][i][2] == 800:
                                    MATRIZ_REGIAO_FACTIVEL[6][4][0] = MATRIZ_REGIAO_FACTIVEL[6][4][0] + 1
                                if GENS_EVOL[pai][i][2] == 150:
                                    MATRIZ_REGIAO_FACTIVEL[6][5][0] = MATRIZ_REGIAO_FACTIVEL[6][5][0] + 1
                                if GENS_EVOL[pai][i][2] == 980:
                                    MATRIZ_REGIAO_FACTIVEL[6][7][0] = MATRIZ_REGIAO_FACTIVEL[6][7][0] + 1
                                if GENS_EVOL[pai][i][2] == 990:
                                    MATRIZ_REGIAO_FACTIVEL[6][8][0] = MATRIZ_REGIAO_FACTIVEL[6][8][0] + 1
                            if GENS_EVOL[0][i][2] == 980:
                                if GENS_EVOL[pai][i][2] == 900:
                                    MATRIZ_REGIAO_FACTIVEL[7][0][0] = MATRIZ_REGIAO_FACTIVEL[7][0][0] + 1
                                if GENS_EVOL[pai][i][2] == 100:
                                    MATRIZ_REGIAO_FACTIVEL[7][1][0] = MATRIZ_REGIAO_FACTIVEL[7][1][0] + 1
                                if GENS_EVOL[pai][i][2] == 110:
                                    MATRIZ_REGIAO_FACTIVEL[7][2][0] = MATRIZ_REGIAO_FACTIVEL[7][2][0] + 1
                                if GENS_EVOL[pai][i][2] == 130:
                                    MATRIZ_REGIAO_FACTIVEL[7][3][0] = MATRIZ_REGIAO_FACTIVEL[7][3][0] + 1
                                if GENS_EVOL[pai][i][2] == 800:
                                    MATRIZ_REGIAO_FACTIVEL[7][4][0] = MATRIZ_REGIAO_FACTIVEL[7][4][0] + 1
                                if GENS_EVOL[pai][i][2] == 150:
                                    MATRIZ_REGIAO_FACTIVEL[7][5][0] = MATRIZ_REGIAO_FACTIVEL[7][5][0] + 1
                                if GENS_EVOL[pai][i][2] == 160:
                                    MATRIZ_REGIAO_FACTIVEL[7][6][0] = MATRIZ_REGIAO_FACTIVEL[7][6][0] + 1
                                if GENS_EVOL[pai][i][2] == 990:
                                    MATRIZ_REGIAO_FACTIVEL[7][8][0] = MATRIZ_REGIAO_FACTIVEL[7][8][0] + 1
                            if GENS_EVOL[0][i][2] == 990:
                                if GENS_EVOL[pai][i][2] == 900:
                                    MATRIZ_REGIAO_FACTIVEL[8][0][0] = MATRIZ_REGIAO_FACTIVEL[8][0][0] + 1
                                if GENS_EVOL[pai][i][2] == 100:
                                    MATRIZ_REGIAO_FACTIVEL[8][1][0] = MATRIZ_REGIAO_FACTIVEL[8][1][0] + 1
                                if GENS_EVOL[pai][i][2] == 110:
                                    MATRIZ_REGIAO_FACTIVEL[8][2][0] = MATRIZ_REGIAO_FACTIVEL[8][2][0] + 1
                                if GENS_EVOL[pai][i][2] == 130:
                                    MATRIZ_REGIAO_FACTIVEL[8][3][0] = MATRIZ_REGIAO_FACTIVEL[8][3][0] + 1
                                if GENS_EVOL[pai][i][2] == 800:
                                    MATRIZ_REGIAO_FACTIVEL[8][4][0] = MATRIZ_REGIAO_FACTIVEL[8][4][0] + 1
                                if GENS_EVOL[pai][i][2] == 150:
                                    MATRIZ_REGIAO_FACTIVEL[8][5][0] = MATRIZ_REGIAO_FACTIVEL[8][5][0] + 1
                                if GENS_EVOL[pai][i][2] == 160:
                                    MATRIZ_REGIAO_FACTIVEL[8][6][0] = MATRIZ_REGIAO_FACTIVEL[8][6][0] + 1
                                if GENS_EVOL[pai][i][2] == 980:
                                    MATRIZ_REGIAO_FACTIVEL[8][7][0] = MATRIZ_REGIAO_FACTIVEL[8][7][0] + 1  
    

                    
        GENS_EVOL[0] = copy.deepcopy(GENS_EVOL[pai])


def atualiza_pai_PORTAS_AOLONGO(): #Quantifica a quantidade de acertos da tabela verdade e a quantidade de portas (sugestão do Heder), ao longo de todo o processo
    soma = 0
    fitness_soma = [] # Array que armazena a soma de todas as saídas de cada circuito
    aux = []
    for k in range(ee_lambda + 1):
        fitness_soma.append([])
    for i in range(len(FITNESS_EE)):
        for j in range(len(FITNESS_EE[i])):
            soma = soma + FITNESS_EE[i][j]
        fitness_soma[i] = copy.deepcopy(soma)
        soma = 0
    maior_fitness = max(fitness_soma)
    indice_maior_fitness = [] #Array que armazena os índices dos genótipos com a maior fitness existente
    iguais = [] #Array que armazena o número de portas correspondente a cada um dos genótipos com maior fitness existente
    iguais_qtd_portas = [] #Array que armazena os índices dos genótipos cujas fitness são iguais e a quantidade de portas também, caso a quantidade de portas seja a menor existente
    for i in range(len(fitness_soma)):
        if fitness_soma[i] == maior_fitness:
            indice_maior_fitness.append(i)
    for i in range(ee_lambda + 1):
        PORTAS_EE[i][no-1] = copy.deepcopy(PORTAS_CKT[i])
    for i in range(len(indice_maior_fitness)):
        iguais.append(PORTAS_EE[indice_maior_fitness[i]][no-1])
    menor_porta = min(iguais)
    for i in range(len(PORTAS_EE)):
        if PORTAS_EE[i][no-1] == menor_porta and fitness_soma[i] == maior_fitness:
            iguais_qtd_portas.append(i)
    if len(iguais_qtd_portas) > 1:
        pai = r.randint(0, len(iguais_qtd_portas)-1)
        pai = iguais_qtd_portas[pai]
    else:
        pai = iguais_qtd_portas[0]
    indice_maior_fitness.clear()
    iguais.clear()
    iguais_qtd_portas.clear()

    GENS_EVOL[0] = copy.deepcopy(GENS_EVOL[pai]) #Atualiza novo pai


def atualiza_pai_WIRES_AOLONGO(): #Quantifica a quantidade de acertos da tabela verdade e a quantidade de portas (sugestão do Heder), ao longo de todo o processo
    soma = 0
    fitness_soma = [] # Array que armazena a soma de todas as saídas de cada circuito
    aux = []
    for k in range(ee_lambda + 1):
        fitness_soma.append([])
    for i in range(len(FITNESS_EE)):
        for j in range(len(FITNESS_EE[i])):
            soma = soma + FITNESS_EE[i][j]
        fitness_soma[i] = copy.deepcopy(soma)
        soma = 0
    maior_fitness = max(fitness_soma)
    indice_maior_fitness = [] #Array que armazena os índices dos genótipos com a maior fitness existente
    iguais = [] #Array que armazena o número de portas correspondente a cada um dos genótipos com maior fitness existente
    iguais_qtd_portas = [] #Array que armazena os índices dos genótipos cujas fitness são iguais e a quantidade de portas também, caso a quantidade de portas seja a menor existente
    for i in range(len(fitness_soma)):
        if fitness_soma[i] == maior_fitness:
            indice_maior_fitness.append(i)
    WIRES_LOCAL = []
    for i in range(ee_lambda + 1):
        WIRES_LOCAL.append([])
        for j in range(1):
            WIRES_LOCAL[i].append([])
            WIRES_LOCAL[i][0] = copy.deepcopy(WIRES_CKT[i])

    for i in range(len(indice_maior_fitness)):
        iguais.append(WIRES_LOCAL[indice_maior_fitness[i]][0])
    maior_wires = max(iguais)
    for i in range(len(WIRES_LOCAL)):
        if WIRES_LOCAL[i][0] == maior_wires and fitness_soma[i] == maior_fitness:
            iguais_qtd_portas.append(i)
    if len(iguais_qtd_portas) > 1:
        pai = r.randint(0, len(iguais_qtd_portas)-1)
        pai = iguais_qtd_portas[pai]
    else:
        pai = iguais_qtd_portas[0]
    indice_maior_fitness.clear()
    iguais.clear()
    iguais_qtd_portas.clear()

    GENS_EVOL[0] = copy.deepcopy(GENS_EVOL[pai]) #Atualiza novo pai

def mutacao_BiasedSAM_INFACTIVEL(posicao):

    todos_ativos = []
    for i in range(len(MEUARRAY[posicao])):
        for j in range(len(MEUARRAY[posicao][i])):
            if MEUARRAY[posicao][i][j] == "X":
                todos_ativos.append(j)
    ATIVO_MOM.clear()
    ATIVO_MOM.append([])
    ATIVO_MOM[0] = copy.deepcopy(MEUARRAY[posicao][0])
    for i in range(len(ATIVO_MOM[0])):
        if ATIVO_MOM[0][i] == "X":
            ATIVO_MOM[0][i] == "-"
    for i in todos_ativos:
        ATIVO_MOM[0][i] = "X"

    controle_ativo = True
    controle_auxiliar = 0 # Esta variável serve para o index da lista ATIVO_MOM[g][gene_mutado] não ser violado

        #FICA FAZENDO MUTAÇÃO
    for g in range(1): # Se for range(no), fará mutação em ao menos UM nó ativo para CADA saida, se for range(1), mudará somente UM gene ativo de todo o genótipo 
        qtd_mutacao = r.randint(1, ug) #Determina quantos nós serão mutados, dentro do intervalo recomendado pela literatura
        while controle_ativo == True: #Realiza "qtd_mutacao" de mutações NESTE descendente
            G = copy.deepcopy(GENS_EVOL[0]) #Busca o pai original de volta (sempre alocado em GENS_EVOL[0])
            gene_mutado = r.randint(ni, (ni+no+Ln-1)) #O gene que será mutado pode receber qualquer valor maior que o último espaço ocupado pela entrada, isto é da posição ni (já que começa por 0) até a posição da última saida

            if gene_mutado > ni+Ln-1:
                controle_ativo = False
                controle_auxiliar = gene_mutado
                gene_mutado = 0
            if ATIVO_MOM[g][gene_mutado] == "X" and controle_ativo == True:

                if gene_mutado > ni+Ln-1:
                    controle_ativo = False
                    controle_auxiliar = gene_mutado
                    gene_mutado = 0
                controle_ativo = False

            if controle_auxiliar != 0:
                gene_mutado = controle_auxiliar
                controle_auxiliar = 0

            if gene_mutado >= (Ln+ni): #Garante que o gene selecionado é uma saída
                #print("MUTAÇÃO TIPO SAIDA")
                ultimo_elemento = ni + Ln - 1 #Último elemento possivel que a saída pode assumir
                primeiro_elemento = ultimo_elemento - (lb * nr) + 1 #Primeiro valor possivel que a saída pode assumir
                elementos_portas = ultimo_elemento - primeiro_elemento + 1 #Quantidade de valores existentes entre o primeiro e último possiveis valores
                qtd_elementos = elementos_portas + ni - 1 #Determina a quantidade de valores distintos que a porta pode assumir como entrada. O -1 tem como função apenas possibilitar o uso de randint(0, qtd_elementos)
                entrada_ou_porta = r.randint(0, qtd_elementos) #Dá a mesma chance para todos os possiveis inputs
                if entrada_ou_porta >= ni: #G[Ln+ni+i] representa cada saida, sequencialmente
                    nova_saida = r.randint(primeiro_elemento, ultimo_elemento)
                    while G[gene_mutado] == nova_saida: #Garante que a mutação mudará o gene_mutado para um valor diferente do inicial
                        nova_saida = r.randint(primeiro_elemento, ultimo_elemento)
                    G[gene_mutado] = nova_saida
                else:
                    nova_saida = r.randint(0, ni-1)
                    while G[gene_mutado] == nova_saida: #Garante que a mutação mudará o gene_mutado para um valor diferente do inicial
                        nova_saida = r.randint(0, ni-1)
                    G[gene_mutado] = nova_saida    
            else:
                colunaatual = int((gene_mutado - ni)/nr) + 1 #Determina a coluna na qual o gene selecionado está
                alelo_mutado = r.randint(0, max_entradas) #Determina qual será o alelo a ser mutado

        
                if alelo_mutado == max_entradas: #Significa que a mutação ocorrerá no tipo da porta
                    #print("MUTAÇÃO TIPO PORTA")
                    porta_logica = r.randint(0, 99) #Determina qual será a nova porta
                    if G[gene_mutado][alelo_mutado] == 900:
                        G[gene_mutado][alelo_mutado] = MUT_WIRE_5_INFAC[porta_logica]
                    if G[gene_mutado][alelo_mutado] == 100:
                          G[gene_mutado][alelo_mutado] = MUT_AND_5_INFAC[porta_logica]
                    if G[gene_mutado][alelo_mutado] == 110:
                          G[gene_mutado][alelo_mutado] = MUT_OR_5_INFAC[porta_logica]
                    if G[gene_mutado][alelo_mutado] == 130:
                          G[gene_mutado][alelo_mutado] = MUT_XOR_5_INFAC[porta_logica]
                    if G[gene_mutado][alelo_mutado] == 800:
                          G[gene_mutado][alelo_mutado] = MUT_NOT_5_INFAC[porta_logica]
                else:
                    #print("MUTAÇÃO TIPO INPUT")
                    if colunaatual == 1: #Neste caso as portas lógicas só recebem inputs
                        entrada = r.randint(0, (ni-1))
                        while G[gene_mutado][alelo_mutado] == entrada:#Garante que a mutação mudará o gene_mutado para um valor diferente do inicial
                            entrada = r.randint(0, (ni-1))
                        G[gene_mutado][alelo_mutado] = entrada
    
                        
                    if colunaatual - lb < 1 and colunaatual != 1: #Neste caso as portas lógicas recebem inputs e nós       
                        valorpossivel = (nr * (colunaatual-2)) + (nr-1) + ni
                        sorteado = r.randint(0, valorpossivel)
                        while G[gene_mutado][alelo_mutado] == sorteado:#Garante que a mutação mudará o gene_mutado para um valor diferente do inicial
                            sorteado = r.randint(0, valorpossivel)
                        G[gene_mutado][alelo_mutado] = sorteado
    
                
                    if colunaatual - lb >= 1: #Neste caso as portas logicas recebem somente nós
                        primeiro_elemento = nr * (colunaatual-lb-1) + ni # O fator + ni serve para deslocar os elementos para frente, contando a quantidade de inputs.
                        ultimo_elemento = (nr * (colunaatual-2)) + (nr-1) + ni 
                        elementos_portas = ultimo_elemento - primeiro_elemento + 1 #Determina quantas portas possíveis existem
                        qtd_elementos = elementos_portas + ni - 1 #Determina a quantidade de valores distintos que a porta pode assumir como entrada. O -1 tem como função apenas possibilitar o uso de randint(0, qtd_elementos)
                        entrada_ou_porta = r.randint(0, qtd_elementos) #Dá a mesma chance para todos os possiveis inputs
                        if entrada_ou_porta >= ni:
                            novo_valor_mutacao = r.randint(primeiro_elemento, ultimo_elemento)
                            while G[gene_mutado][alelo_mutado] == novo_valor_mutacao:#Garante que a mutação mudará o gene_mutado para um valor diferente do inicial
                                novo_valor_mutacao = r.randint(primeiro_elemento, ultimo_elemento)
                            G[gene_mutado][alelo_mutado] = novo_valor_mutacao
                        else:
                            novo_valor_mutacao = r.randint(0, ni-1)
                            while G[gene_mutado][alelo_mutado] == novo_valor_mutacao:#Garante que a mutação mudará o gene_mutado para um valor diferente do inicial
                                novo_valor_mutacao = r.randint(0, ni-1)
                            G[gene_mutado][alelo_mutado] = novo_valor_mutacao
        

        SAM_ativo(posicao)
        GENS_EVOL[posicao] = copy.deepcopy(G) #Passa o genótipo mutado para a matriz de genótipos

        G = copy.deepcopy(GENS_EVOL[0])


def mutacao_BiasedSAM_FACTIVEL(posicao):

    todos_ativos = []
    for i in range(len(MEUARRAY[posicao])):
        for j in range(len(MEUARRAY[posicao][i])):
            if MEUARRAY[posicao][i][j] == "X":
                todos_ativos.append(j)
    ATIVO_MOM.clear()
    ATIVO_MOM.append([])
    ATIVO_MOM[0] = copy.deepcopy(MEUARRAY[posicao][0])
    for i in range(len(ATIVO_MOM[0])):
        if ATIVO_MOM[0][i] == "X":
            ATIVO_MOM[0][i] == "-"
    for i in todos_ativos:
        ATIVO_MOM[0][i] = "X"

    quantidade_de_mutacoes = 0
    controle_ativo = True
    controle_auxiliar = 0 # Esta variável serve para o index da lista ATIVO_MOM[g][gene_mutado] não ser violado

        #FICA FAZENDO MUTAÇÃO
    for g in range(1): # Se for range(no), fará mutação em ao menos UM nó ativo para CADA saida, se for range(1), mudará somente UM gene ativo de todo o genótipo 
        qtd_mutacao = r.randint(1, ug) #Determina quantos nós serão mutados, dentro do intervalo recomendado pela literatura
        while controle_ativo == True: #Realiza "qtd_mutacao" de mutações NESTE descendente
            G = copy.deepcopy(GENS_EVOL[0]) #Busca o pai original de volta (sempre alocado em GENS_EVOL[0])
            gene_mutado = r.randint(ni, (ni+no+Ln-1)) #O gene que será mutado pode receber qualquer valor maior que o último espaço ocupado pela entrada, isto é da posição ni (já que começa por 0) até a posição da última saida

            if gene_mutado > ni+Ln-1:
                quantidade_de_mutacoes +=1
                if quantidade_de_mutacoes == GLOBAL_SAM_MUTACOES:
                    controle_ativo = False
                controle_auxiliar = gene_mutado
                gene_mutado = 0
            if ATIVO_MOM[g][gene_mutado] == "X" and controle_ativo == True:

                if gene_mutado > ni+Ln-1:
                    quantidade_de_mutacoes +=1
                    if quantidade_de_mutacoes == GLOBAL_SAM_MUTACOES:
                        controle_ativo = False
                    controle_auxiliar = gene_mutado
                    gene_mutado = 0
                quantidade_de_mutacoes += 1
                if quantidade_de_mutacoes == GLOBAL_SAM_MUTACOES:
                    controle_ativo = False

            if controle_auxiliar != 0:
                gene_mutado = controle_auxiliar
                controle_auxiliar = 0

            if gene_mutado >= (Ln+ni): #Garante que o gene selecionado é uma saída
                #print("MUTAÇÃO TIPO SAIDA")
                ultimo_elemento = ni + Ln - 1 #Último elemento possivel que a saída pode assumir
                primeiro_elemento = ultimo_elemento - (lb * nr) + 1 #Primeiro valor possivel que a saída pode assumir
                elementos_portas = ultimo_elemento - primeiro_elemento + 1 #Quantidade de valores existentes entre o primeiro e último possiveis valores
                qtd_elementos = elementos_portas + ni - 1 #Determina a quantidade de valores distintos que a porta pode assumir como entrada. O -1 tem como função apenas possibilitar o uso de randint(0, qtd_elementos)
                entrada_ou_porta = r.randint(0, qtd_elementos) #Dá a mesma chance para todos os possiveis inputs
                if entrada_ou_porta >= ni: #G[Ln+ni+i] representa cada saida, sequencialmente
                    nova_saida = r.randint(primeiro_elemento, ultimo_elemento)
                    while G[gene_mutado] == nova_saida: #Garante que a mutação mudará o gene_mutado para um valor diferente do inicial
                        nova_saida = r.randint(primeiro_elemento, ultimo_elemento)
                    G[gene_mutado] = nova_saida
                else:
                    nova_saida = r.randint(0, ni-1)
                    while G[gene_mutado] == nova_saida: #Garante que a mutação mudará o gene_mutado para um valor diferente do inicial
                        nova_saida = r.randint(0, ni-1)
                    G[gene_mutado] = nova_saida    
            else:
                colunaatual = int((gene_mutado - ni)/nr) + 1 #Determina a coluna na qual o gene selecionado está
                alelo_mutado = r.randint(0, max_entradas) #Determina qual será o alelo a ser mutado

        
                if alelo_mutado == max_entradas: #Significa que a mutação ocorrerá no tipo da porta
                    #print("MUTAÇÃO TIPO PORTA")
                    porta_logica = r.randint(0, 99) #Determina qual será a nova porta
                    if G[gene_mutado][alelo_mutado] == 100:
                          G[gene_mutado][alelo_mutado] = MUT_AND_5_FAC[porta_logica]
                    if G[gene_mutado][alelo_mutado] == 110:
                          G[gene_mutado][alelo_mutado] = MUT_OR_5_FAC[porta_logica]
                    if G[gene_mutado][alelo_mutado] == 130:
                          G[gene_mutado][alelo_mutado] = MUT_XOR_5_FAC[porta_logica]
                    if G[gene_mutado][alelo_mutado] == 900:
                          G[gene_mutado][alelo_mutado] = MUT_WIRE_5_FAC[porta_logica]            
                    if G[gene_mutado][alelo_mutado] == 800:
                          G[gene_mutado][alelo_mutado] = MUT_NOT_5_FAC[porta_logica]
                          
                else:
                    #print("MUTAÇÃO TIPO INPUT")
                    if colunaatual == 1: #Neste caso as portas lógicas só recebem inputs
                        entrada = r.randint(0, (ni-1))
                        while G[gene_mutado][alelo_mutado] == entrada:#Garante que a mutação mudará o gene_mutado para um valor diferente do inicial
                            entrada = r.randint(0, (ni-1))
                        G[gene_mutado][alelo_mutado] = entrada
    
                        
                    if colunaatual - lb < 1 and colunaatual != 1: #Neste caso as portas lógicas recebem inputs e nós       
                        valorpossivel = (nr * (colunaatual-2)) + (nr-1) + ni
                        sorteado = r.randint(0, valorpossivel)
                        while G[gene_mutado][alelo_mutado] == sorteado:#Garante que a mutação mudará o gene_mutado para um valor diferente do inicial
                            sorteado = r.randint(0, valorpossivel)
                        G[gene_mutado][alelo_mutado] = sorteado
    
                
                    if colunaatual - lb >= 1: #Neste caso as portas logicas recebem somente nós
                        primeiro_elemento = nr * (colunaatual-lb-1) + ni # O fator + ni serve para deslocar os elementos para frente, contando a quantidade de inputs.
                        ultimo_elemento = (nr * (colunaatual-2)) + (nr-1) + ni 
                        elementos_portas = ultimo_elemento - primeiro_elemento + 1 #Determina quantas portas possíveis existem
                        qtd_elementos = elementos_portas + ni - 1 #Determina a quantidade de valores distintos que a porta pode assumir como entrada. O -1 tem como função apenas possibilitar o uso de randint(0, qtd_elementos)
                        entrada_ou_porta = r.randint(0, qtd_elementos) #Dá a mesma chance para todos os possiveis inputs
                        if entrada_ou_porta >= ni:
                            novo_valor_mutacao = r.randint(primeiro_elemento, ultimo_elemento)
                            while G[gene_mutado][alelo_mutado] == novo_valor_mutacao:#Garante que a mutação mudará o gene_mutado para um valor diferente do inicial
                                novo_valor_mutacao = r.randint(primeiro_elemento, ultimo_elemento)
                            G[gene_mutado][alelo_mutado] = novo_valor_mutacao
                        else:
                            novo_valor_mutacao = r.randint(0, ni-1)
                            while G[gene_mutado][alelo_mutado] == novo_valor_mutacao:#Garante que a mutação mudará o gene_mutado para um valor diferente do inicial
                                novo_valor_mutacao = r.randint(0, ni-1)
                            G[gene_mutado][alelo_mutado] = novo_valor_mutacao
        

        SAM_ativo(posicao)
        GENS_EVOL[posicao] = copy.deepcopy(G) #Passa o genótipo mutado para a matriz de genótipos

        G = copy.deepcopy(GENS_EVOL[0])


def COSPE_ativo(posicao):
    for j in range(no):
        print("SAIDA: ", j)
        for i in range(len(MEUARRAY[posicao][j])):
            if MEUARRAY[posicao][j][i] == "X":
                print("I = ", i, "GENE = ", GENS_EVOL[posicao][i])

## Programas

def main_SAM_G_2P():
    
    seed_inicial = 0 #Mudar este valor quando tiver que executar alguma seed específica que não começa por 0.
    teste_atual = 0 ## Referência para imprimir a população inicial
    
    for y in range(GLOBAL_QTD_TESTES):
        numero_avaliacoes = 0
        controle = True
        geracao = 0
        soma_fitness = []
        auxiliar = 0
        geracao_aux = 0
        formato_ee()
        formato_array_fitness()
        gera_formato_nos()
        formato_tabela_verdade()
        gera_formato_genotipo()
        r.seed(y + seed_inicial)

        
        for t in range(ee_lambda + 1): # Gera a população inicial, diferente entre si (aleatoriamente).
            populacao_inicial()
            define_saida()
            for j in range(ni):
                G[j] = copy.deepcopy(j)
            GENS_EVOL[t] = copy.deepcopy(G)
            
        nos_ativos()
        for w in range(ee_lambda + 1):
            conta_portas(w)
            monta_tabela(w)
            fit_auxiliar = 0
            for b in range(len(FITNESS_EE[w])):
                fit_auxiliar = fit_auxiliar + FITNESS_EE[w][b]
                if fit_auxiliar == no * len(OUTPUTS[0]):
                    print("CONVERGIU")
                    
        arquivo2 = open('semente_populacao_inicial.txt', 'a')
        arquivo2.write("\n POPULAÇÃO INICIAL " + str(y+seed_inicial) + "\n")
        arquivo2.write(str(GENS_EVOL))
        arquivo2.close()
        arquivo_inicio = open('informacoes_processo.txt', 'a')
        arquivo_inicio.write("\n SEED: " + str(y+seed_inicial))
        arquivo_inicio.close()
        primeira_convergencia = False
        muda_atualiza_pai = False
        print("ENTROU")
        print("GERAÇÃO: ", geracao)
        while numero_avaliacoes <= GLOBAL_NUM_AVALIACOES:
            tempo_inicio = time.time()

            gc.collect()

            if muda_atualiza_pai == False:
                for k in range(ee_lambda):
                    mutacao_SAM_CORRETO(k+1)
            else:
                for k in range(ee_lambda):
                    mutacao_SAM_CORRETO(k+1)

            nos_ativos()

            portas_pai = 0
            portas_filho = 0
            if primeira_convergencia == True:
                portas_pai = copy.deepcopy(PORTAS_CKT[0])
                
            for w in range(ee_lambda + 1):

                conta_portas(w)

                auxiliar2 = 0

                monta_tabela(w)

                numero_avaliacoes = numero_avaliacoes + 1

                for b in range(len(FITNESS_EE[w])):
                    auxiliar2 = auxiliar2 + FITNESS_EE[w][b]

                if auxiliar2 == (no * len(OUTPUTS[0])) and primeira_convergencia == False:
                    print(" CONVERGIU COM NÚMERO DE AVALIAÇÕES IGUAL A: ", numero_avaliacoes)
                    primeira_convergencia = True
                    muda_atualiza_pai = True
                    COSPE_ativo(w)
                    print("NÚMERO DE PORTAS: ", PORTAS_CKT[w])
                    print("INDIVIDUO: ", w)
                    arquivo_teste = open('convergencias.txt', 'a')
                    arquivo_teste.write("\n SEED: " + str(y+seed_inicial) + "\n")
                    arquivo_teste.write("CONVERGIU COM NÚMERO DE AVALIAÇÕES IGUAL A: " + str(numero_avaliacoes))
                    for j in range(no):
                        arquivo_teste.write("\n SAIDA: " + str(j))
                        for i in range(len(MEUARRAY[w][j])):
                            if MEUARRAY[w][j][i] == "X":
                                arquivo_teste.write("\n I = " + str(i) + " GENE = " + str(GENS_EVOL[w][i]))
                    
                    arquivo_teste.write("\n NÚMERO DE PORTAS: " + str(PORTAS_CKT[w]))
                    arquivo_teste.write("\n NÚMERO DE WIRES: " + str(WIRES_CKT[w]))
                    arquivo_teste.write("\n INDIVIDUO: " + str(w))
                    arquivo_teste.write("\n")
                    arquivo_teste.close()
                    numero_avaliacoes = 300000000
                    break
                    print("GENS_EVOL: ", GENS_EVOL[w])



            if muda_atualiza_pai == True:
                atualiza_pai_PORTAS_FACTIVEL()
            else:
                atualiza_pai_PORTAS_FACTIVEL()
                #atualiza_pai_CROSSOVER()

            if primeira_convergencia == True:
                portas_filho = copy.deepcopy(PORTAS_CKT[0])

            if portas_filho < portas_pai:
                arquivo_aolongo = open('informacoes_processo.txt', 'a')
                arquivo_aolongo.write("\n MUDANÇA NO NÚMERO DE PORTAS")
                arquivo_aolongo.write("\n PAI:" + str(portas_pai))
                arquivo_aolongo.write("\n FILHO: " + str(portas_filho))
                arquivo_aolongo.write("\n NÚMERO DE AVALIAÇÕES: " + str(numero_avaliacoes))
                arquivo_aolongo.close()

            soma_fitness.clear()

            for b in range(len(FITNESS_EE)):
                for c in range(len(FITNESS_EE[b])):
                    auxiliar = auxiliar + FITNESS_EE[b][c]
                soma_fitness.append(auxiliar)
                auxiliar = 0

            geracao = geracao + 1

            if geracao <= 20:
                print("\nGERAÇÃO : " + str(geracao))
                print(soma_fitness)
            if geracao % 1000 == 0:
                print("\nGERAÇÃO : " + str(geracao))
                print(soma_fitness)



        print("FIM", geracao)
        tempo_fim = time.time()
        arquivo_aolongo2 = open('informacoes_processo.txt', 'a')
        arquivo_aolongo2.write("\n FIM \n")
        arquivo_aolongo2.write("Tempo decorrido: " + str((tempo_fim - tempo_inicio)/60) + " minutos.")
        arquivo_aolongo2.write("\n")
        arquivo_aolongo2.close()
        
        #if controle == True:
        #    arquivo = open('matriz_transicao.txt','a')
        #    arquivo.write("\n")
        #    arquivo.write("NÃO CONVERGIU")
        #    arquivo.write("\n")
        #    arquivo.write(str(MATRIZ_REGIAO_INFACTIVEL))
        #    arquivo.write("\n")
        #else:
        #    arquivo = open('matriz_transicao.txt','a')
        #    arquivo.write("\n")
        #    arquivo.write("MATRIZ REGIÃO FACTÍVEL")
        #    arquivo.write("\n")
        #    arquivo.write(str(MATRIZ_REGIAO_FACTIVEL))
        #    arquivo.write("\n")

## -- ARMAZENA SEEDS QUE NÃO CONVERGIRAM E SEUS GENÓTIPOS -- ##
        if primeira_convergencia == False:
            arquivo_sem_convergencia = open('sem_convergencia.txt', 'a')
            arquivo_sem_convergencia.write("SEED : " + str(y+seed_inicial) + "\n")
            arquivo_sem_convergencia.write("FITNESS: " + str(FITNESS_EE[0]) + "\n")
            arquivo_sem_convergencia.write("MELHOR INDIVÍDUO: 0") 
            for j in range(no):
                arquivo_sem_convergencia.write("\n SAIDA: " + str(j))
                for i in range(len(MEUARRAY[0][j])):
                    if MEUARRAY[0][j][i] == "X":
                        arquivo_sem_convergencia.write("\n I = " + str(i) + " GENE = " + str(GENS_EVOL[0][i])) 
            arquivo_sem_convergencia.write("\n NÚMERO DE PORTAS: " + str(PORTAS_CKT[0]))
            arquivo_sem_convergencia.write("\n NÚMERO DE WIRES: " + str(WIRES_CKT[0]))
            arquivo_sem_convergencia.write("\n")
            arquivo_sem_convergencia.write("GENÓTIPO FINAL: " + str(GENS_EVOL[0]) + "\n")
            
            arquivo_sem_convergencia.close()  

        
        arquivo = open('matriz_transicao.txt', 'a')
        arquivo.write("\n MATRIZ INFACTIVEL \n")
        arquivo.write(str(MATRIZ_REGIAO_INFACTIVEL))
        arquivo.write("\n MATRIZ FACTIVEL \n")
        arquivo.write(str(MATRIZ_REGIAO_FACTIVEL))
        arquivo.close()

        COSPE_ativo(0)
        
        for i in range(ee_lambda + 1):
            conta_portas(i)
        print("NÚMERO DE PORTAS: ", PORTAS_EE[0][no-1])
        if primeira_convergencia == True:
            arquivo_otimizado = open('convergencias_otimizado.txt', 'a')
            arquivo_otimizado.write("\n SEED: " + str(y+seed_inicial) + "\n")
            arquivo_otimizado.write("CONVERGIU COM NÚMERO DE AVALIAÇÕES IGUAL A: " + str(numero_avaliacoes))
            for j in range(no):
                arquivo_otimizado.write("\n SAIDA: " + str(j))
                for i in range(len(MEUARRAY[0][j])):
                    if MEUARRAY[0][j][i] == "X":
                        arquivo_otimizado.write("\n I = " + str(i) + " GENE = " + str(GENS_EVOL[w][i]))
                    
            arquivo_otimizado.write("\n NÚMERO DE PORTAS: " + str(PORTAS_CKT[0]))
            arquivo_otimizado.write("\n NÚMERO DE WIRES: " + str(WIRES_CKT[0]))
            arquivo_otimizado.write("\n INDIVIDUO: " + str(w))
            arquivo_otimizado.write("\n")
            arquivo_otimizado.close()

        
        
        limpa_array()

        teste_atual = teste_atual + 1

        numero_avaliacoes = 0

#############################################################################

def main_GAM_G_2P():
    
    seed_inicial = 0 #Mudar este valor quando tiver que executar alguma seed específica que não começa por 0.
    teste_atual = 0 ## Referência para imprimir a população inicial
    
    for y in range(GLOBAL_QTD_TESTES):
        numero_avaliacoes = 0
        controle = True
        geracao = 0
        soma_fitness = []
        auxiliar = 0
        geracao_aux = 0
        formato_ee()
        formato_array_fitness()
        gera_formato_nos()
        formato_tabela_verdade()
        gera_formato_genotipo()
        r.seed(y + seed_inicial)

        
        for t in range(ee_lambda + 1): # Gera a população inicial, diferente entre si (aleatoriamente).
            populacao_inicial()
            define_saida()
            for j in range(ni):
                G[j] = copy.deepcopy(j)
            GENS_EVOL[t] = copy.deepcopy(G)
            
        nos_ativos()
        for w in range(ee_lambda + 1):
            conta_portas(w)
            monta_tabela(w)
            fit_auxiliar = 0
            for b in range(len(FITNESS_EE[w])):
                fit_auxiliar = fit_auxiliar + FITNESS_EE[w][b]
                if fit_auxiliar == no * len(OUTPUTS[0]):
                    print("CONVERGIU")
                    
        arquivo2 = open('semente_populacao_inicial.txt', 'a')
        arquivo2.write("\n POPULAÇÃO INICIAL " + str(y+seed_inicial) + "\n")
        arquivo2.write(str(GENS_EVOL))
        arquivo2.close()
        arquivo_inicio = open('informacoes_processo.txt', 'a')
        arquivo_inicio.write("\n SEED: " + str(y+seed_inicial))
        arquivo_inicio.close()
        primeira_convergencia = False
        muda_atualiza_pai = False
        print("ENTROU")
        print("GERAÇÃO: ", geracao)
        while numero_avaliacoes <= GLOBAL_NUM_AVALIACOES:
            tempo_inicio = time.time()

            gc.collect()

            if muda_atualiza_pai == False:
                for k in range(ee_lambda):
                    mutacao_GAM_CORRETO(k+1)
            else:
                for k in range(ee_lambda):
                    mutacao_GAM_CORRETO(k+1)

            nos_ativos()

            portas_pai = 0
            portas_filho = 0
            if primeira_convergencia == True:
                portas_pai = copy.deepcopy(PORTAS_CKT[0])
                
            for w in range(ee_lambda + 1):

                conta_portas(w)

                auxiliar2 = 0

                monta_tabela(w)

                numero_avaliacoes = numero_avaliacoes + 1

                for b in range(len(FITNESS_EE[w])):
                    auxiliar2 = auxiliar2 + FITNESS_EE[w][b]

                if auxiliar2 == (no * len(OUTPUTS[0])) and primeira_convergencia == False:
                    print(" CONVERGIU COM NÚMERO DE AVALIAÇÕES IGUAL A: ", numero_avaliacoes)
                    primeira_convergencia = True
                    muda_atualiza_pai = True
                    COSPE_ativo(w)
                    print("NÚMERO DE PORTAS: ", PORTAS_CKT[w])
                    print("INDIVIDUO: ", w)
                    arquivo_teste = open('convergencias.txt', 'a')
                    arquivo_teste.write("\n SEED: " + str(y+seed_inicial) + "\n")
                    arquivo_teste.write("CONVERGIU COM NÚMERO DE AVALIAÇÕES IGUAL A: " + str(numero_avaliacoes))
                    for j in range(no):
                        arquivo_teste.write("\n SAIDA: " + str(j))
                        for i in range(len(MEUARRAY[w][j])):
                            if MEUARRAY[w][j][i] == "X":
                                arquivo_teste.write("\n I = " + str(i) + " GENE = " + str(GENS_EVOL[w][i]))
                    
                    arquivo_teste.write("\n NÚMERO DE PORTAS: " + str(PORTAS_CKT[w]))
                    arquivo_teste.write("\n NÚMERO DE WIRES: " + str(WIRES_CKT[w]))
                    arquivo_teste.write("\n INDIVIDUO: " + str(w))
                    arquivo_teste.write("\n")
                    arquivo_teste.close()
                    numero_avaliacoes = 300000000
                    break
                    print("GENS_EVOL: ", GENS_EVOL[w])



            if muda_atualiza_pai == True:
                atualiza_pai_PORTAS_FACTIVEL()
            else:
                atualiza_pai_PORTAS_FACTIVEL()
                #atualiza_pai_CROSSOVER()

            if primeira_convergencia == True:
                portas_filho = copy.deepcopy(PORTAS_CKT[0])

            if portas_filho < portas_pai:
                arquivo_aolongo = open('informacoes_processo.txt', 'a')
                arquivo_aolongo.write("\n MUDANÇA NO NÚMERO DE PORTAS")
                arquivo_aolongo.write("\n PAI:" + str(portas_pai))
                arquivo_aolongo.write("\n FILHO: " + str(portas_filho))
                arquivo_aolongo.write("\n NÚMERO DE AVALIAÇÕES: " + str(numero_avaliacoes))
                arquivo_aolongo.close()

            soma_fitness.clear()

            for b in range(len(FITNESS_EE)):
                for c in range(len(FITNESS_EE[b])):
                    auxiliar = auxiliar + FITNESS_EE[b][c]
                soma_fitness.append(auxiliar)
                auxiliar = 0

            geracao = geracao + 1

            if geracao <= 20:
                print("\nGERAÇÃO : " + str(geracao))
                print(soma_fitness)
            if geracao % 1000 == 0:
                print("\nGERAÇÃO : " + str(geracao))
                print(soma_fitness)



        print("FIM", geracao)
        tempo_fim = time.time()
        arquivo_aolongo2 = open('informacoes_processo.txt', 'a')
        arquivo_aolongo2.write("\n FIM \n")
        arquivo_aolongo2.write("Tempo decorrido: " + str((tempo_fim - tempo_inicio)/60) + " minutos.")
        arquivo_aolongo2.write("\n")
        arquivo_aolongo2.close()
        
        #if controle == True:
        #    arquivo = open('matriz_transicao.txt','a')
        #    arquivo.write("\n")
        #    arquivo.write("NÃO CONVERGIU")
        #    arquivo.write("\n")
        #    arquivo.write(str(MATRIZ_REGIAO_INFACTIVEL))
        #    arquivo.write("\n")
        #else:
        #    arquivo = open('matriz_transicao.txt','a')
        #    arquivo.write("\n")
        #    arquivo.write("MATRIZ REGIÃO FACTÍVEL")
        #    arquivo.write("\n")
        #    arquivo.write(str(MATRIZ_REGIAO_FACTIVEL))
        #    arquivo.write("\n")

## -- ARMAZENA SEEDS QUE NÃO CONVERGIRAM E SEUS GENÓTIPOS -- ##
        if primeira_convergencia == False:
            arquivo_sem_convergencia = open('sem_convergencia.txt', 'a')
            arquivo_sem_convergencia.write("SEED : " + str(y+seed_inicial) + "\n")
            arquivo_sem_convergencia.write("FITNESS: " + str(FITNESS_EE[0]) + "\n")
            arquivo_sem_convergencia.write("MELHOR INDIVÍDUO: 0") 
            for j in range(no):
                arquivo_sem_convergencia.write("\n SAIDA: " + str(j))
                for i in range(len(MEUARRAY[0][j])):
                    if MEUARRAY[0][j][i] == "X":
                        arquivo_sem_convergencia.write("\n I = " + str(i) + " GENE = " + str(GENS_EVOL[0][i])) 
            arquivo_sem_convergencia.write("\n NÚMERO DE PORTAS: " + str(PORTAS_CKT[0]))
            arquivo_sem_convergencia.write("\n NÚMERO DE WIRES: " + str(WIRES_CKT[0]))
            arquivo_sem_convergencia.write("\n")
            arquivo_sem_convergencia.write("GENÓTIPO FINAL: " + str(GENS_EVOL[0]) + "\n")
            
            arquivo_sem_convergencia.close()  

        
        arquivo = open('matriz_transicao.txt', 'a')
        arquivo.write("\n MATRIZ INFACTIVEL \n")
        arquivo.write(str(MATRIZ_REGIAO_INFACTIVEL))
        arquivo.write("\n MATRIZ FACTIVEL \n")
        arquivo.write(str(MATRIZ_REGIAO_FACTIVEL))
        arquivo.close()

        COSPE_ativo(0)
        
        for i in range(ee_lambda + 1):
            conta_portas(i)
        print("NÚMERO DE PORTAS: ", PORTAS_EE[0][no-1])
        if primeira_convergencia == True:
            arquivo_otimizado = open('convergencias_otimizado.txt', 'a')
            arquivo_otimizado.write("\n SEED: " + str(y+seed_inicial) + "\n")
            arquivo_otimizado.write("CONVERGIU COM NÚMERO DE AVALIAÇÕES IGUAL A: " + str(numero_avaliacoes))
            for j in range(no):
                arquivo_otimizado.write("\n SAIDA: " + str(j))
                for i in range(len(MEUARRAY[0][j])):
                    if MEUARRAY[0][j][i] == "X":
                        arquivo_otimizado.write("\n I = " + str(i) + " GENE = " + str(GENS_EVOL[w][i]))
                    
            arquivo_otimizado.write("\n NÚMERO DE PORTAS: " + str(PORTAS_CKT[0]))
            arquivo_otimizado.write("\n NÚMERO DE WIRES: " + str(WIRES_CKT[0]))
            arquivo_otimizado.write("\n INDIVIDUO: " + str(w))
            arquivo_otimizado.write("\n")
            arquivo_otimizado.close()

        
        
        limpa_array()

        teste_atual = teste_atual + 1

        numero_avaliacoes = 0


#############################################################################


def main_SAM_G_2P_CROSSOVER():
    
    seed_inicial = 0 #Mudar este valor quando tiver que executar alguma seed específica que não começa por 0.
    teste_atual = 0 ## Referência para imprimir a população inicial
    
    for y in range(GLOBAL_QTD_TESTES):
        numero_avaliacoes = 0
        controle = True
        geracao = 0
        soma_fitness = []
        auxiliar = 0
        geracao_aux = 0
        formato_ee()
        formato_array_fitness()
        gera_formato_nos()
        formato_tabela_verdade()
        gera_formato_genotipo()
        r.seed(y + seed_inicial)
        
        for t in range(ee_lambda + 1): # Gera a população inicial, diferente entre si (aleatoriamente).
            populacao_inicial()
            define_saida()
            for j in range(ni):
                G[j] = copy.deepcopy(j)
            GENS_EVOL[t] = copy.deepcopy(G)
            
        nos_ativos()

        for w in range(ee_lambda + 1):
            conta_portas(w)
            monta_tabela(w)
            fit_auxiliar = 0
            for b in range(len(FITNESS_EE[w])):
                fit_auxiliar = fit_auxiliar + FITNESS_EE[w][b]
                if fit_auxiliar == no * len(OUTPUTS[0]):
                    print("CONVERGIU")
                                
                                
        
        arquivo2 = open('semente_populacao_inicial.txt', 'a')
        arquivo2.write("\n POPULAÇÃO INICIAL " + str(y+seed_inicial) + "\n")
        arquivo2.write(str(GENS_EVOL))
        arquivo2.close()
        
        arquivo_inicio = open('informacoes_processo.txt', 'a')
        arquivo_inicio.write("\n SEED: " + str(y+seed_inicial))
        arquivo_inicio.close()

        arquivo_evolucao_inicio = open('evolucao.txt', 'a')
        arquivo_evolucao_inicio.write("\n SEED: " + str(y+seed_inicial))
        arquivo_evolucao_inicio.write("\n")
        arquivo_evolucao_inicio.close()


        arquivo_genes_ativos = open("distribuicao_genes_ativos.txt", "a")
        arquivo_genes_ativos.write("\n SEED: " + str(y+seed_inicial))
        arquivo_genes_ativos.write("\n")
        arquivo_genes_ativos.close()

        arquivo_infoevol = open("informacoes_evolutivas.txt", "a")
        arquivo_infoevol.write("\n SEED: " + str(y+seed_inicial))
        arquivo_infoevol.write("\n")
        arquivo_infoevol.close()

        
        primeira_convergencia = False
        muda_atualiza_pai = False
        
        print("ENTROU")
        print("GERAÇÃO: ", geracao)
        while numero_avaliacoes <= GLOBAL_NUM_AVALIACOES:
            tempo_inicio = time.time()

            gc.collect()
            IND_MUT_SAM[0][0][0] = copy.deepcopy(0)
            IND_MUT_SAM[0][1][0] = copy.deepcopy(0)
            IND_MUT_SAM[1][0][0] = copy.deepcopy(0)
            IND_MUT_SAM[1][1][0] = copy.deepcopy(0)
            IND_MUT_GAM[0][0][0] = copy.deepcopy(0)
            IND_MUT_GAM[0][1][0] = copy.deepcopy(0)
            IND_MUT_GAM[1][0][0] = copy.deepcopy(0)
            IND_MUT_GAM[1][1][0] = copy.deepcopy(0)
            atualiza_matriz_mutacoes()
            #mutacao_BSAM_ADAPTATIVO()              
            if muda_atualiza_pai == False:
                arquivo_evolucao_intermediario = open('evolucao.txt', 'a')
                #arquivo_evolucao_intermediario.write("FITNESS ANTES: " + str(FITNESS_EE))
                arquivo_evolucao_intermediario.close()
                for k in range(ee_lambda):
                    #mutacao_SAM_CORRETO_CROSS(k+1)
                    #auxiliar_das_fitness = 0
                    #for i in FITNESS_EE[0]:
                    #    auxiliar_das_fitness += i
                    #if auxiliar_das_fitness == (no * len(OUTPUTS[0])) - 1:
                    #    mutacao_GAM_CORRETO(k+1)
                    #else:
                    #    mutacao_SAM_CORRETO(k+1)
                    #nova_mutacao_GAM(k+1)
                    #nova_mutacao_SAM(k+1)
                    #mutacao_GAM_CORRETO(k+1)
                    mutacao_SAM_CORRETO(k+1)
                    #if y-seed_inicial >= 0: ## para usar BSAM colocar sinal de <=
                    #    if k == 0 or k == 1:
                    #        mutacao_SAM_CORRETO(k+1)
                    #    else:
                    #        mutacao_GAM_CORRETO(k+1)
                    #else:
                    #    mutacao_BSAM_ADAPTATIVO(k+1)
            else:
                for k in range(ee_lambda):
                    mutacao_SAM_CORRETO(k+1)
                    #nova_mutacao_SAM(k+1)

            nos_ativos()

## -- CONTA A QUANTIDADE DE PORTAS DO PAI -- ##            
            portas_pai = 0
            portas_filho = 0
            if primeira_convergencia == True:
                portas_pai = copy.deepcopy(PORTAS_CKT[0])




## -- AVALIA OS LAMBDA FILHOS -- ##            
            for w in range(ee_lambda + 1):
                
                if w != 0: #Impede a reavaliação do indivíduo 0 (progenitor)
                    arquivo_evolucao = open('evolucao.txt', 'a')
                    arquivo_evolucao.write("\n --> INDIVIDUO ANALSIADO: " + str(w))
                    arquivo_evolucao.write("\n Número de avaliações: " + str(numero_avaliacoes))
                    arquivo_evolucao.write("\n Fitness antes: " + str(FITNESS_EE[w]))
                    fitness_antes_local = copy.deepcopy(FITNESS_EE[w])

                    conta_portas(w)
                    
                    #monta_tabela_MUX(w)
                    monta_tabela(w)

                    numero_avaliacoes = numero_avaliacoes + 1
                    


                    arquivo_evolucao.write("\n Fitness depois: " + str(FITNESS_EE[w]))
                    if w == 1 or w == 2:
                        #arquivo_evolucao.write("\n IND MUT SAM" + str(IND_MUT_SAM[w-1]))
                        if IND_MUT_SAM[w-1][0][0] != 0:
                            if fitness_antes_local == FITNESS_EE[w]:
                                arquivo_evolucao.write("\n MUTAÇÃO TIPO PORTA NEUTRO")
                            else:
                                for elementos in range(len(fitness_antes_local)):
                                    if fitness_antes_local[elementos] < FITNESS_EE[w][elementos]:
                                        arquivo_evolucao.write("\n HOUVE MELHORA, PELO MENOS, NA SAÍDA " + str(elementos))
                                        #arquivo_evolucao.write("\n PORTA ANTES: " + str(IND_MUT_SAM[w-1][0][0]))
                                        #arquivo_evolucao.write("\n PORTA DEPOIS: " + str(IND_MUT_SAM[w-1][1][0]))
                                        porta_antes = IND_MUT_SAM[w-1][0][0]
                                        porta_depois = IND_MUT_SAM[w-1][1][0]
                                        preenche_matriz_benefico(porta_antes, porta_depois)
                                        break
                    if w == 3 or w == 4:
                        #arquivo_evolucao.write("\n IND MUT SAM" + str(IND_MUT_SAM[w-1]))
                        if IND_MUT_GAM[w-3][0][0] != 0:
                            if fitness_antes_local == FITNESS_EE[w]:
                                arquivo_evolucao.write("\n MUTAÇÃO TIPO PORTA NEUTRO")
                            else:
                                for elementos in range(len(fitness_antes_local)):
                                    if fitness_antes_local[elementos] < FITNESS_EE[w][elementos]:
                                        arquivo_evolucao.write("\n HOUVE MELHORA, PELO MENOS, NA SAÍDA " + str(elementos))
                                        #arquivo_evolucao.write("\n PORTA ANTES: " + str(IND_MUT_SAM[w-1][0][0]))
                                        #arquivo_evolucao.write("\n PORTA DEPOIS: " + str(IND_MUT_SAM[w-1][1][0]))
                                        porta_antes = IND_MUT_GAM[w-3][0][0]
                                        porta_depois = IND_MUT_GAM[w-3][1][0]
                                        preenche_matriz_benefico(porta_antes, porta_depois)
                                        break



                                    
                    arquivo_evolucao.close()
                                                               
                else:
                    if muda_atualiza_pai == True: # Neste caso o indivíduo 0 deve ser reavaliado pois leva-se em conta o número de portas (função objetivo: minimizar o número de portas)
                        conta_portas(w)
                        monta_tabela(w)
                        numero_avaliacoes = numero_avaliacoes + 1


                #arquivo_evolucao = open('evolucao.txt', 'a')
                #arquivo_evolucao.write("\n NOVAMENTE O IND MUT: " + str(IND_MUT_SAM))
                #arquivo_evolucao.close()
## -- VERIFICA FACTIBILIDADE DOS INDIVIDUOS -- ##
                auxiliar2 = 0

                for b in range(len(FITNESS_EE[w])):
                    auxiliar2 = auxiliar2 + FITNESS_EE[w][b]

                if auxiliar2 == (no * len(OUTPUTS[0])) and primeira_convergencia == False:
                    print(" CONVERGIU COM NÚMERO DE AVALIAÇÕES IGUAL A: ", numero_avaliacoes)
                    primeira_convergencia = True
                    muda_atualiza_pai = True
                    COSPE_ativo(w)
                    print("NÚMERO DE PORTAS: ", PORTAS_CKT[w])
                    print("INDIVIDUO: ", w)
                    arquivo_teste = open('convergencias.txt', 'a')
                    arquivo_teste.write("\n SEED: " + str(y+seed_inicial) + "\n")
                    arquivo_teste.write("CONVERGIU COM NÚMERO DE AVALIAÇÕES IGUAL A: " + str(numero_avaliacoes))
                    for j in range(no):
                        arquivo_teste.write("\n SAIDA: " + str(j))
                        for i in range(len(MEUARRAY[w][j])):
                            if MEUARRAY[w][j][i] == "X":
                                arquivo_teste.write("\n I = " + str(i) + " GENE = " + str(GENS_EVOL[w][i]))
                    
                    arquivo_teste.write("\n NÚMERO DE PORTAS: " + str(PORTAS_CKT[w]))
                    arquivo_teste.write("\n NÚMERO DE WIRES: " + str(WIRES_CKT[w]))
                    arquivo_teste.write("\n INDIVIDUO: " + str(w))
                    arquivo_teste.write("\n")
                    arquivo_teste.close()
                    #GENS_EVOL[0] = copy.deepcopy(GENS_EVOL[w])
                    numero_avaliacoes = 300000000
                    break
                    #print("GENS_EVOL: ", GENS_EVOL[w])


## -- DETERMINA QUAL É A FUNÇÃO OBJETIVO: ENCONTRAR FACTIBILIDADE (CROSSOVER) OU MINIMIZAR O NÚMERO DE PORTAS (PORTAS_FACTIVEL) -- ##
            if muda_atualiza_pai == True:
                atualiza_pai_PORTAS_FACTIVEL()
            else:
                #atualiza_pai_PORTAS_FACTIVEL()
                atualiza_pai_CROSSOVER_NOVO()
                #atualiza_pai_CROSSOVER_NOVO_GENES_ATIVOS()


## -- VERIFICA SE O NOVO PROGENITOR (GERADO PELO CROSSOVER) É FACTÍVEL -- ##
                auxiliar2 = 0
                conta_portas(0)
                for b in range(len(FITNESS_EE[0])):
                    auxiliar2 = auxiliar2 + FITNESS_EE[0][b]

                if auxiliar2 == (no * len(OUTPUTS[0])) and primeira_convergencia == False:
                    print(" CONVERGIU COM NÚMERO DE AVALIAÇÕES IGUAL A: ", numero_avaliacoes)
                    primeira_convergencia = True
                    muda_atualiza_pai = True
                    COSPE_ativo(0)
                    print("NÚMERO DE PORTAS: ", PORTAS_CKT[0])
                    print("INDIVIDUO: 0", )
                    arquivo_teste = open('convergencias.txt', 'a')
                    arquivo_teste.write("\n SEED: " + str(y+seed_inicial) + "\n")
                    arquivo_teste.write("CONVERGIU COM NÚMERO DE AVALIAÇÕES IGUAL A: " + str(numero_avaliacoes))
                    for j in range(no):
                        arquivo_teste.write("\n SAIDA: " + str(j))
                        for i in range(len(MEUARRAY[0][j])):
                            if MEUARRAY[0][j][i] == "X":
                                arquivo_teste.write("\n I = " + str(i) + " GENE = " + str(GENS_EVOL[0][i]))
                    
                    arquivo_teste.write("\n NÚMERO DE PORTAS: " + str(PORTAS_CKT[0]))
                    arquivo_teste.write("\n NÚMERO DE WIRES: " + str(WIRES_CKT[0]))
                    arquivo_teste.write("\n INDIVIDUO: " + str(w))
                    arquivo_teste.write("\n")
                    arquivo_teste.close()
                    numero_avaliacoes = 300000000
                    break
                    #print("GENS_EVOL: ", GENS_EVOL[0])                


## -- VERIFICA A QUANTIDADE DE PORTAS DO FILHO SOMENTE CASO A FUNÇÃO OBJETIVO TENHA MUDADO (MINIMIZAR NÚMERO DE PORTAS LÓGICAS) -- ##
            if primeira_convergencia == True:
                portas_filho = copy.deepcopy(PORTAS_CKT[0])

            if portas_filho < portas_pai:
                arquivo_aolongo = open('informacoes_processo.txt', 'a')
                arquivo_aolongo.write("\n MUDANÇA NO NÚMERO DE PORTAS")
                arquivo_aolongo.write("\n PAI:" + str(portas_pai))
                arquivo_aolongo.write("\n FILHO: " + str(portas_filho))
                arquivo_aolongo.write("\n NÚMERO DE AVALIAÇÕES: " + str(numero_avaliacoes))
                arquivo_aolongo.close()

            soma_fitness.clear()

            for b in range(len(FITNESS_EE)):
                for c in range(len(FITNESS_EE[b])):
                    auxiliar = auxiliar + FITNESS_EE[b][c]
                soma_fitness.append(auxiliar)
                auxiliar = 0

            geracao = geracao + 1


## -- EXIBE AS FITNESS POR GERAÇÃO -- ##
            todos_ativos = []
            for genes in range(len(MEUARRAY[0])):
                for cada in range(len(MEUARRAY[0][genes])):
                    if MEUARRAY[0][genes][cada] == "X":
                        todos_ativos.append(cada)
            novo_array = []
            for itens in todos_ativos:
                if itens not in novo_array:
                    novo_array.append(itens)
            variavel_auxiliar_fitness_saida = 0
            for fitness_saida in range(len(FITNESS_EE[0])):
                variavel_auxiliar_fitness_saida += FITNESS_EE[0][fitness_saida]


            arquivo_infoevol = open("informacoes_evolutivas.txt", "a")
            arquivo_infoevol.write("\n Avaliações: " + str(numero_avaliacoes) + " Fitness Pai: " + str(FITNESS_EE[0]))
            arquivo_infoevol.close()

            arquivo_evolucao = open("evolucao.txt", "a")
            arquivo_evolucao.write("\n Fitness Pai: " + str(FITNESS_EE[0]))
            arquivo_evolucao.write(" (( " + str(variavel_auxiliar_fitness_saida) + " )) ")
            
            arquivo_evolucao.write("\n Quantidade de genes ativos: " + str(len(novo_array)))
            arquivo_evolucao.close()

            arquivo_genes_ativos = open("distribuicao_genes_ativos.txt", "a")
            arquivo_genes_ativos.write("\nGeração: " + str(geracao))
            arquivo_genes_ativos.write("\nDistribuição: " + str(novo_array))
            arquivo_genes_ativos.close()

            arquivo_genes_ativos = open("genes_ativos.txt", "a")
            arquivo_genes_ativos.write("\n" + str(geracao) + ", " + str(len(novo_array)))
            arquivo_genes_ativos.close()
            
            #print("Quantidade de genes ativos: ", len(novo_array))
            if numero_avaliacoes <= 20:
                print("\nNÚMERO DE AVALIAÇÕES : " + str(numero_avaliacoes))
                print(soma_fitness)
                #arquivo_evolucao = open("evolucao.txt", "a")
                #arquivo_evolucao.write("\n Número de avaliações: " + str(numero_avaliacoes))
                #arquivo_evolucao.write("\n Fitness pai: " + str(FITNESS_EE[0]))
                #arquivo_evolucao.write("\n Genes ativos pai: " + str(len(novo_array)))
                print("Genes ativos: ", len(novo_array))
            if numero_avaliacoes % 400 == 0:
                print("\nNÚMERO DE AVALIAÇÕES : " + str(numero_avaliacoes))
                print(soma_fitness)
                #arquivo_evolucao = open("evolucao.txt", "a")
                #arquivo_evolucao.write("\n Número de avaliações: " + str(numero_avaliacoes))
                #arquivo_evolucao.write("\n Fitness pai: " + str(FITNESS_EE[0]))
                #arquivo_evolucao.write("\n Genes ativos pai: " + str(len(novo_array)))
                print("Genes ativos: ", len(novo_array))
            if geracao <= 20:
                print("\nGERAÇÃO : " + str(geracao))
                print(soma_fitness)
            if geracao % 1000 == 0:
                print("\nGERAÇÃO : " + str(geracao))
                print(soma_fitness)



        print("FIM", geracao)
        
        tempo_fim = time.time()
        
        arquivo_aolongo2 = open('informacoes_processo.txt', 'a')
        arquivo_aolongo2.write("\n FIM \n")
        arquivo_aolongo2.write("Tempo decorrido: " + str((tempo_fim - tempo_inicio)/60) + " minutos.")
        arquivo_aolongo2.write("\n")
        arquivo_aolongo2.close()


        
## -- ARMAZENA SEEDS QUE NÃO CONVERGIRAM E SEUS GENÓTIPOS -- ##
        if primeira_convergencia == False:
            arquivo_sem_convergencia = open('sem_convergencia.txt', 'a')
            arquivo_sem_convergencia.write("SEED : " + str(y+seed_inicial) + "\n")
            arquivo_sem_convergencia.write("FITNESS: " + str(FITNESS_EE[0]) + "\n")
            arquivo_sem_convergencia.write("MELHOR INDIVÍDUO: 0") 
            for j in range(no):
                arquivo_sem_convergencia.write("\n SAIDA: " + str(j))
                for i in range(len(MEUARRAY[0][j])):
                    if MEUARRAY[0][j][i] == "X":
                        arquivo_sem_convergencia.write("\n I = " + str(i) + " GENE = " + str(GENS_EVOL[0][i])) 
            arquivo_sem_convergencia.write("\n NÚMERO DE PORTAS: " + str(PORTAS_CKT[0]))
            arquivo_sem_convergencia.write("\n NÚMERO DE WIRES: " + str(WIRES_CKT[0]))
            arquivo_sem_convergencia.write("\n")
            arquivo_sem_convergencia.write("GENÓTIPO FINAL: " + str(GENS_EVOL[0]) + "\n")
            
            arquivo_sem_convergencia.close()        
        
## -- PREENCHE ARQUIVO DE MATRIZ DE TRANSIÇÃO -- ##
        arquivo = open('matriz_transicao.txt', 'a')
        arquivo.write("\n MATRIZ INFACTIVEL \n")
        arquivo.write(str(MATRIZ_REGIAO_INFACTIVEL))
        arquivo.write("\n MATRIZ FACTIVEL \n")
        arquivo.write(str(MATRIZ_REGIAO_FACTIVEL))
        arquivo.close()

        COSPE_ativo(0)
        
        for i in range(ee_lambda + 1):
            conta_portas(i)
        print("NÚMERO DE PORTAS: ", PORTAS_EE[0][no-1])
        if primeira_convergencia == True:
            arquivo_otimizado = open('convergencias_otimizado.txt', 'a')
            arquivo_otimizado.write("\n SEED: " + str(y+seed_inicial) + "\n")
            arquivo_otimizado.write("CONVERGIU COM NÚMERO DE AVALIAÇÕES IGUAL A: " + str(numero_avaliacoes))
            for j in range(no):
                arquivo_otimizado.write("\n SAIDA: " + str(j))
                for i in range(len(MEUARRAY[0][j])):
                    if MEUARRAY[0][j][i] == "X":
                        arquivo_otimizado.write("\n I = " + str(i) + " GENE = " + str(GENS_EVOL[0][i]))
                    
            arquivo_otimizado.write("\n NÚMERO DE PORTAS: " + str(PORTAS_CKT[0]))
            arquivo_otimizado.write("\n NÚMERO DE WIRES: " + str(WIRES_CKT[0]))
            arquivo_otimizado.write("\n INDIVIDUO: " + str(0))
            arquivo_otimizado.write("\n")
            arquivo_otimizado.close()

        
        
        limpa_array()

        teste_atual = teste_atual + 1

        arquivo_evolucao = open('evolucao.txt', 'a')
        arquivo_evolucao.write("\nFREQUÊNCIA DAS MUTAÇÕES")
        arquivo_evolucao.write("\nSAM:")
        arquivo_evolucao.write("\nSAIDA: " + str(GLOBAL_MUTACAO_SAM_SAIDA))
        arquivo_evolucao.write("\nINPUT: " + str(GLOBAL_MUTACAO_SAM_INPUT))
        arquivo_evolucao.write("\nPORTA: " + str(GLOBAL_MUTACAO_SAM_PORTA))
        arquivo_evolucao.write("\n ATIVOS SAM: " + str(GLOBAL_MUTACAO_SAM_ATIVO))
        arquivo_evolucao.write("\n INATIVOS SAM: " + str(GLOBAL_MUTACAO_SAM_INATIVO))        
        arquivo_evolucao.write("\nGAM:")
        arquivo_evolucao.write("\nSAIDA: " + str(GLOBAL_MUTACAO_GAM_SAIDA))
        arquivo_evolucao.write("\nINPUT: " + str(GLOBAL_MUTACAO_GAM_INPUT))
        arquivo_evolucao.write("\nPORTA: " + str(GLOBAL_MUTACAO_GAM_PORTA))
        arquivo_evolucao.write("\n ATIVOS GAM: " + str(GLOBAL_MUTACAO_GAM_ATIVO))
        arquivo_evolucao.write("\n INATIVOS GAM: " + str(GLOBAL_MUTACAO_GAM_INATIVO))
        arquivo_evolucao.write("\n")
        arquivo_evolucao.write("\n QUANTIDADE DE CROSSOVERS REALIZADOS: " + str(GLOBAL_QTD_CROSSOVER))
        arquivo_evolucao.write("\n QUANTIDADE DE SAIDAS INCORPORADAS: " + str(GLOBAL_QTD_CROSSOVER_SAIDA))
        arquivo_evolucao.write("\n")
        arquivo_evolucao.write("\n")
        arquivo_evolucao.write("\nTROCA DE PORTAS: ")
        arquivo_evolucao.write("\n " + str(GATE_INFAC))
        arquivo_evolucao.write("\n")
        arquivo_evolucao.write("\n")
        arquivo_evolucao.write("\nTROCA DE PORTAS BENÉFICAS: ")
        arquivo_evolucao.write("\n " + str(GATE_INFAC_BEN))        
        arquivo_evolucao.close()


        arquivo_infoevol = open("informacoes_evolutivas.txt", "a")
        arquivo_infoevol.write("\nFREQUÊNCIA DAS MUTAÇÕES")
        arquivo_infoevol.write("\nSAM:")
        arquivo_infoevol.write("\nSAIDA: " + str(GLOBAL_MUTACAO_SAM_SAIDA))
        arquivo_infoevol.write("\nINPUT: " + str(GLOBAL_MUTACAO_SAM_INPUT))
        arquivo_infoevol.write("\nPORTA: " + str(GLOBAL_MUTACAO_SAM_PORTA))
        arquivo_infoevol.write("\n ATIVOS SAM: " + str(GLOBAL_MUTACAO_SAM_ATIVO))
        arquivo_infoevol.write("\n INATIVOS SAM: " + str(GLOBAL_MUTACAO_SAM_INATIVO))        
        arquivo_infoevol.write("\nGAM:")
        arquivo_infoevol.write("\nSAIDA: " + str(GLOBAL_MUTACAO_GAM_SAIDA))
        arquivo_infoevol.write("\nINPUT: " + str(GLOBAL_MUTACAO_GAM_INPUT))
        arquivo_infoevol.write("\nPORTA: " + str(GLOBAL_MUTACAO_GAM_PORTA))
        arquivo_infoevol.write("\n ATIVOS GAM: " + str(GLOBAL_MUTACAO_GAM_ATIVO))
        arquivo_infoevol.write("\n INATIVOS GAM: " + str(GLOBAL_MUTACAO_GAM_INATIVO))
        arquivo_infoevol.write("\n")
        arquivo_infoevol.write("\n QUANTIDADE DE CROSSOVERS REALIZADOS: " + str(GLOBAL_QTD_CROSSOVER))
        arquivo_infoevol.write("\n QUANTIDADE DE SAIDAS INCORPORADAS: " + str(GLOBAL_QTD_CROSSOVER_SAIDA))
        arquivo_infoevol.write("\n")
        arquivo_infoevol.write("\n")
        arquivo_infoevol.write("\nTROCA DE PORTAS: ")
        arquivo_infoevol.write("\n " + str(GATE_INFAC))
        arquivo_infoevol.write("\n")
        arquivo_infoevol.write("\n")
        arquivo_infoevol.write("\nTROCA DE PORTAS BENÉFICAS: ")
        arquivo_infoevol.write("\n " + str(GATE_INFAC_BEN))        
        arquivo_infoevol.close()

        
        numero_avaliacoes = 0

###########################################################


def main_SAM_G_2P_CROSSOVER_POPULACIONAL():
    seed_inicial = 0 #Mudar este valor quando tiver que executar alguma seed específica que não começa por 0.
    qtd_testes = 1
    teste_atual = 0 ## Referência para imprimir a população inicial
    
    for y in range(GLOBAL_QTD_TESTES):
        numero_avaliacoes = 0
        controle = True
        geracao = 0
        soma_fitness = []
        auxiliar = 0
        geracao_aux = 0
        formato_ee_pop()
        formato_array_fitness_pop()
        gera_formato_nos_pop()
        formato_tabela_verdade()
        gera_formato_genotipo()
        r.seed(y + seed_inicial)
        for k in range(ee_mu_pop + ee_lambda_pop):
            populacao_inicial()
            define_saida()
            for j in range(ni):
                G[j] = copy.deepcopy(j)
            GENS_EVOL[k] = copy.deepcopy(G)
            
        nos_ativos_pop()
        #arquivo2 = open('semente_populacao_inicial.txt', 'a')
        #arquivo2.write("\n POPULAÇÃO INICIAL " + str(y+seed_inicial) + "\n")
        #arquivo2.write(str(GENS_EVOL))
        #arquivo2.close()
        arquivo_inicio = open('informacoes_processo.txt', 'a')
        arquivo_inicio.write("\n SEED: " + str(y+seed_inicial))
        arquivo_inicio.close()
        primeira_convergencia = False
        muda_atualiza_pai = False
        print("ENTROU")
        print("GERAÇÃO: ", geracao)


        ##Quantifica FITNESS por SAÍDA
        for w in range(ee_mu_pop + ee_lambda_pop):
            conta_portas(w)
            monta_tabela(w)

        ##Monta FITNESS_GLOBAL
        FITNESS_GLOBAL.clear()
        for w in range(len(FITNESS_EE)):
            fitness_global_auxiliar = 0
            for m in range(len(FITNESS_EE[w])):
                fitness_global_auxiliar += FITNESS_EE[w][m]
            FITNESS_GLOBAL.append(fitness_global_auxiliar)
            
        ## até aqui aparentemente OK            
        while geracao <= GLOBAL_NUM_GERACOES:
            tempo_inicio = time.time()

            gc.collect()

            seleciona_mu_pais()
            #Cria o super individuo
            LAMBDA_FILHOS.clear()
            CROSSOVER_pop_NOVO_SUPER()
            INDIVIDUO_0 = copy.deepcopy(GENS_EVOL[0])
            GENS_EVOL[0] = copy.deepcopy(LAMBDA_FILHOS[0])
            FITNESS_0 = copy.deepcopy(FITNESS_EE[0])
            nos_ativos_pop()
            monta_tabela(0)
            numero_avaliacoes += 1
            auxiliar_fitness_super_individuo = 0
            for numeros in range(len(FITNESS_EE[0])):
                auxiliar_fitness_super_individuo += FITNESS_EE[0][numeros]
                
            GENS_EVOL[0] = copy.deepcopy(INDIVIDUO_0)
            FITNESS_EE[0] = copy.deepcopy(FITNESS_0)
            if auxiliar_fitness_super_individuo == (no * len(OUTPUTS[0])):
                print(" CONVERGIU COM NÚMERO DE AVALIAÇÕES IGUAL A: ", numero_avaliacoes)
                arquivo_teste = open('convergencias.txt', 'a')
                arquivo_teste.write("\n SEED: " + str(y+seed_inicial) + "\n")
                arquivo_teste.write("CONVERGIU COM NÚMERO DE AVALIAÇÕES IGUAL A: " + str(numero_avaliacoes) + " SUPER INDIVIDUO")
                arquivo_teste.write("\n")
                arquivo_teste.close()
                geracao = 300000
                break
                
                
            
            # Seleciona e Realiza o Crossover

            for i in range(ee_lambda_pop-1):
                indice_pai1 = r.randint(0, len(INDICE_MU_PAIS)-1)
                indice_pai2 = r.randint(0, len(INDICE_MU_PAIS)-1)
                #indice_pai3 = r.randint(0, len(INDICE_MU_PAIS)-1)
                #indice_pai4 = r.randint(0, len(INDICE_MU_PAIS)-1)
                while indice_pai2 == indice_pai1:
                    indice_pai2 = r.randint(0, len(INDICE_MU_PAIS)-1)
                #while indice_pai3 == indice_pai1 or indice_pai3 == indice_pai2:
                #    indice_pai3 = r.randint(0, len(INDICE_MU_PAIS)-1)
                #while indice_pai4 == indice_pai3 or indice_pai4 == indice_pai2 or indice_pai4 == indice_pai1:
                #    indice_pai4 = r.randint(0, len(INDICE_MU_PAIS)-1)
                    
                #print("Pai 1: ", INDICE_MU_PAIS[indice_pai1])
                #print("Pai 2: ", INDICE_MU_PAIS[indice_pai2])
                pai1 = INDICE_MU_PAIS[indice_pai1]
                pai2 = INDICE_MU_PAIS[indice_pai2]
                #pai3 = INDICE_MU_PAIS[indice_pai3]
                #pai4 = INDICE_MU_PAIS[indice_pai4]
                CROSSOVER_pop_NOVO(pai1, pai2)                

            # Determina Indices dos LAMBDA Filhos
            INDICE_LAMBDA_FILHOS.clear()
            for i in range(ee_mu_pop + ee_lambda_pop):
                if i not in INDICE_MU_PAIS:
                    INDICE_LAMBDA_FILHOS.append(i)
           
            # Aloca os MU Pais no GENS_EVOL, respeitando seus respectivos indices ORIGINAIS
            for i in range(len(INDICE_MU_PAIS)):
                GENS_EVOL[INDICE_MU_PAIS[i]] = copy.deepcopy(MU_PAIS[i])
                
            # Aloca os LAMBDA Filhos no GENS_EVOL, respeitando seus respectivos indices ORIGINAIS
            for i in range(len(INDICE_LAMBDA_FILHOS)):
                GENS_EVOL[INDICE_LAMBDA_FILHOS[i]] = copy.deepcopy(LAMBDA_FILHOS[i])

            # Determina os nós ativos da população após crossover
            nos_ativos_pop()

            # Realiza a mutação nos LAMBDA Filhos
            for item_a_ser_mutado in INDICE_LAMBDA_FILHOS:
                mutacao_SAM_CORRETO(item_a_ser_mutado)

            # Determina os nós ativos da população após mutação
            nos_ativos_pop()

            ## AVALIAÇÃO DOS INDIVÍDUOS

            ## Avalia SOMENTE os LAMBDA_FILHOS (os PAIS já foram avaliados anteriormente)
            for item_fitness_filhos in INDICE_LAMBDA_FILHOS:
                monta_tabela(item_fitness_filhos)
                numero_avaliacoes += 1
                conta_portas(item_fitness_filhos)

                auxiliar2 = 0
                for b in range(len(FITNESS_EE[item_fitness_filhos])):
                    auxiliar2 += FITNESS_EE[item_fitness_filhos][b]

                if auxiliar2 == (no * len(OUTPUTS[0])) and primeira_convergencia == False:
                    print(" CONVERGIU COM NÚMERO DE AVALIAÇÕES IGUAL A: ", numero_avaliacoes)
                    primeira_convergencia = True
                    muda_atualiza_pai = True
                    COSPE_ativo(item_fitness_filhos)
                    print("NÚMERO DE PORTAS: ", PORTAS_CKT[item_fitness_filhos])
                    print("INDIVÍDUO: ", item_fitness_filhos)
                    arquivo_teste = open('convergencias.txt', 'a')
                    arquivo_teste.write("\n SEED: " + str(y+seed_inicial) + "\n")
                    arquivo_teste.write("CONVERGIU COM NÚMERO DE AVALIAÇÕES IGUAL A: " + str(numero_avaliacoes))
                    for j in range(no):
                        arquivo_teste.write("\n SAIDA: " + str(j))
                        for i in range(len(MEUARRAY[item_fitness_filhos][j])):
                            if MEUARRAY[item_fitness_filhos][j][i] == "X":
                                arquivo_teste.write("\n I = " + str(i) + " GENE = " + str(GENS_EVOL[item_fitness_filhos][i]))
                    arquivo_teste.write("\n NÚMERO DE PORTAS: " + str(PORTAS_CKT[item_fitness_filhos]))
                    arquivo_teste.write("\n NÚMERO DE WIRES: " + str(WIRES_CKT[item_fitness_filhos]))
                    arquivo_teste.write("\n INDIVIDUO: " + str(item_fitness_filhos))
                    arquivo_teste.write("\n")
                    arquivo_teste.close()
                    geracao = 300000
                    break


############# até aqui aparentemente OK

            FITNESS_GLOBAL.clear()
            for w in range(len(FITNESS_EE)):
                fitness_global_auxiliar = 0
                for m in range(len(FITNESS_EE[w])):
                    fitness_global_auxiliar += FITNESS_EE[w][m]
                FITNESS_GLOBAL.append(fitness_global_auxiliar)

            geracao = geracao + 1

            if geracao <= 20:
                print("\nGERAÇÃO : " + str(geracao))
                print(FITNESS_GLOBAL)
            if geracao % 1000 == 0:
                print("\nGERAÇÃO : " + str(geracao))
                print(FITNESS_GLOBAL)



        print("FIM", geracao)
        tempo_fim = time.time()
        arquivo_aolongo2 = open('informacoes_processo.txt', 'a')
        arquivo_aolongo2.write("\n FIM \n")
        arquivo_aolongo2.write("Tempo decorrido: " + str((tempo_fim - tempo_inicio)/60) + " minutos.")
        arquivo_aolongo2.write("\n")
        arquivo_aolongo2.close()
        
        
        limpa_array()

        teste_atual = teste_atual + 1

        numero_avaliacoes = 0

#########################################################################

#########################################################################


def main_GAM_G_2P_CROSSOVER():
    
    seed_inicial = 0 #Mudar este valor quando tiver que executar alguma seed específica que não começa por 0.
    teste_atual = 0 ## Referência para imprimir a população inicial
    
    for y in range(GLOBAL_QTD_TESTES):
        numero_avaliacoes = 0
        controle = True
        geracao = 0
        soma_fitness = []
        auxiliar = 0
        geracao_aux = 0
        formato_ee()
        formato_array_fitness()
        gera_formato_nos()
        formato_tabela_verdade()
        gera_formato_genotipo()
        r.seed(y + seed_inicial)
        
        for t in range(ee_lambda + 1): # Gera a população inicial, diferente entre si (aleatoriamente).
            populacao_inicial()
            define_saida()
            for j in range(ni):
                G[j] = copy.deepcopy(j)
            GENS_EVOL[t] = copy.deepcopy(G)
            
        nos_ativos()

        for w in range(ee_lambda + 1):
            conta_portas(w)
            monta_tabela(w)
            fit_auxiliar = 0
            for b in range(len(FITNESS_EE[w])):
                fit_auxiliar = fit_auxiliar + FITNESS_EE[w][b]
                if fit_auxiliar == no * len(OUTPUTS[0]):
                    print("CONVERGIU")
                                
                                
        
        arquivo2 = open('semente_populacao_inicial.txt', 'a')
        arquivo2.write("\n POPULAÇÃO INICIAL " + str(y+seed_inicial) + "\n")
        arquivo2.write(str(GENS_EVOL))
        arquivo2.close()
        
        arquivo_inicio = open('informacoes_processo.txt', 'a')
        arquivo_inicio.write("\n SEED: " + str(y+seed_inicial))
        arquivo_inicio.close()
        
        primeira_convergencia = False
        muda_atualiza_pai = False
        
        print("ENTROU")
        print("GERAÇÃO: ", geracao)
        while numero_avaliacoes <= GLOBAL_NUM_AVALIACOES:
            tempo_inicio = time.time()

            gc.collect()

            if muda_atualiza_pai == False:
                for k in range(ee_lambda):
                    #mutacao_SAM_CORRETO_CROSS(k+1)
                    #auxiliar_das_fitness = 0
                    #for i in FITNESS_EE[0]:
                    #    auxiliar_das_fitness += i
                    #if auxiliar_das_fitness == (no * len(OUTPUTS[0])) - 1:
                    #    mutacao_GAM_CORRETO(k+1)
                    #else:
                    #    mutacao_SAM_CORRETO(k+1)
                    #nova_mutacao_GAM(k+1)
                    #nova_mutacao_SAM(k+1)
                    mutacao_GAM_CORRETO(k+1)
                    #if k == 0 or k == 1:
                    #    mutacao_SAM_CORRETO(k+1)
                    #else:
                    #    mutacao_GAM_CORRETO(k+1)
            else:
                for k in range(ee_lambda):
                    mutacao_SAM_CORRETO(k+1)
                    #nova_mutacao_SAM(k+1)

            nos_ativos()

## -- CONTA A QUANTIDADE DE PORTAS DO PAI -- ##            
            portas_pai = 0
            portas_filho = 0
            if primeira_convergencia == True:
                portas_pai = copy.deepcopy(PORTAS_CKT[0])




## -- AVALIA OS LAMBDA FILHOS -- ##            
            for w in range(ee_lambda + 1):
                
                if w != 0: #Impede a reavaliação do indivíduo 0 (progenitor)
                    conta_portas(w)
                    
                    monta_tabela(w)

                    numero_avaliacoes = numero_avaliacoes + 1
                else:
                    if muda_atualiza_pai == True: # Neste caso o indivíduo 0 deve ser reavaliado pois leva-se em conta o número de portas (função objetivo: minimizar o número de portas)
                        conta_portas(w)
                        monta_tabela(w)
                        numero_avaliacoes = numero_avaliacoes + 1


## -- VERIFICA FACTIBILIDADE DOS INDIVIDUOS -- ##
                auxiliar2 = 0

                for b in range(len(FITNESS_EE[w])):
                    auxiliar2 = auxiliar2 + FITNESS_EE[w][b]

                if auxiliar2 == (no * len(OUTPUTS[0])) and primeira_convergencia == False:
                    print(" CONVERGIU COM NÚMERO DE AVALIAÇÕES IGUAL A: ", numero_avaliacoes)
                    primeira_convergencia = True
                    muda_atualiza_pai = True
                    COSPE_ativo(w)
                    print("NÚMERO DE PORTAS: ", PORTAS_CKT[w])
                    print("INDIVIDUO: ", w)
                    arquivo_teste = open('convergencias.txt', 'a')
                    arquivo_teste.write("\n SEED: " + str(y+seed_inicial) + "\n")
                    arquivo_teste.write("CONVERGIU COM NÚMERO DE AVALIAÇÕES IGUAL A: " + str(numero_avaliacoes))
                    for j in range(no):
                        arquivo_teste.write("\n SAIDA: " + str(j))
                        for i in range(len(MEUARRAY[w][j])):
                            if MEUARRAY[w][j][i] == "X":
                                arquivo_teste.write("\n I = " + str(i) + " GENE = " + str(GENS_EVOL[w][i]))
                    
                    arquivo_teste.write("\n NÚMERO DE PORTAS: " + str(PORTAS_CKT[w]))
                    arquivo_teste.write("\n NÚMERO DE WIRES: " + str(WIRES_CKT[w]))
                    arquivo_teste.write("\n INDIVIDUO: " + str(w))
                    arquivo_teste.write("\n")
                    arquivo_teste.close()
                    #GENS_EVOL[0] = copy.deepcopy(GENS_EVOL[w])
                    numero_avaliacoes = 300000000
                    break
                    #print("GENS_EVOL: ", GENS_EVOL[w])


## -- DETERMINA QUAL É A FUNÇÃO OBJETIVO: ENCONTRAR FACTIBILIDADE (CROSSOVER) OU MINIMIZAR O NÚMERO DE PORTAS (PORTAS_FACTIVEL) -- ##
            if muda_atualiza_pai == True:
                atualiza_pai_PORTAS_FACTIVEL()
            else:
                #atualiza_pai_PORTAS_FACTIVEL()
                atualiza_pai_CROSSOVER_NOVO()
                #atualiza_pai_CROSSOVER_NOVO_GENES_ATIVOS()


## -- VERIFICA SE O NOVO PROGENITOR (GERADO PELO CROSSOVER) É FACTÍVEL -- ##
                auxiliar2 = 0
                conta_portas(0)
                for b in range(len(FITNESS_EE[0])):
                    auxiliar2 = auxiliar2 + FITNESS_EE[0][b]

                if auxiliar2 == (no * len(OUTPUTS[0])) and primeira_convergencia == False:
                    print(" CONVERGIU COM NÚMERO DE AVALIAÇÕES IGUAL A: ", numero_avaliacoes)
                    primeira_convergencia = True
                    muda_atualiza_pai = True
                    COSPE_ativo(0)
                    print("NÚMERO DE PORTAS: ", PORTAS_CKT[0])
                    print("INDIVIDUO: 0", )
                    arquivo_teste = open('convergencias.txt', 'a')
                    arquivo_teste.write("\n SEED: " + str(y+seed_inicial) + "\n")
                    arquivo_teste.write("CONVERGIU COM NÚMERO DE AVALIAÇÕES IGUAL A: " + str(numero_avaliacoes))
                    for j in range(no):
                        arquivo_teste.write("\n SAIDA: " + str(j))
                        for i in range(len(MEUARRAY[0][j])):
                            if MEUARRAY[0][j][i] == "X":
                                arquivo_teste.write("\n I = " + str(i) + " GENE = " + str(GENS_EVOL[0][i]))
                    
                    arquivo_teste.write("\n NÚMERO DE PORTAS: " + str(PORTAS_CKT[0]))
                    arquivo_teste.write("\n NÚMERO DE WIRES: " + str(WIRES_CKT[0]))
                    arquivo_teste.write("\n INDIVIDUO: " + str(w))
                    arquivo_teste.write("\n")
                    arquivo_teste.close()
                    #numero_avaliacoes = 300000000
                    #break
                    #print("GENS_EVOL: ", GENS_EVOL[0])                


## -- VERIFICA A QUANTIDADE DE PORTAS DO FILHO SOMENTE CASO A FUNÇÃO OBJETIVO TENHA MUDADO (MINIMIZAR NÚMERO DE PORTAS LÓGICAS) -- ##
            if primeira_convergencia == True:
                portas_filho = copy.deepcopy(PORTAS_CKT[0])

            if portas_filho < portas_pai:
                arquivo_aolongo = open('informacoes_processo.txt', 'a')
                arquivo_aolongo.write("\n MUDANÇA NO NÚMERO DE PORTAS")
                arquivo_aolongo.write("\n PAI:" + str(portas_pai))
                arquivo_aolongo.write("\n FILHO: " + str(portas_filho))
                arquivo_aolongo.write("\n NÚMERO DE AVALIAÇÕES: " + str(numero_avaliacoes))
                arquivo_aolongo.close()

            soma_fitness.clear()

            for b in range(len(FITNESS_EE)):
                for c in range(len(FITNESS_EE[b])):
                    auxiliar = auxiliar + FITNESS_EE[b][c]
                soma_fitness.append(auxiliar)
                auxiliar = 0

            geracao = geracao + 1


## -- EXIBE AS FITNESS POR GERAÇÃO -- ##
            todos_ativos = []
            for genes in range(len(MEUARRAY[0])):
                for cada in range(len(MEUARRAY[0][genes])):
                    if MEUARRAY[0][genes][cada] == "X":
                        todos_ativos.append(cada)
            novo_array = []
            for itens in todos_ativos:
                if itens not in novo_array:
                    novo_array.append(itens)
            #print("Quantidade de genes ativos: ", len(novo_array))
            if numero_avaliacoes <= 20:
                print("\nNÚMERO DE AVALIAÇÕES : " + str(numero_avaliacoes))
                print(soma_fitness)
                arquivo_evolucao = open("evolucao.txt", "a")
                arquivo_evolucao.write("\n Número de avaliações: " + str(numero_avaliacoes))
                arquivo_evolucao.write("\n Fitness pai: " + str(FITNESS_EE[0]))
                arquivo_evolucao.write("\n Genes ativos pai: " + str(len(novo_array)))
                print("Genes ativos: ", len(novo_array))
            if numero_avaliacoes % 400 == 0:
                print("\nNÚMERO DE AVALIAÇÕES : " + str(numero_avaliacoes))
                print(soma_fitness)
                arquivo_evolucao = open("evolucao.txt", "a")
                arquivo_evolucao.write("\n Número de avaliações: " + str(numero_avaliacoes))
                arquivo_evolucao.write("\n Fitness pai: " + str(FITNESS_EE[0]))
                arquivo_evolucao.write("\n Genes ativos pai: " + str(len(novo_array)))
                print("Genes ativos: ", len(novo_array))
            if geracao <= 20:
                print("\nGERAÇÃO : " + str(geracao))
                print(soma_fitness)
            if geracao % 1000 == 0:
                print("\nGERAÇÃO : " + str(geracao))
                print(soma_fitness)



        print("FIM", geracao)
        
        tempo_fim = time.time()
        
        arquivo_aolongo2 = open('informacoes_processo.txt', 'a')
        arquivo_aolongo2.write("\n FIM \n")
        arquivo_aolongo2.write("Tempo decorrido: " + str((tempo_fim - tempo_inicio)/60) + " minutos.")
        arquivo_aolongo2.write("\n")
        arquivo_aolongo2.close()


        
## -- ARMAZENA SEEDS QUE NÃO CONVERGIRAM E SEUS GENÓTIPOS -- ##
        if primeira_convergencia == False:
            arquivo_sem_convergencia = open('sem_convergencia.txt', 'a')
            arquivo_sem_convergencia.write("SEED : " + str(y+seed_inicial) + "\n")
            arquivo_sem_convergencia.write("FITNESS: " + str(FITNESS_EE[0]) + "\n")
            arquivo_sem_convergencia.write("MELHOR INDIVÍDUO: 0") 
            for j in range(no):
                arquivo_sem_convergencia.write("\n SAIDA: " + str(j))
                for i in range(len(MEUARRAY[0][j])):
                    if MEUARRAY[0][j][i] == "X":
                        arquivo_sem_convergencia.write("\n I = " + str(i) + " GENE = " + str(GENS_EVOL[0][i])) 
            arquivo_sem_convergencia.write("\n NÚMERO DE PORTAS: " + str(PORTAS_CKT[0]))
            arquivo_sem_convergencia.write("\n NÚMERO DE WIRES: " + str(WIRES_CKT[0]))
            arquivo_sem_convergencia.write("\n")
            arquivo_sem_convergencia.write("GENÓTIPO FINAL: " + str(GENS_EVOL[0]) + "\n")
            
            arquivo_sem_convergencia.close()        
        
## -- PREENCHE ARQUIVO DE MATRIZ DE TRANSIÇÃO -- ##
        arquivo = open('matriz_transicao.txt', 'a')
        arquivo.write("\n MATRIZ INFACTIVEL \n")
        arquivo.write(str(MATRIZ_REGIAO_INFACTIVEL))
        arquivo.write("\n MATRIZ FACTIVEL \n")
        arquivo.write(str(MATRIZ_REGIAO_FACTIVEL))
        arquivo.close()


        #teste = 0
        #for i in range(len(FITNESS_EE[0])):
        #    teste += FITNESS_EE[0][i]
        #if teste == no * len(OUTPUTS[0]):
        #    print("ESTÁ COM FITNESS MÁXIMA")
        #else:
        #    print("NÃO ESTÁ COM FITNESS MÁXIMA")
        COSPE_ativo(0)
        
        for i in range(ee_lambda + 1):
            conta_portas(i)
        print("NÚMERO DE PORTAS: ", PORTAS_EE[0][no-1])
        if primeira_convergencia == True:
            arquivo_otimizado = open('convergencias_otimizado.txt', 'a')
            arquivo_otimizado.write("\n SEED: " + str(y+seed_inicial) + "\n")
            arquivo_otimizado.write("CONVERGIU COM NÚMERO DE AVALIAÇÕES IGUAL A: " + str(numero_avaliacoes))
            for j in range(no):
                arquivo_otimizado.write("\n SAIDA: " + str(j))
                for i in range(len(MEUARRAY[0][j])):
                    if MEUARRAY[0][j][i] == "X":
                        arquivo_otimizado.write("\n I = " + str(i) + " GENE = " + str(GENS_EVOL[0][i]))
                    
            arquivo_otimizado.write("\n NÚMERO DE PORTAS: " + str(PORTAS_CKT[0]))
            arquivo_otimizado.write("\n NÚMERO DE WIRES: " + str(WIRES_CKT[0]))
            arquivo_otimizado.write("\n INDIVIDUO: " + str(0))
            arquivo_otimizado.write("\n")
            arquivo_otimizado.close()

        
        
        limpa_array()

        teste_atual = teste_atual + 1

        numero_avaliacoes = 0

###########################################################


def main_SAMGAM_G_2P_CROSSOVER():
    
    seed_inicial = 0 #Mudar este valor quando tiver que executar alguma seed específica que não começa por 0.
    teste_atual = 0 ## Referência para imprimir a população inicial
    
    for y in range(GLOBAL_QTD_TESTES):
        numero_avaliacoes = 0
        controle = True
        geracao = 0
        soma_fitness = []
        auxiliar = 0
        geracao_aux = 0
        formato_ee()
        formato_array_fitness()
        gera_formato_nos()
        formato_tabela_verdade()
        gera_formato_genotipo()
        r.seed(y + seed_inicial)
        
        for t in range(ee_lambda + 1): # Gera a população inicial, diferente entre si (aleatoriamente).
            populacao_inicial()
            define_saida()
            for j in range(ni):
                G[j] = copy.deepcopy(j)
            GENS_EVOL[t] = copy.deepcopy(G)
            
        nos_ativos()

        for w in range(ee_lambda + 1):
            conta_portas(w)
            monta_tabela(w)
            fit_auxiliar = 0
            for b in range(len(FITNESS_EE[w])):
                fit_auxiliar = fit_auxiliar + FITNESS_EE[w][b]
                if fit_auxiliar == no * len(OUTPUTS[0]):
                    print("CONVERGIU")
                                
                                
        
        arquivo2 = open('semente_populacao_inicial.txt', 'a')
        arquivo2.write("\n POPULAÇÃO INICIAL " + str(y+seed_inicial) + "\n")
        arquivo2.write(str(GENS_EVOL))
        arquivo2.close()
        
        arquivo_inicio = open('informacoes_processo.txt', 'a')
        arquivo_inicio.write("\n SEED: " + str(y+seed_inicial))
        arquivo_inicio.close()

        arquivo_evolucao_inicio = open('evolucao.txt', 'a')
        arquivo_evolucao_inicio.write("\n SEED: " + str(y+seed_inicial))
        arquivo_evolucao_inicio.write("\n")
        arquivo_evolucao_inicio.close()


        arquivo_genes_ativos = open("distribuicao_genes_ativos.txt", "a")
        arquivo_genes_ativos.write("\n SEED: " + str(y+seed_inicial))
        arquivo_genes_ativos.write("\n")
        arquivo_genes_ativos.close()

        arquivo_infoevol = open("informacoes_evolutivas.txt", "a")
        arquivo_infoevol.write("\n SEED: " + str(y+seed_inicial))
        arquivo_infoevol.write("\n")
        arquivo_infoevol.close()

        
        primeira_convergencia = False
        muda_atualiza_pai = False
        
        print("ENTROU")
        print("GERAÇÃO: ", geracao)
        while numero_avaliacoes <= GLOBAL_NUM_AVALIACOES:
            tempo_inicio = time.time()

            gc.collect()
            IND_MUT_SAM[0][0][0] = copy.deepcopy(0)
            IND_MUT_SAM[0][1][0] = copy.deepcopy(0)
            IND_MUT_SAM[1][0][0] = copy.deepcopy(0)
            IND_MUT_SAM[1][1][0] = copy.deepcopy(0)
            IND_MUT_GAM[0][0][0] = copy.deepcopy(0)
            IND_MUT_GAM[0][1][0] = copy.deepcopy(0)
            IND_MUT_GAM[1][0][0] = copy.deepcopy(0)
            IND_MUT_GAM[1][1][0] = copy.deepcopy(0)
            atualiza_matriz_mutacoes()
            #mutacao_BSAM_ADAPTATIVO()              
            if muda_atualiza_pai == False:
                arquivo_evolucao_intermediario = open('evolucao.txt', 'a')
                #arquivo_evolucao_intermediario.write("FITNESS ANTES: " + str(FITNESS_EE))
                arquivo_evolucao_intermediario.close()
                for k in range(ee_lambda):
                    #mutacao_SAM_CORRETO_CROSS(k+1)
                    #auxiliar_das_fitness = 0
                    #for i in FITNESS_EE[0]:
                    #    auxiliar_das_fitness += i
                    #if auxiliar_das_fitness == (no * len(OUTPUTS[0])) - 1:
                    #    mutacao_GAM_CORRETO(k+1)
                    #else:
                    #    mutacao_SAM_CORRETO(k+1)
                    #nova_mutacao_GAM(k+1)
                    #nova_mutacao_SAM(k+1)
                    #mutacao_GAM_CORRETO(k+1)
                    #if y-seed_inicial >= 0: ## para usar BSAM colocar sinal de <=
                    if k == 0 or k == 1:
                        mutacao_SAM_CORRETO(k+1)
                    else:
                        mutacao_GAM_CORRETO(k+1)
                    #else:
                    #    mutacao_BSAM_ADAPTATIVO(k+1)
            else:
                for k in range(ee_lambda):
                    mutacao_SAM_CORRETO(k+1)
                    #nova_mutacao_SAM(k+1)

            nos_ativos()

## -- CONTA A QUANTIDADE DE PORTAS DO PAI -- ##            
            portas_pai = 0
            portas_filho = 0
            if primeira_convergencia == True:
                portas_pai = copy.deepcopy(PORTAS_CKT[0])




## -- AVALIA OS LAMBDA FILHOS -- ##            
            for w in range(ee_lambda + 1):
                
                if w != 0: #Impede a reavaliação do indivíduo 0 (progenitor)
                    arquivo_evolucao = open('evolucao.txt', 'a')
                    arquivo_evolucao.write("\n --> INDIVIDUO ANALSIADO: " + str(w))
                    arquivo_evolucao.write("\n Número de avaliações: " + str(numero_avaliacoes))
                    arquivo_evolucao.write("\n Fitness antes: " + str(FITNESS_EE[w]))
                    fitness_antes_local = copy.deepcopy(FITNESS_EE[w])

                    conta_portas(w)
                    
                    #monta_tabela_MUX(w)
                    monta_tabela(w)

                    numero_avaliacoes = numero_avaliacoes + 1
                    


                    arquivo_evolucao.write("\n Fitness depois: " + str(FITNESS_EE[w]))
                    if w == 1 or w == 2:
                        #arquivo_evolucao.write("\n IND MUT SAM" + str(IND_MUT_SAM[w-1]))
                        if IND_MUT_SAM[w-1][0][0] != 0:
                            if fitness_antes_local == FITNESS_EE[w]:
                                arquivo_evolucao.write("\n MUTAÇÃO TIPO PORTA NEUTRO")
                            else:
                                for elementos in range(len(fitness_antes_local)):
                                    if fitness_antes_local[elementos] < FITNESS_EE[w][elementos]:
                                        arquivo_evolucao.write("\n HOUVE MELHORA, PELO MENOS, NA SAÍDA " + str(elementos))
                                        #arquivo_evolucao.write("\n PORTA ANTES: " + str(IND_MUT_SAM[w-1][0][0]))
                                        #arquivo_evolucao.write("\n PORTA DEPOIS: " + str(IND_MUT_SAM[w-1][1][0]))
                                        porta_antes = IND_MUT_SAM[w-1][0][0]
                                        porta_depois = IND_MUT_SAM[w-1][1][0]
                                        preenche_matriz_benefico(porta_antes, porta_depois)
                                        break
                    if w == 3 or w == 4:
                        #arquivo_evolucao.write("\n IND MUT SAM" + str(IND_MUT_SAM[w-1]))
                        if IND_MUT_GAM[w-3][0][0] != 0:
                            if fitness_antes_local == FITNESS_EE[w]:
                                arquivo_evolucao.write("\n MUTAÇÃO TIPO PORTA NEUTRO")
                            else:
                                for elementos in range(len(fitness_antes_local)):
                                    if fitness_antes_local[elementos] < FITNESS_EE[w][elementos]:
                                        arquivo_evolucao.write("\n HOUVE MELHORA, PELO MENOS, NA SAÍDA " + str(elementos))
                                        #arquivo_evolucao.write("\n PORTA ANTES: " + str(IND_MUT_SAM[w-1][0][0]))
                                        #arquivo_evolucao.write("\n PORTA DEPOIS: " + str(IND_MUT_SAM[w-1][1][0]))
                                        porta_antes = IND_MUT_GAM[w-3][0][0]
                                        porta_depois = IND_MUT_GAM[w-3][1][0]
                                        preenche_matriz_benefico(porta_antes, porta_depois)
                                        break



                                    
                    arquivo_evolucao.close()
                                                               
                else:
                    if muda_atualiza_pai == True: # Neste caso o indivíduo 0 deve ser reavaliado pois leva-se em conta o número de portas (função objetivo: minimizar o número de portas)
                        conta_portas(w)
                        monta_tabela(w)
                        numero_avaliacoes = numero_avaliacoes + 1


                #arquivo_evolucao = open('evolucao.txt', 'a')
                #arquivo_evolucao.write("\n NOVAMENTE O IND MUT: " + str(IND_MUT_SAM))
                #arquivo_evolucao.close()
## -- VERIFICA FACTIBILIDADE DOS INDIVIDUOS -- ##
                auxiliar2 = 0

                for b in range(len(FITNESS_EE[w])):
                    auxiliar2 = auxiliar2 + FITNESS_EE[w][b]

                if auxiliar2 == (no * len(OUTPUTS[0])) and primeira_convergencia == False:
                    print(" CONVERGIU COM NÚMERO DE AVALIAÇÕES IGUAL A: ", numero_avaliacoes)
                    primeira_convergencia = True
                    muda_atualiza_pai = True
                    COSPE_ativo(w)
                    print("NÚMERO DE PORTAS: ", PORTAS_CKT[w])
                    print("INDIVIDUO: ", w)
                    arquivo_teste = open('convergencias.txt', 'a')
                    arquivo_teste.write("\n SEED: " + str(y+seed_inicial) + "\n")
                    arquivo_teste.write("CONVERGIU COM NÚMERO DE AVALIAÇÕES IGUAL A: " + str(numero_avaliacoes))
                    for j in range(no):
                        arquivo_teste.write("\n SAIDA: " + str(j))
                        for i in range(len(MEUARRAY[w][j])):
                            if MEUARRAY[w][j][i] == "X":
                                arquivo_teste.write("\n I = " + str(i) + " GENE = " + str(GENS_EVOL[w][i]))
                    
                    arquivo_teste.write("\n NÚMERO DE PORTAS: " + str(PORTAS_CKT[w]))
                    arquivo_teste.write("\n NÚMERO DE WIRES: " + str(WIRES_CKT[w]))
                    arquivo_teste.write("\n INDIVIDUO: " + str(w))
                    arquivo_teste.write("\n")
                    arquivo_teste.close()
                    #GENS_EVOL[0] = copy.deepcopy(GENS_EVOL[w])
                    numero_avaliacoes = 300000000
                    break
                    #print("GENS_EVOL: ", GENS_EVOL[w])


## -- DETERMINA QUAL É A FUNÇÃO OBJETIVO: ENCONTRAR FACTIBILIDADE (CROSSOVER) OU MINIMIZAR O NÚMERO DE PORTAS (PORTAS_FACTIVEL) -- ##
            if muda_atualiza_pai == True:
                atualiza_pai_PORTAS_FACTIVEL()
            else:
                #atualiza_pai_PORTAS_FACTIVEL()
                atualiza_pai_CROSSOVER_NOVO()
                #atualiza_pai_CROSSOVER_NOVO_GENES_ATIVOS()


## -- VERIFICA SE O NOVO PROGENITOR (GERADO PELO CROSSOVER) É FACTÍVEL -- ##
                auxiliar2 = 0
                conta_portas(0)
                for b in range(len(FITNESS_EE[0])):
                    auxiliar2 = auxiliar2 + FITNESS_EE[0][b]

                if auxiliar2 == (no * len(OUTPUTS[0])) and primeira_convergencia == False:
                    print(" CONVERGIU COM NÚMERO DE AVALIAÇÕES IGUAL A: ", numero_avaliacoes)
                    primeira_convergencia = True
                    muda_atualiza_pai = True
                    COSPE_ativo(0)
                    print("NÚMERO DE PORTAS: ", PORTAS_CKT[0])
                    print("INDIVIDUO: 0", )
                    arquivo_teste = open('convergencias.txt', 'a')
                    arquivo_teste.write("\n SEED: " + str(y+seed_inicial) + "\n")
                    arquivo_teste.write("CONVERGIU COM NÚMERO DE AVALIAÇÕES IGUAL A: " + str(numero_avaliacoes))
                    for j in range(no):
                        arquivo_teste.write("\n SAIDA: " + str(j))
                        for i in range(len(MEUARRAY[0][j])):
                            if MEUARRAY[0][j][i] == "X":
                                arquivo_teste.write("\n I = " + str(i) + " GENE = " + str(GENS_EVOL[0][i]))
                    
                    arquivo_teste.write("\n NÚMERO DE PORTAS: " + str(PORTAS_CKT[0]))
                    arquivo_teste.write("\n NÚMERO DE WIRES: " + str(WIRES_CKT[0]))
                    arquivo_teste.write("\n INDIVIDUO: " + str(w))
                    arquivo_teste.write("\n")
                    arquivo_teste.close()
                    numero_avaliacoes = 300000000
                    break
                    #print("GENS_EVOL: ", GENS_EVOL[0])                


## -- VERIFICA A QUANTIDADE DE PORTAS DO FILHO SOMENTE CASO A FUNÇÃO OBJETIVO TENHA MUDADO (MINIMIZAR NÚMERO DE PORTAS LÓGICAS) -- ##
            if primeira_convergencia == True:
                portas_filho = copy.deepcopy(PORTAS_CKT[0])

            if portas_filho < portas_pai:
                arquivo_aolongo = open('informacoes_processo.txt', 'a')
                arquivo_aolongo.write("\n MUDANÇA NO NÚMERO DE PORTAS")
                arquivo_aolongo.write("\n PAI:" + str(portas_pai))
                arquivo_aolongo.write("\n FILHO: " + str(portas_filho))
                arquivo_aolongo.write("\n NÚMERO DE AVALIAÇÕES: " + str(numero_avaliacoes))
                arquivo_aolongo.close()

            soma_fitness.clear()

            for b in range(len(FITNESS_EE)):
                for c in range(len(FITNESS_EE[b])):
                    auxiliar = auxiliar + FITNESS_EE[b][c]
                soma_fitness.append(auxiliar)
                auxiliar = 0

            geracao = geracao + 1


## -- EXIBE AS FITNESS POR GERAÇÃO -- ##
            todos_ativos = []
            for genes in range(len(MEUARRAY[0])):
                for cada in range(len(MEUARRAY[0][genes])):
                    if MEUARRAY[0][genes][cada] == "X":
                        todos_ativos.append(cada)
            novo_array = []
            for itens in todos_ativos:
                if itens not in novo_array:
                    novo_array.append(itens)
            variavel_auxiliar_fitness_saida = 0
            for fitness_saida in range(len(FITNESS_EE[0])):
                variavel_auxiliar_fitness_saida += FITNESS_EE[0][fitness_saida]


            arquivo_infoevol = open("informacoes_evolutivas.txt", "a")
            arquivo_infoevol.write("\n Avaliações: " + str(numero_avaliacoes) + " Fitness Pai: " + str(FITNESS_EE[0]))
            arquivo_infoevol.close()

            arquivo_evolucao = open("evolucao.txt", "a")
            arquivo_evolucao.write("\n Fitness Pai: " + str(FITNESS_EE[0]))
            arquivo_evolucao.write(" (( " + str(variavel_auxiliar_fitness_saida) + " )) ")
            
            arquivo_evolucao.write("\n Quantidade de genes ativos: " + str(len(novo_array)))
            arquivo_evolucao.close()

            arquivo_genes_ativos = open("distribuicao_genes_ativos.txt", "a")
            arquivo_genes_ativos.write("\nGeração: " + str(geracao))
            arquivo_genes_ativos.write("\nDistribuição: " + str(novo_array))
            arquivo_genes_ativos.close()

            arquivo_genes_ativos = open("genes_ativos.txt", "a")
            arquivo_genes_ativos.write("\n" + str(geracao) + ", " + str(len(novo_array)))
            arquivo_genes_ativos.close()
            
            #print("Quantidade de genes ativos: ", len(novo_array))
            if numero_avaliacoes <= 20:
                print("\nNÚMERO DE AVALIAÇÕES : " + str(numero_avaliacoes))
                print(soma_fitness)
                #arquivo_evolucao = open("evolucao.txt", "a")
                #arquivo_evolucao.write("\n Número de avaliações: " + str(numero_avaliacoes))
                #arquivo_evolucao.write("\n Fitness pai: " + str(FITNESS_EE[0]))
                #arquivo_evolucao.write("\n Genes ativos pai: " + str(len(novo_array)))
                print("Genes ativos: ", len(novo_array))
            if numero_avaliacoes % 400 == 0:
                print("\nNÚMERO DE AVALIAÇÕES : " + str(numero_avaliacoes))
                print(soma_fitness)
                #arquivo_evolucao = open("evolucao.txt", "a")
                #arquivo_evolucao.write("\n Número de avaliações: " + str(numero_avaliacoes))
                #arquivo_evolucao.write("\n Fitness pai: " + str(FITNESS_EE[0]))
                #arquivo_evolucao.write("\n Genes ativos pai: " + str(len(novo_array)))
                print("Genes ativos: ", len(novo_array))
            if geracao <= 20:
                print("\nGERAÇÃO : " + str(geracao))
                print(soma_fitness)
            if geracao % 1000 == 0:
                print("\nGERAÇÃO : " + str(geracao))
                print(soma_fitness)



        print("FIM", geracao)
        
        tempo_fim = time.time()
        
        arquivo_aolongo2 = open('informacoes_processo.txt', 'a')
        arquivo_aolongo2.write("\n FIM \n")
        arquivo_aolongo2.write("Tempo decorrido: " + str((tempo_fim - tempo_inicio)/60) + " minutos.")
        arquivo_aolongo2.write("\n")
        arquivo_aolongo2.close()


        
## -- ARMAZENA SEEDS QUE NÃO CONVERGIRAM E SEUS GENÓTIPOS -- ##
        if primeira_convergencia == False:
            arquivo_sem_convergencia = open('sem_convergencia.txt', 'a')
            arquivo_sem_convergencia.write("SEED : " + str(y+seed_inicial) + "\n")
            arquivo_sem_convergencia.write("FITNESS: " + str(FITNESS_EE[0]) + "\n")
            arquivo_sem_convergencia.write("MELHOR INDIVÍDUO: 0") 
            for j in range(no):
                arquivo_sem_convergencia.write("\n SAIDA: " + str(j))
                for i in range(len(MEUARRAY[0][j])):
                    if MEUARRAY[0][j][i] == "X":
                        arquivo_sem_convergencia.write("\n I = " + str(i) + " GENE = " + str(GENS_EVOL[0][i])) 
            arquivo_sem_convergencia.write("\n NÚMERO DE PORTAS: " + str(PORTAS_CKT[0]))
            arquivo_sem_convergencia.write("\n NÚMERO DE WIRES: " + str(WIRES_CKT[0]))
            arquivo_sem_convergencia.write("\n")
            arquivo_sem_convergencia.write("GENÓTIPO FINAL: " + str(GENS_EVOL[0]) + "\n")
            
            arquivo_sem_convergencia.close()        
        
## -- PREENCHE ARQUIVO DE MATRIZ DE TRANSIÇÃO -- ##
        arquivo = open('matriz_transicao.txt', 'a')
        arquivo.write("\n MATRIZ INFACTIVEL \n")
        arquivo.write(str(MATRIZ_REGIAO_INFACTIVEL))
        arquivo.write("\n MATRIZ FACTIVEL \n")
        arquivo.write(str(MATRIZ_REGIAO_FACTIVEL))
        arquivo.close()

        COSPE_ativo(0)
        
        for i in range(ee_lambda + 1):
            conta_portas(i)
        print("NÚMERO DE PORTAS: ", PORTAS_EE[0][no-1])
        if primeira_convergencia == True:
            arquivo_otimizado = open('convergencias_otimizado.txt', 'a')
            arquivo_otimizado.write("\n SEED: " + str(y+seed_inicial) + "\n")
            arquivo_otimizado.write("CONVERGIU COM NÚMERO DE AVALIAÇÕES IGUAL A: " + str(numero_avaliacoes))
            for j in range(no):
                arquivo_otimizado.write("\n SAIDA: " + str(j))
                for i in range(len(MEUARRAY[0][j])):
                    if MEUARRAY[0][j][i] == "X":
                        arquivo_otimizado.write("\n I = " + str(i) + " GENE = " + str(GENS_EVOL[0][i]))
                    
            arquivo_otimizado.write("\n NÚMERO DE PORTAS: " + str(PORTAS_CKT[0]))
            arquivo_otimizado.write("\n NÚMERO DE WIRES: " + str(WIRES_CKT[0]))
            arquivo_otimizado.write("\n INDIVIDUO: " + str(0))
            arquivo_otimizado.write("\n")
            arquivo_otimizado.close()

        
        
        limpa_array()

        teste_atual = teste_atual + 1

        arquivo_evolucao = open('evolucao.txt', 'a')
        arquivo_evolucao.write("\nFREQUÊNCIA DAS MUTAÇÕES")
        arquivo_evolucao.write("\nSAM:")
        arquivo_evolucao.write("\nSAIDA: " + str(GLOBAL_MUTACAO_SAM_SAIDA))
        arquivo_evolucao.write("\nINPUT: " + str(GLOBAL_MUTACAO_SAM_INPUT))
        arquivo_evolucao.write("\nPORTA: " + str(GLOBAL_MUTACAO_SAM_PORTA))
        arquivo_evolucao.write("\n ATIVOS SAM: " + str(GLOBAL_MUTACAO_SAM_ATIVO))
        arquivo_evolucao.write("\n INATIVOS SAM: " + str(GLOBAL_MUTACAO_SAM_INATIVO))        
        arquivo_evolucao.write("\nGAM:")
        arquivo_evolucao.write("\nSAIDA: " + str(GLOBAL_MUTACAO_GAM_SAIDA))
        arquivo_evolucao.write("\nINPUT: " + str(GLOBAL_MUTACAO_GAM_INPUT))
        arquivo_evolucao.write("\nPORTA: " + str(GLOBAL_MUTACAO_GAM_PORTA))
        arquivo_evolucao.write("\n ATIVOS GAM: " + str(GLOBAL_MUTACAO_GAM_ATIVO))
        arquivo_evolucao.write("\n INATIVOS GAM: " + str(GLOBAL_MUTACAO_GAM_INATIVO))
        arquivo_evolucao.write("\n")
        arquivo_evolucao.write("\n QUANTIDADE DE CROSSOVERS REALIZADOS: " + str(GLOBAL_QTD_CROSSOVER))
        arquivo_evolucao.write("\n QUANTIDADE DE SAIDAS INCORPORADAS: " + str(GLOBAL_QTD_CROSSOVER_SAIDA))
        arquivo_evolucao.write("\n")
        arquivo_evolucao.write("\n")
        arquivo_evolucao.write("\nTROCA DE PORTAS: ")
        arquivo_evolucao.write("\n " + str(GATE_INFAC))
        arquivo_evolucao.write("\n")
        arquivo_evolucao.write("\n")
        arquivo_evolucao.write("\nTROCA DE PORTAS BENÉFICAS: ")
        arquivo_evolucao.write("\n " + str(GATE_INFAC_BEN))        
        arquivo_evolucao.close()


        arquivo_infoevol = open("informacoes_evolutivas.txt", "a")
        arquivo_infoevol.write("\nFREQUÊNCIA DAS MUTAÇÕES")
        arquivo_infoevol.write("\nSAM:")
        arquivo_infoevol.write("\nSAIDA: " + str(GLOBAL_MUTACAO_SAM_SAIDA))
        arquivo_infoevol.write("\nINPUT: " + str(GLOBAL_MUTACAO_SAM_INPUT))
        arquivo_infoevol.write("\nPORTA: " + str(GLOBAL_MUTACAO_SAM_PORTA))
        arquivo_infoevol.write("\n ATIVOS SAM: " + str(GLOBAL_MUTACAO_SAM_ATIVO))
        arquivo_infoevol.write("\n INATIVOS SAM: " + str(GLOBAL_MUTACAO_SAM_INATIVO))        
        arquivo_infoevol.write("\nGAM:")
        arquivo_infoevol.write("\nSAIDA: " + str(GLOBAL_MUTACAO_GAM_SAIDA))
        arquivo_infoevol.write("\nINPUT: " + str(GLOBAL_MUTACAO_GAM_INPUT))
        arquivo_infoevol.write("\nPORTA: " + str(GLOBAL_MUTACAO_GAM_PORTA))
        arquivo_infoevol.write("\n ATIVOS GAM: " + str(GLOBAL_MUTACAO_GAM_ATIVO))
        arquivo_infoevol.write("\n INATIVOS GAM: " + str(GLOBAL_MUTACAO_GAM_INATIVO))
        arquivo_infoevol.write("\n")
        arquivo_infoevol.write("\n QUANTIDADE DE CROSSOVERS REALIZADOS: " + str(GLOBAL_QTD_CROSSOVER))
        arquivo_infoevol.write("\n QUANTIDADE DE SAIDAS INCORPORADAS: " + str(GLOBAL_QTD_CROSSOVER_SAIDA))
        arquivo_infoevol.write("\n")
        arquivo_infoevol.write("\n")
        arquivo_infoevol.write("\nTROCA DE PORTAS: ")
        arquivo_infoevol.write("\n " + str(GATE_INFAC))
        arquivo_infoevol.write("\n")
        arquivo_infoevol.write("\n")
        arquivo_infoevol.write("\nTROCA DE PORTAS BENÉFICAS: ")
        arquivo_infoevol.write("\n " + str(GATE_INFAC_BEN))        
        arquivo_infoevol.close()

        
        numero_avaliacoes = 0

###########################################################


def main_SAM_G_2P_CROSSOVER_MUX():
    
    seed_inicial = 1 #Mudar este valor quando tiver que executar alguma seed específica que não começa por 0.
    teste_atual = 0 ## Referência para imprimir a população inicial
    
    for y in range(GLOBAL_QTD_TESTES):
        numero_avaliacoes = 0
        controle = True
        geracao = 0
        soma_fitness = []
        auxiliar = 0
        geracao_aux = 0
        formato_ee()
        formato_array_fitness()
        gera_formato_nos()
        formato_tabela_verdade()
        gera_formato_genotipo_mux()
        r.seed(y + seed_inicial)
        
        for t in range(ee_lambda + 1): # Gera a população inicial, diferente entre si (aleatoriamente).
            populacao_inicial_mux()
            define_saida()
            for j in range(ni):
                G[j] = copy.deepcopy(j)
            GENS_EVOL[t] = copy.deepcopy(G)
            
        nos_ativos_mux()


        for w in range(ee_lambda + 1):
            conta_portas_mux(w)
            monta_tabela_mux_porta(w)
            fit_auxiliar = 0
            for b in range(len(FITNESS_EE[w])):
                fit_auxiliar = fit_auxiliar + FITNESS_EE[w][b]
                if fit_auxiliar == no * len(OUTPUTS[0]):
                    print("CONVERGIU")
                                
                                
        
        arquivo2 = open('semente_populacao_inicial.txt', 'a')
        arquivo2.write("\n POPULAÇÃO INICIAL " + str(y+seed_inicial) + "\n")
        arquivo2.write(str(GENS_EVOL))
        arquivo2.close()
        
        arquivo_inicio = open('informacoes_processo.txt', 'a')
        arquivo_inicio.write("\n SEED: " + str(y+seed_inicial))
        arquivo_inicio.close()

        arquivo_evolucao_inicio = open('evolucao.txt', 'a')
        arquivo_evolucao_inicio.write("\n SEED: " + str(y+seed_inicial))
        arquivo_evolucao_inicio.write("\n")
        arquivo_evolucao_inicio.close()


        arquivo_genes_ativos = open("distribuicao_genes_ativos.txt", "a")
        arquivo_genes_ativos.write("\n SEED: " + str(y+seed_inicial))
        arquivo_genes_ativos.write("\n")
        arquivo_genes_ativos.close()

        arquivo_infoevol = open("informacoes_evolutivas.txt", "a")
        arquivo_infoevol.write("\n SEED: " + str(y+seed_inicial))
        arquivo_infoevol.write("\n")
        arquivo_infoevol.close()

        
        primeira_convergencia = False
        muda_atualiza_pai = False
        
        print("ENTROU")
        print("GERAÇÃO: ", geracao)
        while numero_avaliacoes <= GLOBAL_NUM_AVALIACOES:
            tempo_inicio = time.time()

            gc.collect()
            IND_MUT_SAM[0][0][0] = copy.deepcopy(0)
            IND_MUT_SAM[0][1][0] = copy.deepcopy(0)
            IND_MUT_SAM[1][0][0] = copy.deepcopy(0)
            IND_MUT_SAM[1][1][0] = copy.deepcopy(0)
            IND_MUT_GAM[0][0][0] = copy.deepcopy(0)
            IND_MUT_GAM[0][1][0] = copy.deepcopy(0)
            IND_MUT_GAM[1][0][0] = copy.deepcopy(0)
            IND_MUT_GAM[1][1][0] = copy.deepcopy(0)
            #atualiza_matriz_mutacoes()
              
            if muda_atualiza_pai == False:
                for k in range(ee_lambda):
                    #mutacao_SAM_CORRETO_mux(k+1)
                    if k == 0 or k == 1:
                        mutacao_SAM_CORRETO_mux(k+1)
                    else:
                        mutacao_GAM_CORRETO_mux(k+1)                    
            else:
                for k in range(ee_lambda):
                    mutacao_SAM_CORRETO_mux(k+1)

            nos_ativos_mux()

## -- CONTA A QUANTIDADE DE PORTAS DO PAI -- ##            
            portas_pai = 0
            portas_filho = 0
            if primeira_convergencia == True:
                portas_pai = copy.deepcopy(PORTAS_CKT[0])




## -- AVALIA OS LAMBDA FILHOS -- ##            
            for w in range(ee_lambda + 1):
                
                if w != 0: #Impede a reavaliação do indivíduo 0 (progenitor)
                    arquivo_evolucao = open('evolucao.txt', 'a')
                    arquivo_evolucao.write("\n --> INDIVIDUO ANALSIADO: " + str(w))
                    arquivo_evolucao.write("\n Número de avaliações: " + str(numero_avaliacoes))
                    arquivo_evolucao.write("\n Fitness antes: " + str(FITNESS_EE[w]))
                    fitness_antes_local = copy.deepcopy(FITNESS_EE[w])

                    conta_portas_mux(w)
                    
                    #monta_tabela_MUX(w)
                    monta_tabela_mux_porta(w)

                    numero_avaliacoes = numero_avaliacoes + 1
                    


                    arquivo_evolucao.write("\n Fitness depois: " + str(FITNESS_EE[w]))
                    if w == 1 or w == 2:
                        #arquivo_evolucao.write("\n IND MUT SAM" + str(IND_MUT_SAM[w-1]))
                        if IND_MUT_SAM[w-1][0][0] != 0:
                            if fitness_antes_local == FITNESS_EE[w]:
                                arquivo_evolucao.write("\n MUTAÇÃO TIPO PORTA NEUTRO")
                            else:
                                for elementos in range(len(fitness_antes_local)):
                                    if fitness_antes_local[elementos] < FITNESS_EE[w][elementos]:
                                        arquivo_evolucao.write("\n HOUVE MELHORA, PELO MENOS, NA SAÍDA " + str(elementos))
                                        #arquivo_evolucao.write("\n PORTA ANTES: " + str(IND_MUT_SAM[w-1][0][0]))
                                        #arquivo_evolucao.write("\n PORTA DEPOIS: " + str(IND_MUT_SAM[w-1][1][0]))
                                        porta_antes = IND_MUT_SAM[w-1][0][0]
                                        porta_depois = IND_MUT_SAM[w-1][1][0]
                                        preenche_matriz_benefico(porta_antes, porta_depois)
                                        break
                    if w == 3 or w == 4:
                        #arquivo_evolucao.write("\n IND MUT SAM" + str(IND_MUT_SAM[w-1]))
                        if IND_MUT_GAM[w-3][0][0] != 0:
                            if fitness_antes_local == FITNESS_EE[w]:
                                arquivo_evolucao.write("\n MUTAÇÃO TIPO PORTA NEUTRO")
                            else:
                                for elementos in range(len(fitness_antes_local)):
                                    if fitness_antes_local[elementos] < FITNESS_EE[w][elementos]:
                                        arquivo_evolucao.write("\n HOUVE MELHORA, PELO MENOS, NA SAÍDA " + str(elementos))
                                        #arquivo_evolucao.write("\n PORTA ANTES: " + str(IND_MUT_SAM[w-1][0][0]))
                                        #arquivo_evolucao.write("\n PORTA DEPOIS: " + str(IND_MUT_SAM[w-1][1][0]))
                                        porta_antes = IND_MUT_GAM[w-3][0][0]
                                        porta_depois = IND_MUT_GAM[w-3][1][0]
                                        #preenche_matriz_benefico(porta_antes, porta_depois)
                                        break



                                    
                    arquivo_evolucao.close()
                                                               
                else:
                    if muda_atualiza_pai == True: # Neste caso o indivíduo 0 deve ser reavaliado pois leva-se em conta o número de portas (função objetivo: minimizar o número de portas)
                        conta_portas_mux(w)
                        monta_tabela_mux_porta(w)
                        numero_avaliacoes = numero_avaliacoes + 1


                #arquivo_evolucao = open('evolucao.txt', 'a')
                #arquivo_evolucao.write("\n NOVAMENTE O IND MUT: " + str(IND_MUT_SAM))
                #arquivo_evolucao.close()
## -- VERIFICA FACTIBILIDADE DOS INDIVIDUOS -- ##
                auxiliar2 = 0

                for b in range(len(FITNESS_EE[w])):
                    auxiliar2 = auxiliar2 + FITNESS_EE[w][b]

                if auxiliar2 == (no * len(OUTPUTS[0])) and primeira_convergencia == False:
                    print(" CONVERGIU COM NÚMERO DE AVALIAÇÕES IGUAL A: ", numero_avaliacoes)
                    primeira_convergencia = True
                    muda_atualiza_pai = True
                    COSPE_ativo(w)
                    print("NÚMERO DE PORTAS: ", PORTAS_CKT[w])
                    print("INDIVIDUO: ", w)
                    arquivo_teste = open('convergencias.txt', 'a')
                    arquivo_teste.write("\n SEED: " + str(y+seed_inicial) + "\n")
                    arquivo_teste.write("CONVERGIU COM NÚMERO DE AVALIAÇÕES IGUAL A: " + str(numero_avaliacoes))
                    for j in range(no):
                        arquivo_teste.write("\n SAIDA: " + str(j))
                        for i in range(len(MEUARRAY[w][j])):
                            if MEUARRAY[w][j][i] == "X":
                                arquivo_teste.write("\n I = " + str(i) + " GENE = " + str(GENS_EVOL[w][i]))
                    
                    arquivo_teste.write("\n NÚMERO DE PORTAS: " + str(PORTAS_CKT[w]))
                    arquivo_teste.write("\n NÚMERO DE WIRES: " + str(WIRES_CKT[w]))
                    arquivo_teste.write("\n INDIVIDUO: " + str(w))
                    arquivo_teste.write("\n")
                    arquivo_teste.close()
                    #GENS_EVOL[0] = copy.deepcopy(GENS_EVOL[w])
                    numero_avaliacoes = 300000000
                    break
                    #print("GENS_EVOL: ", GENS_EVOL[w])


## -- DETERMINA QUAL É A FUNÇÃO OBJETIVO: ENCONTRAR FACTIBILIDADE (CROSSOVER) OU MINIMIZAR O NÚMERO DE PORTAS (PORTAS_FACTIVEL) -- ##
            if muda_atualiza_pai == True:
                atualiza_pai_PORTAS_FACTIVEL()
            else:
                #atualiza_pai_PORTAS_FACTIVEL()
                atualiza_pai_CROSSOVER_NOVO_MUX_PORTA()
                #atualiza_pai_CROSSOVER_NOVO_GENES_ATIVOS()


## -- VERIFICA SE O NOVO PROGENITOR (GERADO PELO CROSSOVER) É FACTÍVEL -- ##
                auxiliar2 = 0
                conta_portas(0)
                for b in range(len(FITNESS_EE[0])):
                    auxiliar2 = auxiliar2 + FITNESS_EE[0][b]

                if auxiliar2 == (no * len(OUTPUTS[0])) and primeira_convergencia == False:
                    print(" CONVERGIU COM NÚMERO DE AVALIAÇÕES IGUAL A: ", numero_avaliacoes)
                    primeira_convergencia = True
                    muda_atualiza_pai = True
                    COSPE_ativo(0)
                    print("NÚMERO DE PORTAS: ", PORTAS_CKT[0])
                    print("INDIVIDUO: 0", )
                    arquivo_teste = open('convergencias.txt', 'a')
                    arquivo_teste.write("\n SEED: " + str(y+seed_inicial) + "\n")
                    arquivo_teste.write("CONVERGIU COM NÚMERO DE AVALIAÇÕES IGUAL A: " + str(numero_avaliacoes))
                    for j in range(no):
                        arquivo_teste.write("\n SAIDA: " + str(j))
                        for i in range(len(MEUARRAY[0][j])):
                            if MEUARRAY[0][j][i] == "X":
                                arquivo_teste.write("\n I = " + str(i) + " GENE = " + str(GENS_EVOL[0][i]))
                    
                    arquivo_teste.write("\n NÚMERO DE PORTAS: " + str(PORTAS_CKT[0]))
                    arquivo_teste.write("\n NÚMERO DE WIRES: " + str(WIRES_CKT[0]))
                    arquivo_teste.write("\n INDIVIDUO: " + str(w))
                    arquivo_teste.write("\n")
                    arquivo_teste.close()
                    numero_avaliacoes = 300000000
                    break
                    #print("GENS_EVOL: ", GENS_EVOL[0])                


## -- VERIFICA A QUANTIDADE DE PORTAS DO FILHO SOMENTE CASO A FUNÇÃO OBJETIVO TENHA MUDADO (MINIMIZAR NÚMERO DE PORTAS LÓGICAS) -- ##
            if primeira_convergencia == True:
                portas_filho = copy.deepcopy(PORTAS_CKT[0])

            if portas_filho < portas_pai:
                arquivo_aolongo = open('informacoes_processo.txt', 'a')
                arquivo_aolongo.write("\n MUDANÇA NO NÚMERO DE PORTAS")
                arquivo_aolongo.write("\n PAI:" + str(portas_pai))
                arquivo_aolongo.write("\n FILHO: " + str(portas_filho))
                arquivo_aolongo.write("\n NÚMERO DE AVALIAÇÕES: " + str(numero_avaliacoes))
                arquivo_aolongo.close()

            soma_fitness.clear()

            for b in range(len(FITNESS_EE)):
                for c in range(len(FITNESS_EE[b])):
                    auxiliar = auxiliar + FITNESS_EE[b][c]
                soma_fitness.append(auxiliar)
                auxiliar = 0

            geracao = geracao + 1


## -- EXIBE AS FITNESS POR GERAÇÃO -- ##
            todos_ativos = []
            for genes in range(len(MEUARRAY[0])):
                for cada in range(len(MEUARRAY[0][genes])):
                    if MEUARRAY[0][genes][cada] == "X":
                        todos_ativos.append(cada)
            novo_array = []
            for itens in todos_ativos:
                if itens not in novo_array:
                    novo_array.append(itens)
            variavel_auxiliar_fitness_saida = 0
            for fitness_saida in range(len(FITNESS_EE[0])):
                variavel_auxiliar_fitness_saida += FITNESS_EE[0][fitness_saida]


            arquivo_infoevol = open("informacoes_evolutivas.txt", "a")
            arquivo_infoevol.write("\n Avaliações: " + str(numero_avaliacoes) + " Fitness Pai: " + str(FITNESS_EE[0]))
            arquivo_infoevol.close()

            arquivo_evolucao = open("evolucao.txt", "a")
            arquivo_evolucao.write("\n Fitness Pai: " + str(FITNESS_EE[0]))
            arquivo_evolucao.write(" (( " + str(variavel_auxiliar_fitness_saida) + " )) ")
            
            arquivo_evolucao.write("\n Quantidade de genes ativos: " + str(len(novo_array)))
            arquivo_evolucao.close()

            arquivo_genes_ativos = open("distribuicao_genes_ativos.txt", "a")
            arquivo_genes_ativos.write("\nGeração: " + str(geracao))
            arquivo_genes_ativos.write("\nDistribuição: " + str(novo_array))
            arquivo_genes_ativos.close()

            arquivo_genes_ativos = open("genes_ativos.txt", "a")
            arquivo_genes_ativos.write("\n" + str(geracao) + ", " + str(len(novo_array)))
            arquivo_genes_ativos.close()
            
            #print("Quantidade de genes ativos: ", len(novo_array))
            if numero_avaliacoes <= 20:
                print("\nNÚMERO DE AVALIAÇÕES : " + str(numero_avaliacoes))
                print(soma_fitness)
                #arquivo_evolucao = open("evolucao.txt", "a")
                #arquivo_evolucao.write("\n Número de avaliações: " + str(numero_avaliacoes))
                #arquivo_evolucao.write("\n Fitness pai: " + str(FITNESS_EE[0]))
                #arquivo_evolucao.write("\n Genes ativos pai: " + str(len(novo_array)))
                print("Genes ativos: ", len(novo_array))
            if numero_avaliacoes % 400 == 0:
                print("\nNÚMERO DE AVALIAÇÕES : " + str(numero_avaliacoes))
                print(soma_fitness)
                #arquivo_evolucao = open("evolucao.txt", "a")
                #arquivo_evolucao.write("\n Número de avaliações: " + str(numero_avaliacoes))
                #arquivo_evolucao.write("\n Fitness pai: " + str(FITNESS_EE[0]))
                #arquivo_evolucao.write("\n Genes ativos pai: " + str(len(novo_array)))
                print("Genes ativos: ", len(novo_array))
            if geracao <= 20:
                print("\nGERAÇÃO : " + str(geracao))
                print(soma_fitness)
            if geracao % 1000 == 0:
                print("\nGERAÇÃO : " + str(geracao))
                print(soma_fitness)



        print("FIM", geracao)
        
        tempo_fim = time.time()
        
        arquivo_aolongo2 = open('informacoes_processo.txt', 'a')
        arquivo_aolongo2.write("\n FIM \n")
        arquivo_aolongo2.write("Tempo decorrido: " + str((tempo_fim - tempo_inicio)/60) + " minutos.")
        arquivo_aolongo2.write("\n")
        arquivo_aolongo2.close()


        
## -- ARMAZENA SEEDS QUE NÃO CONVERGIRAM E SEUS GENÓTIPOS -- ##
        if primeira_convergencia == False:
            arquivo_sem_convergencia = open('sem_convergencia.txt', 'a')
            arquivo_sem_convergencia.write("SEED : " + str(y+seed_inicial) + "\n")
            arquivo_sem_convergencia.write("FITNESS: " + str(FITNESS_EE[0]) + "\n")
            arquivo_sem_convergencia.write("MELHOR INDIVÍDUO: 0") 
            for j in range(no):
                arquivo_sem_convergencia.write("\n SAIDA: " + str(j))
                for i in range(len(MEUARRAY[0][j])):
                    if MEUARRAY[0][j][i] == "X":
                        arquivo_sem_convergencia.write("\n I = " + str(i) + " GENE = " + str(GENS_EVOL[0][i])) 
            arquivo_sem_convergencia.write("\n NÚMERO DE PORTAS: " + str(PORTAS_CKT[0]))
            arquivo_sem_convergencia.write("\n NÚMERO DE WIRES: " + str(WIRES_CKT[0]))
            arquivo_sem_convergencia.write("\n")
            arquivo_sem_convergencia.write("GENÓTIPO FINAL: " + str(GENS_EVOL[0]) + "\n")
            
            arquivo_sem_convergencia.close()        
        
## -- PREENCHE ARQUIVO DE MATRIZ DE TRANSIÇÃO -- ##
        arquivo = open('matriz_transicao.txt', 'a')
        arquivo.write("\n MATRIZ INFACTIVEL \n")
        arquivo.write(str(MATRIZ_REGIAO_INFACTIVEL))
        arquivo.write("\n MATRIZ FACTIVEL \n")
        arquivo.write(str(MATRIZ_REGIAO_FACTIVEL))
        arquivo.close()

        COSPE_ativo(0)
        
        for i in range(ee_lambda + 1):
            conta_portas(i)
        print("NÚMERO DE PORTAS: ", PORTAS_EE[0][no-1])
        if primeira_convergencia == True:
            arquivo_otimizado = open('convergencias_otimizado.txt', 'a')
            arquivo_otimizado.write("\n SEED: " + str(y+seed_inicial) + "\n")
            arquivo_otimizado.write("CONVERGIU COM NÚMERO DE AVALIAÇÕES IGUAL A: " + str(numero_avaliacoes))
            for j in range(no):
                arquivo_otimizado.write("\n SAIDA: " + str(j))
                for i in range(len(MEUARRAY[0][j])):
                    if MEUARRAY[0][j][i] == "X":
                        arquivo_otimizado.write("\n I = " + str(i) + " GENE = " + str(GENS_EVOL[0][i]))
                    
            arquivo_otimizado.write("\n NÚMERO DE PORTAS: " + str(PORTAS_CKT[0]))
            arquivo_otimizado.write("\n NÚMERO DE WIRES: " + str(WIRES_CKT[0]))
            arquivo_otimizado.write("\n INDIVIDUO: " + str(0))
            arquivo_otimizado.write("\n")
            arquivo_otimizado.close()

        
        
        limpa_array()

        teste_atual = teste_atual + 1

        arquivo_evolucao = open('evolucao.txt', 'a')
        arquivo_evolucao.write("\nFREQUÊNCIA DAS MUTAÇÕES")
        arquivo_evolucao.write("\nSAM:")
        arquivo_evolucao.write("\nSAIDA: " + str(GLOBAL_MUTACAO_SAM_SAIDA))
        arquivo_evolucao.write("\nINPUT: " + str(GLOBAL_MUTACAO_SAM_INPUT))
        arquivo_evolucao.write("\nPORTA: " + str(GLOBAL_MUTACAO_SAM_PORTA))
        arquivo_evolucao.write("\n ATIVOS SAM: " + str(GLOBAL_MUTACAO_SAM_ATIVO))
        arquivo_evolucao.write("\n INATIVOS SAM: " + str(GLOBAL_MUTACAO_SAM_INATIVO))        
        arquivo_evolucao.write("\nGAM:")
        arquivo_evolucao.write("\nSAIDA: " + str(GLOBAL_MUTACAO_GAM_SAIDA))
        arquivo_evolucao.write("\nINPUT: " + str(GLOBAL_MUTACAO_GAM_INPUT))
        arquivo_evolucao.write("\nPORTA: " + str(GLOBAL_MUTACAO_GAM_PORTA))
        arquivo_evolucao.write("\n ATIVOS GAM: " + str(GLOBAL_MUTACAO_GAM_ATIVO))
        arquivo_evolucao.write("\n INATIVOS GAM: " + str(GLOBAL_MUTACAO_GAM_INATIVO))
        arquivo_evolucao.write("\n")
        arquivo_evolucao.write("\n QUANTIDADE DE CROSSOVERS REALIZADOS: " + str(GLOBAL_QTD_CROSSOVER))
        arquivo_evolucao.write("\n QUANTIDADE DE SAIDAS INCORPORADAS: " + str(GLOBAL_QTD_CROSSOVER_SAIDA))
        arquivo_evolucao.write("\n")
        arquivo_evolucao.write("\n")
        arquivo_evolucao.write("\nTROCA DE PORTAS: ")
        arquivo_evolucao.write("\n " + str(GATE_INFAC))
        arquivo_evolucao.write("\n")
        arquivo_evolucao.write("\n")
        arquivo_evolucao.write("\nTROCA DE PORTAS BENÉFICAS: ")
        arquivo_evolucao.write("\n " + str(GATE_INFAC_BEN))        
        arquivo_evolucao.close()


        arquivo_infoevol = open("informacoes_evolutivas.txt", "a")
        arquivo_infoevol.write("\nFREQUÊNCIA DAS MUTAÇÕES")
        arquivo_infoevol.write("\nSAM:")
        arquivo_infoevol.write("\nSAIDA: " + str(GLOBAL_MUTACAO_SAM_SAIDA))
        arquivo_infoevol.write("\nINPUT: " + str(GLOBAL_MUTACAO_SAM_INPUT))
        arquivo_infoevol.write("\nPORTA: " + str(GLOBAL_MUTACAO_SAM_PORTA))
        arquivo_infoevol.write("\n ATIVOS SAM: " + str(GLOBAL_MUTACAO_SAM_ATIVO))
        arquivo_infoevol.write("\n INATIVOS SAM: " + str(GLOBAL_MUTACAO_SAM_INATIVO))        
        arquivo_infoevol.write("\nGAM:")
        arquivo_infoevol.write("\nSAIDA: " + str(GLOBAL_MUTACAO_GAM_SAIDA))
        arquivo_infoevol.write("\nINPUT: " + str(GLOBAL_MUTACAO_GAM_INPUT))
        arquivo_infoevol.write("\nPORTA: " + str(GLOBAL_MUTACAO_GAM_PORTA))
        arquivo_infoevol.write("\n ATIVOS GAM: " + str(GLOBAL_MUTACAO_GAM_ATIVO))
        arquivo_infoevol.write("\n INATIVOS GAM: " + str(GLOBAL_MUTACAO_GAM_INATIVO))
        arquivo_infoevol.write("\n")
        arquivo_infoevol.write("\n QUANTIDADE DE CROSSOVERS REALIZADOS: " + str(GLOBAL_QTD_CROSSOVER))
        arquivo_infoevol.write("\n QUANTIDADE DE SAIDAS INCORPORADAS: " + str(GLOBAL_QTD_CROSSOVER_SAIDA))
        arquivo_infoevol.write("\n")
        arquivo_infoevol.write("\n")
        arquivo_infoevol.write("\nTROCA DE PORTAS: ")
        arquivo_infoevol.write("\n " + str(GATE_INFAC))
        arquivo_infoevol.write("\n")
        arquivo_infoevol.write("\n")
        arquivo_infoevol.write("\nTROCA DE PORTAS BENÉFICAS: ")
        arquivo_infoevol.write("\n " + str(GATE_INFAC_BEN))        
        arquivo_infoevol.close()



        numero_avaliacoes = 0

###########################################################




def main_CGP_3E():
    
    seed_inicial = 0 #Mudar este valor quando tiver que executar alguma seed específica que não começa por 0.
    teste_atual = 0 ## Referência para imprimir a população inicial
    
    for y in range(GLOBAL_QTD_TESTES):
        numero_avaliacoes = 0
        controle = True
        geracao = 0
        soma_fitness = []
        auxiliar = 0
        geracao_aux = 0
        formato_ee()
        formato_array_fitness()
        gera_formato_nos()
        formato_tabela_verdade()
        gera_formato_genotipo_mux()
        r.seed(y + seed_inicial)
        
        for t in range(ee_lambda + 1): # Gera a população inicial, diferente entre si (aleatoriamente).
            populacao_inicial_mux()
            define_saida()
            for j in range(ni):
                G[j] = copy.deepcopy(j)
            GENS_EVOL[t] = copy.deepcopy(G)
            
        nos_ativos_mux()


        for w in range(ee_lambda + 1):
            conta_portas_mux(w)
            monta_tabela_mux(w)
            fit_auxiliar = 0
            for b in range(len(FITNESS_EE[w])):
                fit_auxiliar = fit_auxiliar + FITNESS_EE[w][b]
                if fit_auxiliar == no * len(OUTPUTS[0]):
                    print("CONVERGIU")
        
        primeira_convergencia = False
        muda_atualiza_pai = False
        
        factibilidade_ckt = False
        print("ENTROU")
        print("GERAÇÃO: ", geracao)

        while factibilidade_ckt == False:
            while numero_avaliacoes < int(0.3*GLOBAL_NUM_AVALIACOES): #and factibilidade_ckt == False:


                gc.collect()

                  
                if muda_atualiza_pai == False:
                    for k in range(ee_lambda):
                        if k == 0 or k == 1:
                            mutacao_SAM_CORRETO_mux(k+1)
                        else:
                            mutacao_GAM_CORRETO_mux(k+1)                    
                else:
                    for k in range(ee_lambda):
                        mutacao_SAM_CORRETO_mux(k+1)

                nos_ativos_mux()



    ## -- AVALIA OS LAMBDA FILHOS -- ##            
                for w in range(ee_lambda + 1):
                    

                    conta_portas_mux(w)
                    
                    monta_tabela_mux(w)

                    numero_avaliacoes = numero_avaliacoes + 1
                                                                   

                atualiza_pai_PORTAS_FACTIVEL_CONTROLEMUX()
                nos_ativos_mux()

                todas_fitness = []
                soma_todas_fitness = 0
                for fitness in range(len(FITNESS_EE)):
                    for cada in range(len(FITNESS_EE[fitness])):
                        soma_todas_fitness += FITNESS_EE[fitness][cada]
                    if soma_todas_fitness == len(OUTPUTS[0]) * no:
                        factibilidade_ckt = True
                    soma_todas_fitness = 0

                    
    ## -- EXIBE AS FITNESS POR GERAÇÃO -- ##
                todos_ativos = []
                for genes in range(len(MEUARRAY[0])):
                    for cada in range(len(MEUARRAY[0][genes])):
                        if MEUARRAY[0][genes][cada] == "X":
                            todos_ativos.append(cada)
                novo_array = []
                for itens in todos_ativos:
                    if itens not in novo_array:
                        novo_array.append(itens)
                variavel_auxiliar_fitness_saida = 0
                for fitness_saida in range(len(FITNESS_EE[0])):
                    variavel_auxiliar_fitness_saida += FITNESS_EE[0][fitness_saida]

                fitness_aqui_antes = []
                soma_fitness_antes_aqui = 0
                for fitness in range(len(FITNESS_EE)):
                    for cada in range(len(FITNESS_EE[fitness])):
                        soma_fitness_antes_aqui += FITNESS_EE[fitness][cada]
                    fitness_aqui_antes.append(soma_fitness_antes_aqui)
                    soma_fitness_antes_aqui = 0
                if numero_avaliacoes <= 20:
                    print("\nNÚMERO DE AVALIAÇÕES : " + str(numero_avaliacoes))
                    print(fitness_aqui_antes)
                    #arquivo_evolucao = open("evolucao.txt", "a")
                    #arquivo_evolucao.write("\n Número de avaliações: " + str(numero_avaliacoes))
                    #arquivo_evolucao.write("\n Fitness pai: " + str(FITNESS_EE[0]))
                    #arquivo_evolucao.write("\n Genes ativos pai: " + str(len(novo_array)))
                    print("Genes ativos: ", len(novo_array))
                if numero_avaliacoes % 400 == 0:
                    print("\nNÚMERO DE AVALIAÇÕES : " + str(numero_avaliacoes))
                    print(fitness_aqui_antes)
                    print(COMUNS_EE)
                    #arquivo_evolucao = open("evolucao.txt", "a")
                    #arquivo_evolucao.write("\n Número de avaliações: " + str(numero_avaliacoes))
                    #arquivo_evolucao.write("\n Fitness pai: " + str(FITNESS_EE[0]))
                    #arquivo_evolucao.write("\n Genes ativos pai: " + str(len(novo_array)))
                    print("Genes ativos: ", len(novo_array))
                if geracao <= 20:
                    print("\nGERAÇÃO : " + str(geracao))
                    print(fitness_aqui_antes)
                if geracao % 1000 == 0:
                    print("\nGERAÇÃO : " + str(geracao))
                    print(fitness_aqui_antes)

                geracao += 1

        print("TERMINOU A BUSCA PELOS SUBCIRCUITOS")
        formato_outputs_controle()
        cria_TABELA_CONTROLE(0)
        arquivo_tabela_controle = open("tabelas_controle.txt", "a")
        arquivo_tabela_controle.write("\n SEED: " + str(y+seed_inicial) + "\n")
        arquivo_tabela_controle.write(str(OUTPUTS_CONTROLE))
        arquivo_tabela_controle.write("\n")
        arquivo_tabela_controle.close()
        print("INICIA A BUSCA PELO CONTROLE")
            
        CIRCUITO_SUBCIRCUITOS = copy.deepcopy(GENS_EVOL[0])
        COSPE_ativo(0)
        arquivo_teste = open('convergencias_i0i1.txt', 'a')
        arquivo_teste.write("\n SEED: " + str(y+seed_inicial) + "\n")
        arquivo_teste.write("CONVERGIU COM NÚMERO DE AVALIAÇÕES IGUAL A: " + str(numero_avaliacoes))
        for j in range(no):
            arquivo_teste.write("\n SAIDA: " + str(j))
            for i in range(len(MEUARRAY[0][j])):
                if MEUARRAY[0][j][i] == "X":
                    arquivo_teste.write("\n I = " + str(i) + " GENE = " + str(GENS_EVOL[0][i]))
        
        arquivo_teste.write("\n NÚMERO DE PORTAS: " + str(PORTAS_CKT[0]))
        arquivo_teste.write("\n NÚMERO DE WIRES: " + str(WIRES_CKT[0]))
        arquivo_teste.write("\n NÚMERO DE MUXES: " + str(MUX_CKT[0]))
        arquivo_teste.write("\n INDIVIDUO: 0")
        arquivo_teste.write("\n")
        arquivo_teste.close()

        arquivo_comuns_ee = open('entradas_comuns.txt', 'a')
        arquivo_comuns_ee.write("\n SEED: " + str(y+seed_inicial) + "\n")
        arquivo_comuns_ee.write(str(COMUNS_EE))
        arquivo_comuns_ee.write("\n")
        arquivo_comuns_ee.close()
        

        
        limpa_array()
            
        controle = True

        soma_fitness = []
        auxiliar = 0
        geracao_aux = 0
        formato_ee()
        formato_array_fitness()
        gera_formato_nos()
        formato_tabela_verdade()
        gera_formato_genotipo_mux()
        
        for t in range(ee_lambda + 1): # Gera a população inicial, diferente entre si (aleatoriamente).
            populacao_inicial_mux2()
            define_saida()
            for j in range(ni):
                G[j] = copy.deepcopy(j)
            GENS_EVOL[t] = copy.deepcopy(G)
            
        nos_ativos_mux()
        for w in range(ee_lambda + 1):
            monta_tabela_mux2(w)
        fitness_aqui = []
        soma_fitness_aqui = 0
        for i in range(len(FITNESS_EE)):
            for j in range(len(FITNESS_EE[i])):
                soma_fitness_aqui += FITNESS_EE[i][j]
            fitness_aqui.append(soma_fitness)
            if soma_fitness == no * len(OUTPUTS[0]):
                print("CONVERGIU")
            soma_fitness_aqui = 0

        while numero_avaliacoes <= GLOBAL_NUM_AVALIACOES:
            
            if muda_atualiza_pai == False:
                for k in range(ee_lambda):
                    if k == 0 or k == 1:
                        mutacao_SAM_CORRETO_mux(k+1)
                    else:
                        mutacao_GAM_CORRETO_mux(k+1)                    
            else:
                for k in range(ee_lambda):
                    mutacao_SAM_CORRETO_mux(k+1)

            nos_ativos_mux()            

            
            
            for w in range(ee_lambda + 1):
                

                conta_portas_mux(w)
                
                monta_tabela_mux2(w)

                numero_avaliacoes = numero_avaliacoes + 1
                #print(numero_avaliacoes)
                #print(w+1)

            soma_fitness_local = 0
            soma_fitness_local_aqui = []
            for g in range(len(FITNESS_EE)):
                for h in range(len(FITNESS_EE[g])):
                    soma_fitness_local += FITNESS_EE[g][h]
                soma_fitness_local_aqui.append(soma_fitness_local)
                soma_fitness_local = 0

            for w in range(ee_lambda + 1):

                if soma_fitness_local_aqui[w] == no * len(OUTPUTS[0]):
                    print("INDIVIDUO: ", w)
                    print("FITNESS: ", soma_fitness_local_aqui[w])
                    print(" CONVERGIU COM NÚMERO DE AVALIAÇÕES IGUAL A: ", numero_avaliacoes-(4-w))
                    primeira_convergencia = True
                    muda_atualiza_pai = True
                    COSPE_ativo(w)
                    print("NÚMERO DE PORTAS: ", PORTAS_CKT[w])

                    arquivo_teste = open('convergencias.txt', 'a')
                    arquivo_teste.write("\n SEED: " + str(y+seed_inicial) + "\n")
                    arquivo_teste.write("CONVERGIU COM NÚMERO DE AVALIAÇÕES IGUAL A: " + str(numero_avaliacoes-(4-w)))
                    for j in range(no):
                        arquivo_teste.write("\n SAIDA: " + str(j))
                        for i in range(len(MEUARRAY[w][j])):
                            if MEUARRAY[g][j][i] == "X":
                                arquivo_teste.write("\n I = " + str(i) + " GENE = " + str(GENS_EVOL[w][i]))
                    
                    arquivo_teste.write("\n NÚMERO DE PORTAS: " + str(PORTAS_CKT[w]))
                    arquivo_teste.write("\n NÚMERO DE WIRES: " + str(WIRES_CKT[w]))
                    arquivo_teste.write("\n NÚMERO DE MUXES: " + str(MUX_CKT[w]))
                    arquivo_teste.write("\n INDIVIDUO: " + str(w))
                    arquivo_teste.write("\n")
                    arquivo_teste.close()
                    numero_avaliacoes = 300000000
                    break

                    

            #atualiza_pai_SOCONTROLE_MUX()
            atualiza_pai_CROSSOVER_NOVO_MUX2()
            fitness_impressao = []
            soma_impressao = 0
            for fitness in range(len(FITNESS_EE)):
                for cada in range(len(FITNESS_EE[fitness])):
                    soma_impressao += FITNESS_EE[fitness][cada]
                fitness_impressao.append(soma_impressao)
                soma_impressao = 0
            if numero_avaliacoes % 400 == 0:
                print("\nNÚMERO DE AVALIAÇÕES : " + str(numero_avaliacoes))
                print(fitness_impressao)
                   
        limpa_array()
        limpa_array_controle()
        teste_atual = teste_atual + 1
        numero_avaliacoes = 0
###########################################################















        
#main_SAM_G_2P_CROSSOVER()
#main_SAM_G_2P()
#main_GAM_G_2P_CROSSOVER()
#main_SAMGAM_G_2P_CROSSOVER()
#main_SAM_G_2P_CROSSOVER_MUX()
main_CGP_3E()
#main_GAM_G_2P()
